
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model SellPoint
 * 
 */
export type SellPoint = $Result.DefaultSelection<Prisma.$SellPointPayload>
/**
 * Model Patent
 * 
 */
export type Patent = $Result.DefaultSelection<Prisma.$PatentPayload>
/**
 * Model PatentValidation
 * 
 */
export type PatentValidation = $Result.DefaultSelection<Prisma.$PatentValidationPayload>
/**
 * Model DeletedPatents
 * 
 */
export type DeletedPatents = $Result.DefaultSelection<Prisma.$DeletedPatentsPayload>
/**
 * Model AssignHoursReports
 * 
 */
export type AssignHoursReports = $Result.DefaultSelection<Prisma.$AssignHoursReportsPayload>
/**
 * Model AssignPatentHoursReports
 * 
 */
export type AssignPatentHoursReports = $Result.DefaultSelection<Prisma.$AssignPatentHoursReportsPayload>
/**
 * Model SellingHoursReports
 * 
 */
export type SellingHoursReports = $Result.DefaultSelection<Prisma.$SellingHoursReportsPayload>
/**
 * Model UserHoursReports
 * 
 */
export type UserHoursReports = $Result.DefaultSelection<Prisma.$UserHoursReportsPayload>
/**
 * Model UserParkingReports
 * 
 */
export type UserParkingReports = $Result.DefaultSelection<Prisma.$UserParkingReportsPayload>
/**
 * Model HoursPrices
 * 
 */
export type HoursPrices = $Result.DefaultSelection<Prisma.$HoursPricesPayload>
/**
 * Model Parking
 * 
 */
export type Parking = $Result.DefaultSelection<Prisma.$ParkingPayload>
/**
 * Model Infraction
 * 
 */
export type Infraction = $Result.DefaultSelection<Prisma.$InfractionPayload>
/**
 * Model InfractionImage
 * 
 */
export type InfractionImage = $Result.DefaultSelection<Prisma.$InfractionImagePayload>
/**
 * Model SingleParkingComprobant
 * 
 */
export type SingleParkingComprobant = $Result.DefaultSelection<Prisma.$SingleParkingComprobantPayload>
/**
 * Model SellingHoursComprobant
 * 
 */
export type SellingHoursComprobant = $Result.DefaultSelection<Prisma.$SellingHoursComprobantPayload>
/**
 * Model Holiday
 * 
 */
export type Holiday = $Result.DefaultSelection<Prisma.$HolidayPayload>
/**
 * Model SellingPointHoursComprobant
 * 
 */
export type SellingPointHoursComprobant = $Result.DefaultSelection<Prisma.$SellingPointHoursComprobantPayload>
/**
 * Model SellingMonthlyComprobant
 * 
 */
export type SellingMonthlyComprobant = $Result.DefaultSelection<Prisma.$SellingMonthlyComprobantPayload>
/**
 * Model Movie
 * 
 */
export type Movie = $Result.DefaultSelection<Prisma.$MoviePayload>
/**
 * Model Showing
 * 
 */
export type Showing = $Result.DefaultSelection<Prisma.$ShowingPayload>
/**
 * Model Seat
 * 
 */
export type Seat = $Result.DefaultSelection<Prisma.$SeatPayload>
/**
 * Model SeatHold
 * 
 */
export type SeatHold = $Result.DefaultSelection<Prisma.$SeatHoldPayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model Ticket
 * 
 */
export type Ticket = $Result.DefaultSelection<Prisma.$TicketPayload>
/**
 * Model CinemaCredit
 * 
 */
export type CinemaCredit = $Result.DefaultSelection<Prisma.$CinemaCreditPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  CUSTOMER: 'CUSTOMER',
  EMPLOYEE: 'EMPLOYEE',
  ADMIN: 'ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Format: {
  TWO_D: 'TWO_D',
  THREE_D: 'THREE_D'
};

export type Format = (typeof Format)[keyof typeof Format]


export const ShowingStatus: {
  SCHEDULED: 'SCHEDULED',
  CANCELLED: 'CANCELLED'
};

export type ShowingStatus = (typeof ShowingStatus)[keyof typeof ShowingStatus]


export const SeatStatus: {
  AVAILABLE: 'AVAILABLE',
  HELD: 'HELD',
  SOLD_ONLINE: 'SOLD_ONLINE',
  SOLD_PHYSICAL: 'SOLD_PHYSICAL'
};

export type SeatStatus = (typeof SeatStatus)[keyof typeof SeatStatus]


export const BookingStatus: {
  RESERVED: 'RESERVED',
  PAID: 'PAID',
  CANCELLED: 'CANCELLED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const PurchaseChannel: {
  ONLINE: 'ONLINE',
  PHYSICAL: 'PHYSICAL'
};

export type PurchaseChannel = (typeof PurchaseChannel)[keyof typeof PurchaseChannel]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Format = $Enums.Format

export const Format: typeof $Enums.Format

export type ShowingStatus = $Enums.ShowingStatus

export const ShowingStatus: typeof $Enums.ShowingStatus

export type SeatStatus = $Enums.SeatStatus

export const SeatStatus: typeof $Enums.SeatStatus

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type PurchaseChannel = $Enums.PurchaseChannel

export const PurchaseChannel: typeof $Enums.PurchaseChannel

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.sellPoint`: Exposes CRUD operations for the **SellPoint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SellPoints
    * const sellPoints = await prisma.sellPoint.findMany()
    * ```
    */
  get sellPoint(): Prisma.SellPointDelegate<ExtArgs>;

  /**
   * `prisma.patent`: Exposes CRUD operations for the **Patent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patents
    * const patents = await prisma.patent.findMany()
    * ```
    */
  get patent(): Prisma.PatentDelegate<ExtArgs>;

  /**
   * `prisma.patentValidation`: Exposes CRUD operations for the **PatentValidation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PatentValidations
    * const patentValidations = await prisma.patentValidation.findMany()
    * ```
    */
  get patentValidation(): Prisma.PatentValidationDelegate<ExtArgs>;

  /**
   * `prisma.deletedPatents`: Exposes CRUD operations for the **DeletedPatents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeletedPatents
    * const deletedPatents = await prisma.deletedPatents.findMany()
    * ```
    */
  get deletedPatents(): Prisma.DeletedPatentsDelegate<ExtArgs>;

  /**
   * `prisma.assignHoursReports`: Exposes CRUD operations for the **AssignHoursReports** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssignHoursReports
    * const assignHoursReports = await prisma.assignHoursReports.findMany()
    * ```
    */
  get assignHoursReports(): Prisma.AssignHoursReportsDelegate<ExtArgs>;

  /**
   * `prisma.assignPatentHoursReports`: Exposes CRUD operations for the **AssignPatentHoursReports** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssignPatentHoursReports
    * const assignPatentHoursReports = await prisma.assignPatentHoursReports.findMany()
    * ```
    */
  get assignPatentHoursReports(): Prisma.AssignPatentHoursReportsDelegate<ExtArgs>;

  /**
   * `prisma.sellingHoursReports`: Exposes CRUD operations for the **SellingHoursReports** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SellingHoursReports
    * const sellingHoursReports = await prisma.sellingHoursReports.findMany()
    * ```
    */
  get sellingHoursReports(): Prisma.SellingHoursReportsDelegate<ExtArgs>;

  /**
   * `prisma.userHoursReports`: Exposes CRUD operations for the **UserHoursReports** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserHoursReports
    * const userHoursReports = await prisma.userHoursReports.findMany()
    * ```
    */
  get userHoursReports(): Prisma.UserHoursReportsDelegate<ExtArgs>;

  /**
   * `prisma.userParkingReports`: Exposes CRUD operations for the **UserParkingReports** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserParkingReports
    * const userParkingReports = await prisma.userParkingReports.findMany()
    * ```
    */
  get userParkingReports(): Prisma.UserParkingReportsDelegate<ExtArgs>;

  /**
   * `prisma.hoursPrices`: Exposes CRUD operations for the **HoursPrices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HoursPrices
    * const hoursPrices = await prisma.hoursPrices.findMany()
    * ```
    */
  get hoursPrices(): Prisma.HoursPricesDelegate<ExtArgs>;

  /**
   * `prisma.parking`: Exposes CRUD operations for the **Parking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parkings
    * const parkings = await prisma.parking.findMany()
    * ```
    */
  get parking(): Prisma.ParkingDelegate<ExtArgs>;

  /**
   * `prisma.infraction`: Exposes CRUD operations for the **Infraction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Infractions
    * const infractions = await prisma.infraction.findMany()
    * ```
    */
  get infraction(): Prisma.InfractionDelegate<ExtArgs>;

  /**
   * `prisma.infractionImage`: Exposes CRUD operations for the **InfractionImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InfractionImages
    * const infractionImages = await prisma.infractionImage.findMany()
    * ```
    */
  get infractionImage(): Prisma.InfractionImageDelegate<ExtArgs>;

  /**
   * `prisma.singleParkingComprobant`: Exposes CRUD operations for the **SingleParkingComprobant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SingleParkingComprobants
    * const singleParkingComprobants = await prisma.singleParkingComprobant.findMany()
    * ```
    */
  get singleParkingComprobant(): Prisma.SingleParkingComprobantDelegate<ExtArgs>;

  /**
   * `prisma.sellingHoursComprobant`: Exposes CRUD operations for the **SellingHoursComprobant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SellingHoursComprobants
    * const sellingHoursComprobants = await prisma.sellingHoursComprobant.findMany()
    * ```
    */
  get sellingHoursComprobant(): Prisma.SellingHoursComprobantDelegate<ExtArgs>;

  /**
   * `prisma.holiday`: Exposes CRUD operations for the **Holiday** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Holidays
    * const holidays = await prisma.holiday.findMany()
    * ```
    */
  get holiday(): Prisma.HolidayDelegate<ExtArgs>;

  /**
   * `prisma.sellingPointHoursComprobant`: Exposes CRUD operations for the **SellingPointHoursComprobant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SellingPointHoursComprobants
    * const sellingPointHoursComprobants = await prisma.sellingPointHoursComprobant.findMany()
    * ```
    */
  get sellingPointHoursComprobant(): Prisma.SellingPointHoursComprobantDelegate<ExtArgs>;

  /**
   * `prisma.sellingMonthlyComprobant`: Exposes CRUD operations for the **SellingMonthlyComprobant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SellingMonthlyComprobants
    * const sellingMonthlyComprobants = await prisma.sellingMonthlyComprobant.findMany()
    * ```
    */
  get sellingMonthlyComprobant(): Prisma.SellingMonthlyComprobantDelegate<ExtArgs>;

  /**
   * `prisma.movie`: Exposes CRUD operations for the **Movie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Movies
    * const movies = await prisma.movie.findMany()
    * ```
    */
  get movie(): Prisma.MovieDelegate<ExtArgs>;

  /**
   * `prisma.showing`: Exposes CRUD operations for the **Showing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Showings
    * const showings = await prisma.showing.findMany()
    * ```
    */
  get showing(): Prisma.ShowingDelegate<ExtArgs>;

  /**
   * `prisma.seat`: Exposes CRUD operations for the **Seat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seats
    * const seats = await prisma.seat.findMany()
    * ```
    */
  get seat(): Prisma.SeatDelegate<ExtArgs>;

  /**
   * `prisma.seatHold`: Exposes CRUD operations for the **SeatHold** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SeatHolds
    * const seatHolds = await prisma.seatHold.findMany()
    * ```
    */
  get seatHold(): Prisma.SeatHoldDelegate<ExtArgs>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs>;

  /**
   * `prisma.ticket`: Exposes CRUD operations for the **Ticket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.ticket.findMany()
    * ```
    */
  get ticket(): Prisma.TicketDelegate<ExtArgs>;

  /**
   * `prisma.cinemaCredit`: Exposes CRUD operations for the **CinemaCredit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CinemaCredits
    * const cinemaCredits = await prisma.cinemaCredit.findMany()
    * ```
    */
  get cinemaCredit(): Prisma.CinemaCreditDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    SellPoint: 'SellPoint',
    Patent: 'Patent',
    PatentValidation: 'PatentValidation',
    DeletedPatents: 'DeletedPatents',
    AssignHoursReports: 'AssignHoursReports',
    AssignPatentHoursReports: 'AssignPatentHoursReports',
    SellingHoursReports: 'SellingHoursReports',
    UserHoursReports: 'UserHoursReports',
    UserParkingReports: 'UserParkingReports',
    HoursPrices: 'HoursPrices',
    Parking: 'Parking',
    Infraction: 'Infraction',
    InfractionImage: 'InfractionImage',
    SingleParkingComprobant: 'SingleParkingComprobant',
    SellingHoursComprobant: 'SellingHoursComprobant',
    Holiday: 'Holiday',
    SellingPointHoursComprobant: 'SellingPointHoursComprobant',
    SellingMonthlyComprobant: 'SellingMonthlyComprobant',
    Movie: 'Movie',
    Showing: 'Showing',
    Seat: 'Seat',
    SeatHold: 'SeatHold',
    Booking: 'Booking',
    Ticket: 'Ticket',
    CinemaCredit: 'CinemaCredit'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "sellPoint" | "patent" | "patentValidation" | "deletedPatents" | "assignHoursReports" | "assignPatentHoursReports" | "sellingHoursReports" | "userHoursReports" | "userParkingReports" | "hoursPrices" | "parking" | "infraction" | "infractionImage" | "singleParkingComprobant" | "sellingHoursComprobant" | "holiday" | "sellingPointHoursComprobant" | "sellingMonthlyComprobant" | "movie" | "showing" | "seat" | "seatHold" | "booking" | "ticket" | "cinemaCredit"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      SellPoint: {
        payload: Prisma.$SellPointPayload<ExtArgs>
        fields: Prisma.SellPointFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SellPointFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellPointPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SellPointFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellPointPayload>
          }
          findFirst: {
            args: Prisma.SellPointFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellPointPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SellPointFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellPointPayload>
          }
          findMany: {
            args: Prisma.SellPointFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellPointPayload>[]
          }
          create: {
            args: Prisma.SellPointCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellPointPayload>
          }
          createMany: {
            args: Prisma.SellPointCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SellPointCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellPointPayload>[]
          }
          delete: {
            args: Prisma.SellPointDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellPointPayload>
          }
          update: {
            args: Prisma.SellPointUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellPointPayload>
          }
          deleteMany: {
            args: Prisma.SellPointDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SellPointUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SellPointUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellPointPayload>
          }
          aggregate: {
            args: Prisma.SellPointAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSellPoint>
          }
          groupBy: {
            args: Prisma.SellPointGroupByArgs<ExtArgs>
            result: $Utils.Optional<SellPointGroupByOutputType>[]
          }
          count: {
            args: Prisma.SellPointCountArgs<ExtArgs>
            result: $Utils.Optional<SellPointCountAggregateOutputType> | number
          }
        }
      }
      Patent: {
        payload: Prisma.$PatentPayload<ExtArgs>
        fields: Prisma.PatentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentPayload>
          }
          findFirst: {
            args: Prisma.PatentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentPayload>
          }
          findMany: {
            args: Prisma.PatentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentPayload>[]
          }
          create: {
            args: Prisma.PatentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentPayload>
          }
          createMany: {
            args: Prisma.PatentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentPayload>[]
          }
          delete: {
            args: Prisma.PatentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentPayload>
          }
          update: {
            args: Prisma.PatentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentPayload>
          }
          deleteMany: {
            args: Prisma.PatentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PatentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentPayload>
          }
          aggregate: {
            args: Prisma.PatentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatent>
          }
          groupBy: {
            args: Prisma.PatentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatentCountArgs<ExtArgs>
            result: $Utils.Optional<PatentCountAggregateOutputType> | number
          }
        }
      }
      PatentValidation: {
        payload: Prisma.$PatentValidationPayload<ExtArgs>
        fields: Prisma.PatentValidationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatentValidationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentValidationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatentValidationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentValidationPayload>
          }
          findFirst: {
            args: Prisma.PatentValidationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentValidationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatentValidationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentValidationPayload>
          }
          findMany: {
            args: Prisma.PatentValidationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentValidationPayload>[]
          }
          create: {
            args: Prisma.PatentValidationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentValidationPayload>
          }
          createMany: {
            args: Prisma.PatentValidationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatentValidationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentValidationPayload>[]
          }
          delete: {
            args: Prisma.PatentValidationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentValidationPayload>
          }
          update: {
            args: Prisma.PatentValidationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentValidationPayload>
          }
          deleteMany: {
            args: Prisma.PatentValidationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatentValidationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PatentValidationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatentValidationPayload>
          }
          aggregate: {
            args: Prisma.PatentValidationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatentValidation>
          }
          groupBy: {
            args: Prisma.PatentValidationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatentValidationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatentValidationCountArgs<ExtArgs>
            result: $Utils.Optional<PatentValidationCountAggregateOutputType> | number
          }
        }
      }
      DeletedPatents: {
        payload: Prisma.$DeletedPatentsPayload<ExtArgs>
        fields: Prisma.DeletedPatentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeletedPatentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletedPatentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeletedPatentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletedPatentsPayload>
          }
          findFirst: {
            args: Prisma.DeletedPatentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletedPatentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeletedPatentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletedPatentsPayload>
          }
          findMany: {
            args: Prisma.DeletedPatentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletedPatentsPayload>[]
          }
          create: {
            args: Prisma.DeletedPatentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletedPatentsPayload>
          }
          createMany: {
            args: Prisma.DeletedPatentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeletedPatentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletedPatentsPayload>[]
          }
          delete: {
            args: Prisma.DeletedPatentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletedPatentsPayload>
          }
          update: {
            args: Prisma.DeletedPatentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletedPatentsPayload>
          }
          deleteMany: {
            args: Prisma.DeletedPatentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeletedPatentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeletedPatentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeletedPatentsPayload>
          }
          aggregate: {
            args: Prisma.DeletedPatentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeletedPatents>
          }
          groupBy: {
            args: Prisma.DeletedPatentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeletedPatentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeletedPatentsCountArgs<ExtArgs>
            result: $Utils.Optional<DeletedPatentsCountAggregateOutputType> | number
          }
        }
      }
      AssignHoursReports: {
        payload: Prisma.$AssignHoursReportsPayload<ExtArgs>
        fields: Prisma.AssignHoursReportsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssignHoursReportsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignHoursReportsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssignHoursReportsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignHoursReportsPayload>
          }
          findFirst: {
            args: Prisma.AssignHoursReportsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignHoursReportsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssignHoursReportsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignHoursReportsPayload>
          }
          findMany: {
            args: Prisma.AssignHoursReportsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignHoursReportsPayload>[]
          }
          create: {
            args: Prisma.AssignHoursReportsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignHoursReportsPayload>
          }
          createMany: {
            args: Prisma.AssignHoursReportsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssignHoursReportsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignHoursReportsPayload>[]
          }
          delete: {
            args: Prisma.AssignHoursReportsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignHoursReportsPayload>
          }
          update: {
            args: Prisma.AssignHoursReportsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignHoursReportsPayload>
          }
          deleteMany: {
            args: Prisma.AssignHoursReportsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssignHoursReportsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssignHoursReportsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignHoursReportsPayload>
          }
          aggregate: {
            args: Prisma.AssignHoursReportsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssignHoursReports>
          }
          groupBy: {
            args: Prisma.AssignHoursReportsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssignHoursReportsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssignHoursReportsCountArgs<ExtArgs>
            result: $Utils.Optional<AssignHoursReportsCountAggregateOutputType> | number
          }
        }
      }
      AssignPatentHoursReports: {
        payload: Prisma.$AssignPatentHoursReportsPayload<ExtArgs>
        fields: Prisma.AssignPatentHoursReportsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssignPatentHoursReportsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignPatentHoursReportsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssignPatentHoursReportsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignPatentHoursReportsPayload>
          }
          findFirst: {
            args: Prisma.AssignPatentHoursReportsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignPatentHoursReportsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssignPatentHoursReportsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignPatentHoursReportsPayload>
          }
          findMany: {
            args: Prisma.AssignPatentHoursReportsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignPatentHoursReportsPayload>[]
          }
          create: {
            args: Prisma.AssignPatentHoursReportsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignPatentHoursReportsPayload>
          }
          createMany: {
            args: Prisma.AssignPatentHoursReportsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssignPatentHoursReportsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignPatentHoursReportsPayload>[]
          }
          delete: {
            args: Prisma.AssignPatentHoursReportsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignPatentHoursReportsPayload>
          }
          update: {
            args: Prisma.AssignPatentHoursReportsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignPatentHoursReportsPayload>
          }
          deleteMany: {
            args: Prisma.AssignPatentHoursReportsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssignPatentHoursReportsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssignPatentHoursReportsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignPatentHoursReportsPayload>
          }
          aggregate: {
            args: Prisma.AssignPatentHoursReportsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssignPatentHoursReports>
          }
          groupBy: {
            args: Prisma.AssignPatentHoursReportsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssignPatentHoursReportsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssignPatentHoursReportsCountArgs<ExtArgs>
            result: $Utils.Optional<AssignPatentHoursReportsCountAggregateOutputType> | number
          }
        }
      }
      SellingHoursReports: {
        payload: Prisma.$SellingHoursReportsPayload<ExtArgs>
        fields: Prisma.SellingHoursReportsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SellingHoursReportsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingHoursReportsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SellingHoursReportsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingHoursReportsPayload>
          }
          findFirst: {
            args: Prisma.SellingHoursReportsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingHoursReportsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SellingHoursReportsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingHoursReportsPayload>
          }
          findMany: {
            args: Prisma.SellingHoursReportsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingHoursReportsPayload>[]
          }
          create: {
            args: Prisma.SellingHoursReportsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingHoursReportsPayload>
          }
          createMany: {
            args: Prisma.SellingHoursReportsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SellingHoursReportsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingHoursReportsPayload>[]
          }
          delete: {
            args: Prisma.SellingHoursReportsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingHoursReportsPayload>
          }
          update: {
            args: Prisma.SellingHoursReportsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingHoursReportsPayload>
          }
          deleteMany: {
            args: Prisma.SellingHoursReportsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SellingHoursReportsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SellingHoursReportsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingHoursReportsPayload>
          }
          aggregate: {
            args: Prisma.SellingHoursReportsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSellingHoursReports>
          }
          groupBy: {
            args: Prisma.SellingHoursReportsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SellingHoursReportsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SellingHoursReportsCountArgs<ExtArgs>
            result: $Utils.Optional<SellingHoursReportsCountAggregateOutputType> | number
          }
        }
      }
      UserHoursReports: {
        payload: Prisma.$UserHoursReportsPayload<ExtArgs>
        fields: Prisma.UserHoursReportsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserHoursReportsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserHoursReportsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserHoursReportsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserHoursReportsPayload>
          }
          findFirst: {
            args: Prisma.UserHoursReportsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserHoursReportsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserHoursReportsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserHoursReportsPayload>
          }
          findMany: {
            args: Prisma.UserHoursReportsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserHoursReportsPayload>[]
          }
          create: {
            args: Prisma.UserHoursReportsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserHoursReportsPayload>
          }
          createMany: {
            args: Prisma.UserHoursReportsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserHoursReportsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserHoursReportsPayload>[]
          }
          delete: {
            args: Prisma.UserHoursReportsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserHoursReportsPayload>
          }
          update: {
            args: Prisma.UserHoursReportsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserHoursReportsPayload>
          }
          deleteMany: {
            args: Prisma.UserHoursReportsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserHoursReportsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserHoursReportsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserHoursReportsPayload>
          }
          aggregate: {
            args: Prisma.UserHoursReportsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserHoursReports>
          }
          groupBy: {
            args: Prisma.UserHoursReportsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserHoursReportsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserHoursReportsCountArgs<ExtArgs>
            result: $Utils.Optional<UserHoursReportsCountAggregateOutputType> | number
          }
        }
      }
      UserParkingReports: {
        payload: Prisma.$UserParkingReportsPayload<ExtArgs>
        fields: Prisma.UserParkingReportsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserParkingReportsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserParkingReportsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserParkingReportsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserParkingReportsPayload>
          }
          findFirst: {
            args: Prisma.UserParkingReportsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserParkingReportsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserParkingReportsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserParkingReportsPayload>
          }
          findMany: {
            args: Prisma.UserParkingReportsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserParkingReportsPayload>[]
          }
          create: {
            args: Prisma.UserParkingReportsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserParkingReportsPayload>
          }
          createMany: {
            args: Prisma.UserParkingReportsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserParkingReportsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserParkingReportsPayload>[]
          }
          delete: {
            args: Prisma.UserParkingReportsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserParkingReportsPayload>
          }
          update: {
            args: Prisma.UserParkingReportsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserParkingReportsPayload>
          }
          deleteMany: {
            args: Prisma.UserParkingReportsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserParkingReportsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserParkingReportsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserParkingReportsPayload>
          }
          aggregate: {
            args: Prisma.UserParkingReportsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserParkingReports>
          }
          groupBy: {
            args: Prisma.UserParkingReportsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserParkingReportsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserParkingReportsCountArgs<ExtArgs>
            result: $Utils.Optional<UserParkingReportsCountAggregateOutputType> | number
          }
        }
      }
      HoursPrices: {
        payload: Prisma.$HoursPricesPayload<ExtArgs>
        fields: Prisma.HoursPricesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HoursPricesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoursPricesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HoursPricesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoursPricesPayload>
          }
          findFirst: {
            args: Prisma.HoursPricesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoursPricesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HoursPricesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoursPricesPayload>
          }
          findMany: {
            args: Prisma.HoursPricesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoursPricesPayload>[]
          }
          create: {
            args: Prisma.HoursPricesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoursPricesPayload>
          }
          createMany: {
            args: Prisma.HoursPricesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HoursPricesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoursPricesPayload>[]
          }
          delete: {
            args: Prisma.HoursPricesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoursPricesPayload>
          }
          update: {
            args: Prisma.HoursPricesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoursPricesPayload>
          }
          deleteMany: {
            args: Prisma.HoursPricesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HoursPricesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HoursPricesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HoursPricesPayload>
          }
          aggregate: {
            args: Prisma.HoursPricesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHoursPrices>
          }
          groupBy: {
            args: Prisma.HoursPricesGroupByArgs<ExtArgs>
            result: $Utils.Optional<HoursPricesGroupByOutputType>[]
          }
          count: {
            args: Prisma.HoursPricesCountArgs<ExtArgs>
            result: $Utils.Optional<HoursPricesCountAggregateOutputType> | number
          }
        }
      }
      Parking: {
        payload: Prisma.$ParkingPayload<ExtArgs>
        fields: Prisma.ParkingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParkingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParkingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPayload>
          }
          findFirst: {
            args: Prisma.ParkingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParkingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPayload>
          }
          findMany: {
            args: Prisma.ParkingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPayload>[]
          }
          create: {
            args: Prisma.ParkingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPayload>
          }
          createMany: {
            args: Prisma.ParkingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParkingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPayload>[]
          }
          delete: {
            args: Prisma.ParkingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPayload>
          }
          update: {
            args: Prisma.ParkingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPayload>
          }
          deleteMany: {
            args: Prisma.ParkingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParkingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ParkingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkingPayload>
          }
          aggregate: {
            args: Prisma.ParkingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParking>
          }
          groupBy: {
            args: Prisma.ParkingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParkingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParkingCountArgs<ExtArgs>
            result: $Utils.Optional<ParkingCountAggregateOutputType> | number
          }
        }
      }
      Infraction: {
        payload: Prisma.$InfractionPayload<ExtArgs>
        fields: Prisma.InfractionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InfractionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InfractionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionPayload>
          }
          findFirst: {
            args: Prisma.InfractionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InfractionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionPayload>
          }
          findMany: {
            args: Prisma.InfractionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionPayload>[]
          }
          create: {
            args: Prisma.InfractionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionPayload>
          }
          createMany: {
            args: Prisma.InfractionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InfractionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionPayload>[]
          }
          delete: {
            args: Prisma.InfractionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionPayload>
          }
          update: {
            args: Prisma.InfractionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionPayload>
          }
          deleteMany: {
            args: Prisma.InfractionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InfractionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InfractionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionPayload>
          }
          aggregate: {
            args: Prisma.InfractionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInfraction>
          }
          groupBy: {
            args: Prisma.InfractionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InfractionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InfractionCountArgs<ExtArgs>
            result: $Utils.Optional<InfractionCountAggregateOutputType> | number
          }
        }
      }
      InfractionImage: {
        payload: Prisma.$InfractionImagePayload<ExtArgs>
        fields: Prisma.InfractionImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InfractionImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InfractionImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionImagePayload>
          }
          findFirst: {
            args: Prisma.InfractionImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InfractionImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionImagePayload>
          }
          findMany: {
            args: Prisma.InfractionImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionImagePayload>[]
          }
          create: {
            args: Prisma.InfractionImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionImagePayload>
          }
          createMany: {
            args: Prisma.InfractionImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InfractionImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionImagePayload>[]
          }
          delete: {
            args: Prisma.InfractionImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionImagePayload>
          }
          update: {
            args: Prisma.InfractionImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionImagePayload>
          }
          deleteMany: {
            args: Prisma.InfractionImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InfractionImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InfractionImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionImagePayload>
          }
          aggregate: {
            args: Prisma.InfractionImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInfractionImage>
          }
          groupBy: {
            args: Prisma.InfractionImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<InfractionImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.InfractionImageCountArgs<ExtArgs>
            result: $Utils.Optional<InfractionImageCountAggregateOutputType> | number
          }
        }
      }
      SingleParkingComprobant: {
        payload: Prisma.$SingleParkingComprobantPayload<ExtArgs>
        fields: Prisma.SingleParkingComprobantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SingleParkingComprobantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SingleParkingComprobantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SingleParkingComprobantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SingleParkingComprobantPayload>
          }
          findFirst: {
            args: Prisma.SingleParkingComprobantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SingleParkingComprobantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SingleParkingComprobantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SingleParkingComprobantPayload>
          }
          findMany: {
            args: Prisma.SingleParkingComprobantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SingleParkingComprobantPayload>[]
          }
          create: {
            args: Prisma.SingleParkingComprobantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SingleParkingComprobantPayload>
          }
          createMany: {
            args: Prisma.SingleParkingComprobantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SingleParkingComprobantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SingleParkingComprobantPayload>[]
          }
          delete: {
            args: Prisma.SingleParkingComprobantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SingleParkingComprobantPayload>
          }
          update: {
            args: Prisma.SingleParkingComprobantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SingleParkingComprobantPayload>
          }
          deleteMany: {
            args: Prisma.SingleParkingComprobantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SingleParkingComprobantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SingleParkingComprobantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SingleParkingComprobantPayload>
          }
          aggregate: {
            args: Prisma.SingleParkingComprobantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSingleParkingComprobant>
          }
          groupBy: {
            args: Prisma.SingleParkingComprobantGroupByArgs<ExtArgs>
            result: $Utils.Optional<SingleParkingComprobantGroupByOutputType>[]
          }
          count: {
            args: Prisma.SingleParkingComprobantCountArgs<ExtArgs>
            result: $Utils.Optional<SingleParkingComprobantCountAggregateOutputType> | number
          }
        }
      }
      SellingHoursComprobant: {
        payload: Prisma.$SellingHoursComprobantPayload<ExtArgs>
        fields: Prisma.SellingHoursComprobantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SellingHoursComprobantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingHoursComprobantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SellingHoursComprobantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingHoursComprobantPayload>
          }
          findFirst: {
            args: Prisma.SellingHoursComprobantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingHoursComprobantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SellingHoursComprobantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingHoursComprobantPayload>
          }
          findMany: {
            args: Prisma.SellingHoursComprobantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingHoursComprobantPayload>[]
          }
          create: {
            args: Prisma.SellingHoursComprobantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingHoursComprobantPayload>
          }
          createMany: {
            args: Prisma.SellingHoursComprobantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SellingHoursComprobantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingHoursComprobantPayload>[]
          }
          delete: {
            args: Prisma.SellingHoursComprobantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingHoursComprobantPayload>
          }
          update: {
            args: Prisma.SellingHoursComprobantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingHoursComprobantPayload>
          }
          deleteMany: {
            args: Prisma.SellingHoursComprobantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SellingHoursComprobantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SellingHoursComprobantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingHoursComprobantPayload>
          }
          aggregate: {
            args: Prisma.SellingHoursComprobantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSellingHoursComprobant>
          }
          groupBy: {
            args: Prisma.SellingHoursComprobantGroupByArgs<ExtArgs>
            result: $Utils.Optional<SellingHoursComprobantGroupByOutputType>[]
          }
          count: {
            args: Prisma.SellingHoursComprobantCountArgs<ExtArgs>
            result: $Utils.Optional<SellingHoursComprobantCountAggregateOutputType> | number
          }
        }
      }
      Holiday: {
        payload: Prisma.$HolidayPayload<ExtArgs>
        fields: Prisma.HolidayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HolidayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HolidayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          findFirst: {
            args: Prisma.HolidayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HolidayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          findMany: {
            args: Prisma.HolidayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>[]
          }
          create: {
            args: Prisma.HolidayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          createMany: {
            args: Prisma.HolidayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HolidayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>[]
          }
          delete: {
            args: Prisma.HolidayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          update: {
            args: Prisma.HolidayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          deleteMany: {
            args: Prisma.HolidayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HolidayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HolidayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          aggregate: {
            args: Prisma.HolidayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHoliday>
          }
          groupBy: {
            args: Prisma.HolidayGroupByArgs<ExtArgs>
            result: $Utils.Optional<HolidayGroupByOutputType>[]
          }
          count: {
            args: Prisma.HolidayCountArgs<ExtArgs>
            result: $Utils.Optional<HolidayCountAggregateOutputType> | number
          }
        }
      }
      SellingPointHoursComprobant: {
        payload: Prisma.$SellingPointHoursComprobantPayload<ExtArgs>
        fields: Prisma.SellingPointHoursComprobantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SellingPointHoursComprobantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingPointHoursComprobantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SellingPointHoursComprobantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingPointHoursComprobantPayload>
          }
          findFirst: {
            args: Prisma.SellingPointHoursComprobantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingPointHoursComprobantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SellingPointHoursComprobantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingPointHoursComprobantPayload>
          }
          findMany: {
            args: Prisma.SellingPointHoursComprobantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingPointHoursComprobantPayload>[]
          }
          create: {
            args: Prisma.SellingPointHoursComprobantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingPointHoursComprobantPayload>
          }
          createMany: {
            args: Prisma.SellingPointHoursComprobantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SellingPointHoursComprobantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingPointHoursComprobantPayload>[]
          }
          delete: {
            args: Prisma.SellingPointHoursComprobantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingPointHoursComprobantPayload>
          }
          update: {
            args: Prisma.SellingPointHoursComprobantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingPointHoursComprobantPayload>
          }
          deleteMany: {
            args: Prisma.SellingPointHoursComprobantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SellingPointHoursComprobantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SellingPointHoursComprobantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingPointHoursComprobantPayload>
          }
          aggregate: {
            args: Prisma.SellingPointHoursComprobantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSellingPointHoursComprobant>
          }
          groupBy: {
            args: Prisma.SellingPointHoursComprobantGroupByArgs<ExtArgs>
            result: $Utils.Optional<SellingPointHoursComprobantGroupByOutputType>[]
          }
          count: {
            args: Prisma.SellingPointHoursComprobantCountArgs<ExtArgs>
            result: $Utils.Optional<SellingPointHoursComprobantCountAggregateOutputType> | number
          }
        }
      }
      SellingMonthlyComprobant: {
        payload: Prisma.$SellingMonthlyComprobantPayload<ExtArgs>
        fields: Prisma.SellingMonthlyComprobantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SellingMonthlyComprobantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingMonthlyComprobantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SellingMonthlyComprobantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingMonthlyComprobantPayload>
          }
          findFirst: {
            args: Prisma.SellingMonthlyComprobantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingMonthlyComprobantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SellingMonthlyComprobantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingMonthlyComprobantPayload>
          }
          findMany: {
            args: Prisma.SellingMonthlyComprobantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingMonthlyComprobantPayload>[]
          }
          create: {
            args: Prisma.SellingMonthlyComprobantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingMonthlyComprobantPayload>
          }
          createMany: {
            args: Prisma.SellingMonthlyComprobantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SellingMonthlyComprobantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingMonthlyComprobantPayload>[]
          }
          delete: {
            args: Prisma.SellingMonthlyComprobantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingMonthlyComprobantPayload>
          }
          update: {
            args: Prisma.SellingMonthlyComprobantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingMonthlyComprobantPayload>
          }
          deleteMany: {
            args: Prisma.SellingMonthlyComprobantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SellingMonthlyComprobantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SellingMonthlyComprobantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingMonthlyComprobantPayload>
          }
          aggregate: {
            args: Prisma.SellingMonthlyComprobantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSellingMonthlyComprobant>
          }
          groupBy: {
            args: Prisma.SellingMonthlyComprobantGroupByArgs<ExtArgs>
            result: $Utils.Optional<SellingMonthlyComprobantGroupByOutputType>[]
          }
          count: {
            args: Prisma.SellingMonthlyComprobantCountArgs<ExtArgs>
            result: $Utils.Optional<SellingMonthlyComprobantCountAggregateOutputType> | number
          }
        }
      }
      Movie: {
        payload: Prisma.$MoviePayload<ExtArgs>
        fields: Prisma.MovieFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MovieFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MovieFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          findFirst: {
            args: Prisma.MovieFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MovieFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          findMany: {
            args: Prisma.MovieFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>[]
          }
          create: {
            args: Prisma.MovieCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          createMany: {
            args: Prisma.MovieCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MovieCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>[]
          }
          delete: {
            args: Prisma.MovieDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          update: {
            args: Prisma.MovieUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          deleteMany: {
            args: Prisma.MovieDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MovieUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MovieUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          aggregate: {
            args: Prisma.MovieAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMovie>
          }
          groupBy: {
            args: Prisma.MovieGroupByArgs<ExtArgs>
            result: $Utils.Optional<MovieGroupByOutputType>[]
          }
          count: {
            args: Prisma.MovieCountArgs<ExtArgs>
            result: $Utils.Optional<MovieCountAggregateOutputType> | number
          }
        }
      }
      Showing: {
        payload: Prisma.$ShowingPayload<ExtArgs>
        fields: Prisma.ShowingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShowingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShowingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowingPayload>
          }
          findFirst: {
            args: Prisma.ShowingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShowingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowingPayload>
          }
          findMany: {
            args: Prisma.ShowingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowingPayload>[]
          }
          create: {
            args: Prisma.ShowingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowingPayload>
          }
          createMany: {
            args: Prisma.ShowingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShowingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowingPayload>[]
          }
          delete: {
            args: Prisma.ShowingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowingPayload>
          }
          update: {
            args: Prisma.ShowingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowingPayload>
          }
          deleteMany: {
            args: Prisma.ShowingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShowingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShowingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowingPayload>
          }
          aggregate: {
            args: Prisma.ShowingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShowing>
          }
          groupBy: {
            args: Prisma.ShowingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShowingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShowingCountArgs<ExtArgs>
            result: $Utils.Optional<ShowingCountAggregateOutputType> | number
          }
        }
      }
      Seat: {
        payload: Prisma.$SeatPayload<ExtArgs>
        fields: Prisma.SeatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>
          }
          findFirst: {
            args: Prisma.SeatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>
          }
          findMany: {
            args: Prisma.SeatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>[]
          }
          create: {
            args: Prisma.SeatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>
          }
          createMany: {
            args: Prisma.SeatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>[]
          }
          delete: {
            args: Prisma.SeatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>
          }
          update: {
            args: Prisma.SeatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>
          }
          deleteMany: {
            args: Prisma.SeatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SeatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatPayload>
          }
          aggregate: {
            args: Prisma.SeatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeat>
          }
          groupBy: {
            args: Prisma.SeatGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeatGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeatCountArgs<ExtArgs>
            result: $Utils.Optional<SeatCountAggregateOutputType> | number
          }
        }
      }
      SeatHold: {
        payload: Prisma.$SeatHoldPayload<ExtArgs>
        fields: Prisma.SeatHoldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeatHoldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatHoldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeatHoldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatHoldPayload>
          }
          findFirst: {
            args: Prisma.SeatHoldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatHoldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeatHoldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatHoldPayload>
          }
          findMany: {
            args: Prisma.SeatHoldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatHoldPayload>[]
          }
          create: {
            args: Prisma.SeatHoldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatHoldPayload>
          }
          createMany: {
            args: Prisma.SeatHoldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeatHoldCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatHoldPayload>[]
          }
          delete: {
            args: Prisma.SeatHoldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatHoldPayload>
          }
          update: {
            args: Prisma.SeatHoldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatHoldPayload>
          }
          deleteMany: {
            args: Prisma.SeatHoldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeatHoldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SeatHoldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeatHoldPayload>
          }
          aggregate: {
            args: Prisma.SeatHoldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeatHold>
          }
          groupBy: {
            args: Prisma.SeatHoldGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeatHoldGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeatHoldCountArgs<ExtArgs>
            result: $Utils.Optional<SeatHoldCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      Ticket: {
        payload: Prisma.$TicketPayload<ExtArgs>
        fields: Prisma.TicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findFirst: {
            args: Prisma.TicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findMany: {
            args: Prisma.TicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          create: {
            args: Prisma.TicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          createMany: {
            args: Prisma.TicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          delete: {
            args: Prisma.TicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          update: {
            args: Prisma.TicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          deleteMany: {
            args: Prisma.TicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          aggregate: {
            args: Prisma.TicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicket>
          }
          groupBy: {
            args: Prisma.TicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCountAggregateOutputType> | number
          }
        }
      }
      CinemaCredit: {
        payload: Prisma.$CinemaCreditPayload<ExtArgs>
        fields: Prisma.CinemaCreditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CinemaCreditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaCreditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CinemaCreditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaCreditPayload>
          }
          findFirst: {
            args: Prisma.CinemaCreditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaCreditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CinemaCreditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaCreditPayload>
          }
          findMany: {
            args: Prisma.CinemaCreditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaCreditPayload>[]
          }
          create: {
            args: Prisma.CinemaCreditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaCreditPayload>
          }
          createMany: {
            args: Prisma.CinemaCreditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CinemaCreditCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaCreditPayload>[]
          }
          delete: {
            args: Prisma.CinemaCreditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaCreditPayload>
          }
          update: {
            args: Prisma.CinemaCreditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaCreditPayload>
          }
          deleteMany: {
            args: Prisma.CinemaCreditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CinemaCreditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CinemaCreditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CinemaCreditPayload>
          }
          aggregate: {
            args: Prisma.CinemaCreditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCinemaCredit>
          }
          groupBy: {
            args: Prisma.CinemaCreditGroupByArgs<ExtArgs>
            result: $Utils.Optional<CinemaCreditGroupByOutputType>[]
          }
          count: {
            args: Prisma.CinemaCreditCountArgs<ExtArgs>
            result: $Utils.Optional<CinemaCreditCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    patents: number
    deletedPatent: number
    sellPoint: number
    sellingHoursReports: number
    parking: number
    userReports: number
    userParkingReports: number
    paidInfractions: number
    receivedHoursSales: number
    bookings: number
    soldBookings: number
    seatHolds: number
    cinemaCredits: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patents?: boolean | UserCountOutputTypeCountPatentsArgs
    deletedPatent?: boolean | UserCountOutputTypeCountDeletedPatentArgs
    sellPoint?: boolean | UserCountOutputTypeCountSellPointArgs
    sellingHoursReports?: boolean | UserCountOutputTypeCountSellingHoursReportsArgs
    parking?: boolean | UserCountOutputTypeCountParkingArgs
    userReports?: boolean | UserCountOutputTypeCountUserReportsArgs
    userParkingReports?: boolean | UserCountOutputTypeCountUserParkingReportsArgs
    paidInfractions?: boolean | UserCountOutputTypeCountPaidInfractionsArgs
    receivedHoursSales?: boolean | UserCountOutputTypeCountReceivedHoursSalesArgs
    bookings?: boolean | UserCountOutputTypeCountBookingsArgs
    soldBookings?: boolean | UserCountOutputTypeCountSoldBookingsArgs
    seatHolds?: boolean | UserCountOutputTypeCountSeatHoldsArgs
    cinemaCredits?: boolean | UserCountOutputTypeCountCinemaCreditsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPatentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeletedPatentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeletedPatentsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSellPointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellPointWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSellingHoursReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellingHoursReportsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountParkingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParkingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserHoursReportsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserParkingReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserParkingReportsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaidInfractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InfractionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedHoursSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellingHoursReportsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSoldBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSeatHoldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeatHoldWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCinemaCreditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CinemaCreditWhereInput
  }


  /**
   * Count Type SellPointCountOutputType
   */

  export type SellPointCountOutputType = {
    reports: number
    patentReports: number
  }

  export type SellPointCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reports?: boolean | SellPointCountOutputTypeCountReportsArgs
    patentReports?: boolean | SellPointCountOutputTypeCountPatentReportsArgs
  }

  // Custom InputTypes
  /**
   * SellPointCountOutputType without action
   */
  export type SellPointCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellPointCountOutputType
     */
    select?: SellPointCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SellPointCountOutputType without action
   */
  export type SellPointCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignHoursReportsWhereInput
  }

  /**
   * SellPointCountOutputType without action
   */
  export type SellPointCountOutputTypeCountPatentReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignPatentHoursReportsWhereInput
  }


  /**
   * Count Type InfractionCountOutputType
   */

  export type InfractionCountOutputType = {
    images: number
  }

  export type InfractionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | InfractionCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * InfractionCountOutputType without action
   */
  export type InfractionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfractionCountOutputType
     */
    select?: InfractionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InfractionCountOutputType without action
   */
  export type InfractionCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InfractionImageWhereInput
  }


  /**
   * Count Type MovieCountOutputType
   */

  export type MovieCountOutputType = {
    showings: number
  }

  export type MovieCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    showings?: boolean | MovieCountOutputTypeCountShowingsArgs
  }

  // Custom InputTypes
  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCountOutputType
     */
    select?: MovieCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeCountShowingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShowingWhereInput
  }


  /**
   * Count Type ShowingCountOutputType
   */

  export type ShowingCountOutputType = {
    seats: number
    seatHolds: number
    credits: number
  }

  export type ShowingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seats?: boolean | ShowingCountOutputTypeCountSeatsArgs
    seatHolds?: boolean | ShowingCountOutputTypeCountSeatHoldsArgs
    credits?: boolean | ShowingCountOutputTypeCountCreditsArgs
  }

  // Custom InputTypes
  /**
   * ShowingCountOutputType without action
   */
  export type ShowingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowingCountOutputType
     */
    select?: ShowingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShowingCountOutputType without action
   */
  export type ShowingCountOutputTypeCountSeatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeatWhereInput
  }

  /**
   * ShowingCountOutputType without action
   */
  export type ShowingCountOutputTypeCountSeatHoldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeatHoldWhereInput
  }

  /**
   * ShowingCountOutputType without action
   */
  export type ShowingCountOutputTypeCountCreditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CinemaCreditWhereInput
  }


  /**
   * Count Type SeatCountOutputType
   */

  export type SeatCountOutputType = {
    tickets: number
  }

  export type SeatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | SeatCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * SeatCountOutputType without action
   */
  export type SeatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatCountOutputType
     */
    select?: SeatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeatCountOutputType without action
   */
  export type SeatCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }


  /**
   * Count Type BookingCountOutputType
   */

  export type BookingCountOutputType = {
    tickets: number
    credits: number
  }

  export type BookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | BookingCountOutputTypeCountTicketsArgs
    credits?: boolean | BookingCountOutputTypeCountCreditsArgs
  }

  // Custom InputTypes
  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCountOutputType
     */
    select?: BookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountCreditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CinemaCreditWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    type: number | null
    dni: number | null
    availableHours: number | null
    availableMinutes: number | null
    usedHours: number | null
    recoveryCode: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    type: number | null
    dni: number | null
    availableHours: number | null
    availableMinutes: number | null
    usedHours: number | null
    recoveryCode: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    lastName: string | null
    email: string | null
    password: string | null
    type: number | null
    dni: number | null
    role: $Enums.Role | null
    availableHours: number | null
    availableMinutes: number | null
    usedHours: number | null
    recoveryCode: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    lastName: string | null
    email: string | null
    password: string | null
    type: number | null
    dni: number | null
    role: $Enums.Role | null
    availableHours: number | null
    availableMinutes: number | null
    usedHours: number | null
    recoveryCode: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    lastName: number
    email: number
    password: number
    type: number
    dni: number
    role: number
    availableHours: number
    availableMinutes: number
    usedHours: number
    recoveryCode: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    type?: true
    dni?: true
    availableHours?: true
    availableMinutes?: true
    usedHours?: true
    recoveryCode?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    type?: true
    dni?: true
    availableHours?: true
    availableMinutes?: true
    usedHours?: true
    recoveryCode?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    lastName?: true
    email?: true
    password?: true
    type?: true
    dni?: true
    role?: true
    availableHours?: true
    availableMinutes?: true
    usedHours?: true
    recoveryCode?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    lastName?: true
    email?: true
    password?: true
    type?: true
    dni?: true
    role?: true
    availableHours?: true
    availableMinutes?: true
    usedHours?: true
    recoveryCode?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    lastName?: true
    email?: true
    password?: true
    type?: true
    dni?: true
    role?: true
    availableHours?: true
    availableMinutes?: true
    usedHours?: true
    recoveryCode?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role: $Enums.Role
    availableHours: number | null
    availableMinutes: number | null
    usedHours: number | null
    recoveryCode: number | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    type?: boolean
    dni?: boolean
    role?: boolean
    availableHours?: boolean
    availableMinutes?: boolean
    usedHours?: boolean
    recoveryCode?: boolean
    patents?: boolean | User$patentsArgs<ExtArgs>
    deletedPatent?: boolean | User$deletedPatentArgs<ExtArgs>
    sellPoint?: boolean | User$sellPointArgs<ExtArgs>
    sellingHoursReports?: boolean | User$sellingHoursReportsArgs<ExtArgs>
    parking?: boolean | User$parkingArgs<ExtArgs>
    userReports?: boolean | User$userReportsArgs<ExtArgs>
    userParkingReports?: boolean | User$userParkingReportsArgs<ExtArgs>
    paidInfractions?: boolean | User$paidInfractionsArgs<ExtArgs>
    receivedHoursSales?: boolean | User$receivedHoursSalesArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    soldBookings?: boolean | User$soldBookingsArgs<ExtArgs>
    seatHolds?: boolean | User$seatHoldsArgs<ExtArgs>
    cinemaCredits?: boolean | User$cinemaCreditsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    type?: boolean
    dni?: boolean
    role?: boolean
    availableHours?: boolean
    availableMinutes?: boolean
    usedHours?: boolean
    recoveryCode?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    type?: boolean
    dni?: boolean
    role?: boolean
    availableHours?: boolean
    availableMinutes?: boolean
    usedHours?: boolean
    recoveryCode?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patents?: boolean | User$patentsArgs<ExtArgs>
    deletedPatent?: boolean | User$deletedPatentArgs<ExtArgs>
    sellPoint?: boolean | User$sellPointArgs<ExtArgs>
    sellingHoursReports?: boolean | User$sellingHoursReportsArgs<ExtArgs>
    parking?: boolean | User$parkingArgs<ExtArgs>
    userReports?: boolean | User$userReportsArgs<ExtArgs>
    userParkingReports?: boolean | User$userParkingReportsArgs<ExtArgs>
    paidInfractions?: boolean | User$paidInfractionsArgs<ExtArgs>
    receivedHoursSales?: boolean | User$receivedHoursSalesArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    soldBookings?: boolean | User$soldBookingsArgs<ExtArgs>
    seatHolds?: boolean | User$seatHoldsArgs<ExtArgs>
    cinemaCredits?: boolean | User$cinemaCreditsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      patents: Prisma.$PatentPayload<ExtArgs>[]
      deletedPatent: Prisma.$DeletedPatentsPayload<ExtArgs>[]
      sellPoint: Prisma.$SellPointPayload<ExtArgs>[]
      sellingHoursReports: Prisma.$SellingHoursReportsPayload<ExtArgs>[]
      parking: Prisma.$ParkingPayload<ExtArgs>[]
      userReports: Prisma.$UserHoursReportsPayload<ExtArgs>[]
      userParkingReports: Prisma.$UserParkingReportsPayload<ExtArgs>[]
      paidInfractions: Prisma.$InfractionPayload<ExtArgs>[]
      receivedHoursSales: Prisma.$SellingHoursReportsPayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      soldBookings: Prisma.$BookingPayload<ExtArgs>[]
      seatHolds: Prisma.$SeatHoldPayload<ExtArgs>[]
      cinemaCredits: Prisma.$CinemaCreditPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      lastName: string
      email: string
      password: string
      type: number
      dni: number
      role: $Enums.Role
      availableHours: number | null
      availableMinutes: number | null
      usedHours: number | null
      recoveryCode: number | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patents<T extends User$patentsArgs<ExtArgs> = {}>(args?: Subset<T, User$patentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatentPayload<ExtArgs>, T, "findMany"> | Null>
    deletedPatent<T extends User$deletedPatentArgs<ExtArgs> = {}>(args?: Subset<T, User$deletedPatentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeletedPatentsPayload<ExtArgs>, T, "findMany"> | Null>
    sellPoint<T extends User$sellPointArgs<ExtArgs> = {}>(args?: Subset<T, User$sellPointArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellPointPayload<ExtArgs>, T, "findMany"> | Null>
    sellingHoursReports<T extends User$sellingHoursReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$sellingHoursReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellingHoursReportsPayload<ExtArgs>, T, "findMany"> | Null>
    parking<T extends User$parkingArgs<ExtArgs> = {}>(args?: Subset<T, User$parkingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingPayload<ExtArgs>, T, "findMany"> | Null>
    userReports<T extends User$userReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$userReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserHoursReportsPayload<ExtArgs>, T, "findMany"> | Null>
    userParkingReports<T extends User$userParkingReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$userParkingReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserParkingReportsPayload<ExtArgs>, T, "findMany"> | Null>
    paidInfractions<T extends User$paidInfractionsArgs<ExtArgs> = {}>(args?: Subset<T, User$paidInfractionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfractionPayload<ExtArgs>, T, "findMany"> | Null>
    receivedHoursSales<T extends User$receivedHoursSalesArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedHoursSalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellingHoursReportsPayload<ExtArgs>, T, "findMany"> | Null>
    bookings<T extends User$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    soldBookings<T extends User$soldBookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$soldBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    seatHolds<T extends User$seatHoldsArgs<ExtArgs> = {}>(args?: Subset<T, User$seatHoldsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatHoldPayload<ExtArgs>, T, "findMany"> | Null>
    cinemaCredits<T extends User$cinemaCreditsArgs<ExtArgs> = {}>(args?: Subset<T, User$cinemaCreditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CinemaCreditPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly type: FieldRef<"User", 'Int'>
    readonly dni: FieldRef<"User", 'Int'>
    readonly role: FieldRef<"User", 'Role'>
    readonly availableHours: FieldRef<"User", 'Int'>
    readonly availableMinutes: FieldRef<"User", 'Int'>
    readonly usedHours: FieldRef<"User", 'Int'>
    readonly recoveryCode: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.patents
   */
  export type User$patentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patent
     */
    select?: PatentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentInclude<ExtArgs> | null
    where?: PatentWhereInput
    orderBy?: PatentOrderByWithRelationInput | PatentOrderByWithRelationInput[]
    cursor?: PatentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatentScalarFieldEnum | PatentScalarFieldEnum[]
  }

  /**
   * User.deletedPatent
   */
  export type User$deletedPatentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedPatents
     */
    select?: DeletedPatentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletedPatentsInclude<ExtArgs> | null
    where?: DeletedPatentsWhereInput
    orderBy?: DeletedPatentsOrderByWithRelationInput | DeletedPatentsOrderByWithRelationInput[]
    cursor?: DeletedPatentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeletedPatentsScalarFieldEnum | DeletedPatentsScalarFieldEnum[]
  }

  /**
   * User.sellPoint
   */
  export type User$sellPointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellPoint
     */
    select?: SellPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellPointInclude<ExtArgs> | null
    where?: SellPointWhereInput
    orderBy?: SellPointOrderByWithRelationInput | SellPointOrderByWithRelationInput[]
    cursor?: SellPointWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellPointScalarFieldEnum | SellPointScalarFieldEnum[]
  }

  /**
   * User.sellingHoursReports
   */
  export type User$sellingHoursReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHoursReports
     */
    select?: SellingHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellingHoursReportsInclude<ExtArgs> | null
    where?: SellingHoursReportsWhereInput
    orderBy?: SellingHoursReportsOrderByWithRelationInput | SellingHoursReportsOrderByWithRelationInput[]
    cursor?: SellingHoursReportsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellingHoursReportsScalarFieldEnum | SellingHoursReportsScalarFieldEnum[]
  }

  /**
   * User.parking
   */
  export type User$parkingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parking
     */
    select?: ParkingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingInclude<ExtArgs> | null
    where?: ParkingWhereInput
    orderBy?: ParkingOrderByWithRelationInput | ParkingOrderByWithRelationInput[]
    cursor?: ParkingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParkingScalarFieldEnum | ParkingScalarFieldEnum[]
  }

  /**
   * User.userReports
   */
  export type User$userReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserHoursReports
     */
    select?: UserHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserHoursReportsInclude<ExtArgs> | null
    where?: UserHoursReportsWhereInput
    orderBy?: UserHoursReportsOrderByWithRelationInput | UserHoursReportsOrderByWithRelationInput[]
    cursor?: UserHoursReportsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserHoursReportsScalarFieldEnum | UserHoursReportsScalarFieldEnum[]
  }

  /**
   * User.userParkingReports
   */
  export type User$userParkingReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserParkingReports
     */
    select?: UserParkingReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserParkingReportsInclude<ExtArgs> | null
    where?: UserParkingReportsWhereInput
    orderBy?: UserParkingReportsOrderByWithRelationInput | UserParkingReportsOrderByWithRelationInput[]
    cursor?: UserParkingReportsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserParkingReportsScalarFieldEnum | UserParkingReportsScalarFieldEnum[]
  }

  /**
   * User.paidInfractions
   */
  export type User$paidInfractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Infraction
     */
    select?: InfractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionInclude<ExtArgs> | null
    where?: InfractionWhereInput
    orderBy?: InfractionOrderByWithRelationInput | InfractionOrderByWithRelationInput[]
    cursor?: InfractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InfractionScalarFieldEnum | InfractionScalarFieldEnum[]
  }

  /**
   * User.receivedHoursSales
   */
  export type User$receivedHoursSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHoursReports
     */
    select?: SellingHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellingHoursReportsInclude<ExtArgs> | null
    where?: SellingHoursReportsWhereInput
    orderBy?: SellingHoursReportsOrderByWithRelationInput | SellingHoursReportsOrderByWithRelationInput[]
    cursor?: SellingHoursReportsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellingHoursReportsScalarFieldEnum | SellingHoursReportsScalarFieldEnum[]
  }

  /**
   * User.bookings
   */
  export type User$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.soldBookings
   */
  export type User$soldBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.seatHolds
   */
  export type User$seatHoldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatHold
     */
    select?: SeatHoldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatHoldInclude<ExtArgs> | null
    where?: SeatHoldWhereInput
    orderBy?: SeatHoldOrderByWithRelationInput | SeatHoldOrderByWithRelationInput[]
    cursor?: SeatHoldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeatHoldScalarFieldEnum | SeatHoldScalarFieldEnum[]
  }

  /**
   * User.cinemaCredits
   */
  export type User$cinemaCreditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaCredit
     */
    select?: CinemaCreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaCreditInclude<ExtArgs> | null
    where?: CinemaCreditWhereInput
    orderBy?: CinemaCreditOrderByWithRelationInput | CinemaCreditOrderByWithRelationInput[]
    cursor?: CinemaCreditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CinemaCreditScalarFieldEnum | CinemaCreditScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model SellPoint
   */

  export type AggregateSellPoint = {
    _count: SellPointCountAggregateOutputType | null
    _avg: SellPointAvgAggregateOutputType | null
    _sum: SellPointSumAggregateOutputType | null
    _min: SellPointMinAggregateOutputType | null
    _max: SellPointMaxAggregateOutputType | null
  }

  export type SellPointAvgAggregateOutputType = {
    id: number | null
    streetNumber: number | null
    availableHours: number | null
    usedHours: number | null
    dni: number | null
    userId: number | null
    profitPercentage: number | null
  }

  export type SellPointSumAggregateOutputType = {
    id: number | null
    streetNumber: number | null
    availableHours: number | null
    usedHours: number | null
    dni: number | null
    userId: number | null
    profitPercentage: number | null
  }

  export type SellPointMinAggregateOutputType = {
    id: number | null
    address: string | null
    street: string | null
    streetNumber: number | null
    availableHours: number | null
    usedHours: number | null
    pointName: string | null
    dni: number | null
    userId: number | null
    profitPercentage: number | null
  }

  export type SellPointMaxAggregateOutputType = {
    id: number | null
    address: string | null
    street: string | null
    streetNumber: number | null
    availableHours: number | null
    usedHours: number | null
    pointName: string | null
    dni: number | null
    userId: number | null
    profitPercentage: number | null
  }

  export type SellPointCountAggregateOutputType = {
    id: number
    address: number
    street: number
    streetNumber: number
    availableHours: number
    usedHours: number
    pointName: number
    dni: number
    userId: number
    profitPercentage: number
    _all: number
  }


  export type SellPointAvgAggregateInputType = {
    id?: true
    streetNumber?: true
    availableHours?: true
    usedHours?: true
    dni?: true
    userId?: true
    profitPercentage?: true
  }

  export type SellPointSumAggregateInputType = {
    id?: true
    streetNumber?: true
    availableHours?: true
    usedHours?: true
    dni?: true
    userId?: true
    profitPercentage?: true
  }

  export type SellPointMinAggregateInputType = {
    id?: true
    address?: true
    street?: true
    streetNumber?: true
    availableHours?: true
    usedHours?: true
    pointName?: true
    dni?: true
    userId?: true
    profitPercentage?: true
  }

  export type SellPointMaxAggregateInputType = {
    id?: true
    address?: true
    street?: true
    streetNumber?: true
    availableHours?: true
    usedHours?: true
    pointName?: true
    dni?: true
    userId?: true
    profitPercentage?: true
  }

  export type SellPointCountAggregateInputType = {
    id?: true
    address?: true
    street?: true
    streetNumber?: true
    availableHours?: true
    usedHours?: true
    pointName?: true
    dni?: true
    userId?: true
    profitPercentage?: true
    _all?: true
  }

  export type SellPointAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellPoint to aggregate.
     */
    where?: SellPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellPoints to fetch.
     */
    orderBy?: SellPointOrderByWithRelationInput | SellPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SellPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SellPoints
    **/
    _count?: true | SellPointCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SellPointAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SellPointSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellPointMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellPointMaxAggregateInputType
  }

  export type GetSellPointAggregateType<T extends SellPointAggregateArgs> = {
        [P in keyof T & keyof AggregateSellPoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSellPoint[P]>
      : GetScalarType<T[P], AggregateSellPoint[P]>
  }




  export type SellPointGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellPointWhereInput
    orderBy?: SellPointOrderByWithAggregationInput | SellPointOrderByWithAggregationInput[]
    by: SellPointScalarFieldEnum[] | SellPointScalarFieldEnum
    having?: SellPointScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellPointCountAggregateInputType | true
    _avg?: SellPointAvgAggregateInputType
    _sum?: SellPointSumAggregateInputType
    _min?: SellPointMinAggregateInputType
    _max?: SellPointMaxAggregateInputType
  }

  export type SellPointGroupByOutputType = {
    id: number
    address: string
    street: string | null
    streetNumber: number | null
    availableHours: number
    usedHours: number
    pointName: string
    dni: number | null
    userId: number | null
    profitPercentage: number
    _count: SellPointCountAggregateOutputType | null
    _avg: SellPointAvgAggregateOutputType | null
    _sum: SellPointSumAggregateOutputType | null
    _min: SellPointMinAggregateOutputType | null
    _max: SellPointMaxAggregateOutputType | null
  }

  type GetSellPointGroupByPayload<T extends SellPointGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SellPointGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellPointGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellPointGroupByOutputType[P]>
            : GetScalarType<T[P], SellPointGroupByOutputType[P]>
        }
      >
    >


  export type SellPointSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    street?: boolean
    streetNumber?: boolean
    availableHours?: boolean
    usedHours?: boolean
    pointName?: boolean
    dni?: boolean
    userId?: boolean
    profitPercentage?: boolean
    user?: boolean | SellPoint$userArgs<ExtArgs>
    reports?: boolean | SellPoint$reportsArgs<ExtArgs>
    patentReports?: boolean | SellPoint$patentReportsArgs<ExtArgs>
    _count?: boolean | SellPointCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sellPoint"]>

  export type SellPointSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    street?: boolean
    streetNumber?: boolean
    availableHours?: boolean
    usedHours?: boolean
    pointName?: boolean
    dni?: boolean
    userId?: boolean
    profitPercentage?: boolean
    user?: boolean | SellPoint$userArgs<ExtArgs>
  }, ExtArgs["result"]["sellPoint"]>

  export type SellPointSelectScalar = {
    id?: boolean
    address?: boolean
    street?: boolean
    streetNumber?: boolean
    availableHours?: boolean
    usedHours?: boolean
    pointName?: boolean
    dni?: boolean
    userId?: boolean
    profitPercentage?: boolean
  }

  export type SellPointInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SellPoint$userArgs<ExtArgs>
    reports?: boolean | SellPoint$reportsArgs<ExtArgs>
    patentReports?: boolean | SellPoint$patentReportsArgs<ExtArgs>
    _count?: boolean | SellPointCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SellPointIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SellPoint$userArgs<ExtArgs>
  }

  export type $SellPointPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SellPoint"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      reports: Prisma.$AssignHoursReportsPayload<ExtArgs>[]
      patentReports: Prisma.$AssignPatentHoursReportsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      address: string
      street: string | null
      streetNumber: number | null
      availableHours: number
      usedHours: number
      pointName: string
      dni: number | null
      userId: number | null
      profitPercentage: number
    }, ExtArgs["result"]["sellPoint"]>
    composites: {}
  }

  type SellPointGetPayload<S extends boolean | null | undefined | SellPointDefaultArgs> = $Result.GetResult<Prisma.$SellPointPayload, S>

  type SellPointCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SellPointFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SellPointCountAggregateInputType | true
    }

  export interface SellPointDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SellPoint'], meta: { name: 'SellPoint' } }
    /**
     * Find zero or one SellPoint that matches the filter.
     * @param {SellPointFindUniqueArgs} args - Arguments to find a SellPoint
     * @example
     * // Get one SellPoint
     * const sellPoint = await prisma.sellPoint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SellPointFindUniqueArgs>(args: SelectSubset<T, SellPointFindUniqueArgs<ExtArgs>>): Prisma__SellPointClient<$Result.GetResult<Prisma.$SellPointPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SellPoint that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SellPointFindUniqueOrThrowArgs} args - Arguments to find a SellPoint
     * @example
     * // Get one SellPoint
     * const sellPoint = await prisma.sellPoint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SellPointFindUniqueOrThrowArgs>(args: SelectSubset<T, SellPointFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SellPointClient<$Result.GetResult<Prisma.$SellPointPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SellPoint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellPointFindFirstArgs} args - Arguments to find a SellPoint
     * @example
     * // Get one SellPoint
     * const sellPoint = await prisma.sellPoint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SellPointFindFirstArgs>(args?: SelectSubset<T, SellPointFindFirstArgs<ExtArgs>>): Prisma__SellPointClient<$Result.GetResult<Prisma.$SellPointPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SellPoint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellPointFindFirstOrThrowArgs} args - Arguments to find a SellPoint
     * @example
     * // Get one SellPoint
     * const sellPoint = await prisma.sellPoint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SellPointFindFirstOrThrowArgs>(args?: SelectSubset<T, SellPointFindFirstOrThrowArgs<ExtArgs>>): Prisma__SellPointClient<$Result.GetResult<Prisma.$SellPointPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SellPoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellPointFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SellPoints
     * const sellPoints = await prisma.sellPoint.findMany()
     * 
     * // Get first 10 SellPoints
     * const sellPoints = await prisma.sellPoint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sellPointWithIdOnly = await prisma.sellPoint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SellPointFindManyArgs>(args?: SelectSubset<T, SellPointFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellPointPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SellPoint.
     * @param {SellPointCreateArgs} args - Arguments to create a SellPoint.
     * @example
     * // Create one SellPoint
     * const SellPoint = await prisma.sellPoint.create({
     *   data: {
     *     // ... data to create a SellPoint
     *   }
     * })
     * 
     */
    create<T extends SellPointCreateArgs>(args: SelectSubset<T, SellPointCreateArgs<ExtArgs>>): Prisma__SellPointClient<$Result.GetResult<Prisma.$SellPointPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SellPoints.
     * @param {SellPointCreateManyArgs} args - Arguments to create many SellPoints.
     * @example
     * // Create many SellPoints
     * const sellPoint = await prisma.sellPoint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SellPointCreateManyArgs>(args?: SelectSubset<T, SellPointCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SellPoints and returns the data saved in the database.
     * @param {SellPointCreateManyAndReturnArgs} args - Arguments to create many SellPoints.
     * @example
     * // Create many SellPoints
     * const sellPoint = await prisma.sellPoint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SellPoints and only return the `id`
     * const sellPointWithIdOnly = await prisma.sellPoint.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SellPointCreateManyAndReturnArgs>(args?: SelectSubset<T, SellPointCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellPointPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SellPoint.
     * @param {SellPointDeleteArgs} args - Arguments to delete one SellPoint.
     * @example
     * // Delete one SellPoint
     * const SellPoint = await prisma.sellPoint.delete({
     *   where: {
     *     // ... filter to delete one SellPoint
     *   }
     * })
     * 
     */
    delete<T extends SellPointDeleteArgs>(args: SelectSubset<T, SellPointDeleteArgs<ExtArgs>>): Prisma__SellPointClient<$Result.GetResult<Prisma.$SellPointPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SellPoint.
     * @param {SellPointUpdateArgs} args - Arguments to update one SellPoint.
     * @example
     * // Update one SellPoint
     * const sellPoint = await prisma.sellPoint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SellPointUpdateArgs>(args: SelectSubset<T, SellPointUpdateArgs<ExtArgs>>): Prisma__SellPointClient<$Result.GetResult<Prisma.$SellPointPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SellPoints.
     * @param {SellPointDeleteManyArgs} args - Arguments to filter SellPoints to delete.
     * @example
     * // Delete a few SellPoints
     * const { count } = await prisma.sellPoint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SellPointDeleteManyArgs>(args?: SelectSubset<T, SellPointDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellPointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SellPoints
     * const sellPoint = await prisma.sellPoint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SellPointUpdateManyArgs>(args: SelectSubset<T, SellPointUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SellPoint.
     * @param {SellPointUpsertArgs} args - Arguments to update or create a SellPoint.
     * @example
     * // Update or create a SellPoint
     * const sellPoint = await prisma.sellPoint.upsert({
     *   create: {
     *     // ... data to create a SellPoint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SellPoint we want to update
     *   }
     * })
     */
    upsert<T extends SellPointUpsertArgs>(args: SelectSubset<T, SellPointUpsertArgs<ExtArgs>>): Prisma__SellPointClient<$Result.GetResult<Prisma.$SellPointPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SellPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellPointCountArgs} args - Arguments to filter SellPoints to count.
     * @example
     * // Count the number of SellPoints
     * const count = await prisma.sellPoint.count({
     *   where: {
     *     // ... the filter for the SellPoints we want to count
     *   }
     * })
    **/
    count<T extends SellPointCountArgs>(
      args?: Subset<T, SellPointCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellPointCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SellPoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellPointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellPointAggregateArgs>(args: Subset<T, SellPointAggregateArgs>): Prisma.PrismaPromise<GetSellPointAggregateType<T>>

    /**
     * Group by SellPoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellPointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellPointGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellPointGroupByArgs['orderBy'] }
        : { orderBy?: SellPointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellPointGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellPointGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SellPoint model
   */
  readonly fields: SellPointFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SellPoint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SellPointClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends SellPoint$userArgs<ExtArgs> = {}>(args?: Subset<T, SellPoint$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    reports<T extends SellPoint$reportsArgs<ExtArgs> = {}>(args?: Subset<T, SellPoint$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignHoursReportsPayload<ExtArgs>, T, "findMany"> | Null>
    patentReports<T extends SellPoint$patentReportsArgs<ExtArgs> = {}>(args?: Subset<T, SellPoint$patentReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignPatentHoursReportsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SellPoint model
   */ 
  interface SellPointFieldRefs {
    readonly id: FieldRef<"SellPoint", 'Int'>
    readonly address: FieldRef<"SellPoint", 'String'>
    readonly street: FieldRef<"SellPoint", 'String'>
    readonly streetNumber: FieldRef<"SellPoint", 'Int'>
    readonly availableHours: FieldRef<"SellPoint", 'Int'>
    readonly usedHours: FieldRef<"SellPoint", 'Int'>
    readonly pointName: FieldRef<"SellPoint", 'String'>
    readonly dni: FieldRef<"SellPoint", 'Int'>
    readonly userId: FieldRef<"SellPoint", 'Int'>
    readonly profitPercentage: FieldRef<"SellPoint", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SellPoint findUnique
   */
  export type SellPointFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellPoint
     */
    select?: SellPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellPointInclude<ExtArgs> | null
    /**
     * Filter, which SellPoint to fetch.
     */
    where: SellPointWhereUniqueInput
  }

  /**
   * SellPoint findUniqueOrThrow
   */
  export type SellPointFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellPoint
     */
    select?: SellPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellPointInclude<ExtArgs> | null
    /**
     * Filter, which SellPoint to fetch.
     */
    where: SellPointWhereUniqueInput
  }

  /**
   * SellPoint findFirst
   */
  export type SellPointFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellPoint
     */
    select?: SellPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellPointInclude<ExtArgs> | null
    /**
     * Filter, which SellPoint to fetch.
     */
    where?: SellPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellPoints to fetch.
     */
    orderBy?: SellPointOrderByWithRelationInput | SellPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellPoints.
     */
    cursor?: SellPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellPoints.
     */
    distinct?: SellPointScalarFieldEnum | SellPointScalarFieldEnum[]
  }

  /**
   * SellPoint findFirstOrThrow
   */
  export type SellPointFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellPoint
     */
    select?: SellPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellPointInclude<ExtArgs> | null
    /**
     * Filter, which SellPoint to fetch.
     */
    where?: SellPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellPoints to fetch.
     */
    orderBy?: SellPointOrderByWithRelationInput | SellPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellPoints.
     */
    cursor?: SellPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellPoints.
     */
    distinct?: SellPointScalarFieldEnum | SellPointScalarFieldEnum[]
  }

  /**
   * SellPoint findMany
   */
  export type SellPointFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellPoint
     */
    select?: SellPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellPointInclude<ExtArgs> | null
    /**
     * Filter, which SellPoints to fetch.
     */
    where?: SellPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellPoints to fetch.
     */
    orderBy?: SellPointOrderByWithRelationInput | SellPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SellPoints.
     */
    cursor?: SellPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellPoints.
     */
    skip?: number
    distinct?: SellPointScalarFieldEnum | SellPointScalarFieldEnum[]
  }

  /**
   * SellPoint create
   */
  export type SellPointCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellPoint
     */
    select?: SellPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellPointInclude<ExtArgs> | null
    /**
     * The data needed to create a SellPoint.
     */
    data: XOR<SellPointCreateInput, SellPointUncheckedCreateInput>
  }

  /**
   * SellPoint createMany
   */
  export type SellPointCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SellPoints.
     */
    data: SellPointCreateManyInput | SellPointCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SellPoint createManyAndReturn
   */
  export type SellPointCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellPoint
     */
    select?: SellPointSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SellPoints.
     */
    data: SellPointCreateManyInput | SellPointCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellPointIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SellPoint update
   */
  export type SellPointUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellPoint
     */
    select?: SellPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellPointInclude<ExtArgs> | null
    /**
     * The data needed to update a SellPoint.
     */
    data: XOR<SellPointUpdateInput, SellPointUncheckedUpdateInput>
    /**
     * Choose, which SellPoint to update.
     */
    where: SellPointWhereUniqueInput
  }

  /**
   * SellPoint updateMany
   */
  export type SellPointUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SellPoints.
     */
    data: XOR<SellPointUpdateManyMutationInput, SellPointUncheckedUpdateManyInput>
    /**
     * Filter which SellPoints to update
     */
    where?: SellPointWhereInput
  }

  /**
   * SellPoint upsert
   */
  export type SellPointUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellPoint
     */
    select?: SellPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellPointInclude<ExtArgs> | null
    /**
     * The filter to search for the SellPoint to update in case it exists.
     */
    where: SellPointWhereUniqueInput
    /**
     * In case the SellPoint found by the `where` argument doesn't exist, create a new SellPoint with this data.
     */
    create: XOR<SellPointCreateInput, SellPointUncheckedCreateInput>
    /**
     * In case the SellPoint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SellPointUpdateInput, SellPointUncheckedUpdateInput>
  }

  /**
   * SellPoint delete
   */
  export type SellPointDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellPoint
     */
    select?: SellPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellPointInclude<ExtArgs> | null
    /**
     * Filter which SellPoint to delete.
     */
    where: SellPointWhereUniqueInput
  }

  /**
   * SellPoint deleteMany
   */
  export type SellPointDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellPoints to delete
     */
    where?: SellPointWhereInput
  }

  /**
   * SellPoint.user
   */
  export type SellPoint$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SellPoint.reports
   */
  export type SellPoint$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignHoursReports
     */
    select?: AssignHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignHoursReportsInclude<ExtArgs> | null
    where?: AssignHoursReportsWhereInput
    orderBy?: AssignHoursReportsOrderByWithRelationInput | AssignHoursReportsOrderByWithRelationInput[]
    cursor?: AssignHoursReportsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignHoursReportsScalarFieldEnum | AssignHoursReportsScalarFieldEnum[]
  }

  /**
   * SellPoint.patentReports
   */
  export type SellPoint$patentReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignPatentHoursReports
     */
    select?: AssignPatentHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignPatentHoursReportsInclude<ExtArgs> | null
    where?: AssignPatentHoursReportsWhereInput
    orderBy?: AssignPatentHoursReportsOrderByWithRelationInput | AssignPatentHoursReportsOrderByWithRelationInput[]
    cursor?: AssignPatentHoursReportsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignPatentHoursReportsScalarFieldEnum | AssignPatentHoursReportsScalarFieldEnum[]
  }

  /**
   * SellPoint without action
   */
  export type SellPointDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellPoint
     */
    select?: SellPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellPointInclude<ExtArgs> | null
  }


  /**
   * Model Patent
   */

  export type AggregatePatent = {
    _count: PatentCountAggregateOutputType | null
    _avg: PatentAvgAggregateOutputType | null
    _sum: PatentSumAggregateOutputType | null
    _min: PatentMinAggregateOutputType | null
    _max: PatentMaxAggregateOutputType | null
  }

  export type PatentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    singleHours: number | null
    dni: number | null
  }

  export type PatentSumAggregateOutputType = {
    id: number | null
    userId: number | null
    singleHours: number | null
    dni: number | null
  }

  export type PatentMinAggregateOutputType = {
    id: number | null
    patentId: string | null
    userId: number | null
    createdAt: Date | null
    hasSingleHours: boolean | null
    singleHours: number | null
    dni: number | null
    isAllowed: boolean | null
    canShow: boolean | null
    isAllowedIn: string | null
    houseType: string | null
  }

  export type PatentMaxAggregateOutputType = {
    id: number | null
    patentId: string | null
    userId: number | null
    createdAt: Date | null
    hasSingleHours: boolean | null
    singleHours: number | null
    dni: number | null
    isAllowed: boolean | null
    canShow: boolean | null
    isAllowedIn: string | null
    houseType: string | null
  }

  export type PatentCountAggregateOutputType = {
    id: number
    patentId: number
    userId: number
    createdAt: number
    hasSingleHours: number
    singleHours: number
    dni: number
    isAllowed: number
    canShow: number
    isAllowedIn: number
    houseType: number
    _all: number
  }


  export type PatentAvgAggregateInputType = {
    id?: true
    userId?: true
    singleHours?: true
    dni?: true
  }

  export type PatentSumAggregateInputType = {
    id?: true
    userId?: true
    singleHours?: true
    dni?: true
  }

  export type PatentMinAggregateInputType = {
    id?: true
    patentId?: true
    userId?: true
    createdAt?: true
    hasSingleHours?: true
    singleHours?: true
    dni?: true
    isAllowed?: true
    canShow?: true
    isAllowedIn?: true
    houseType?: true
  }

  export type PatentMaxAggregateInputType = {
    id?: true
    patentId?: true
    userId?: true
    createdAt?: true
    hasSingleHours?: true
    singleHours?: true
    dni?: true
    isAllowed?: true
    canShow?: true
    isAllowedIn?: true
    houseType?: true
  }

  export type PatentCountAggregateInputType = {
    id?: true
    patentId?: true
    userId?: true
    createdAt?: true
    hasSingleHours?: true
    singleHours?: true
    dni?: true
    isAllowed?: true
    canShow?: true
    isAllowedIn?: true
    houseType?: true
    _all?: true
  }

  export type PatentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patent to aggregate.
     */
    where?: PatentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patents to fetch.
     */
    orderBy?: PatentOrderByWithRelationInput | PatentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patents
    **/
    _count?: true | PatentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatentMaxAggregateInputType
  }

  export type GetPatentAggregateType<T extends PatentAggregateArgs> = {
        [P in keyof T & keyof AggregatePatent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatent[P]>
      : GetScalarType<T[P], AggregatePatent[P]>
  }




  export type PatentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatentWhereInput
    orderBy?: PatentOrderByWithAggregationInput | PatentOrderByWithAggregationInput[]
    by: PatentScalarFieldEnum[] | PatentScalarFieldEnum
    having?: PatentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatentCountAggregateInputType | true
    _avg?: PatentAvgAggregateInputType
    _sum?: PatentSumAggregateInputType
    _min?: PatentMinAggregateInputType
    _max?: PatentMaxAggregateInputType
  }

  export type PatentGroupByOutputType = {
    id: number
    patentId: string
    userId: number | null
    createdAt: Date
    hasSingleHours: boolean
    singleHours: number
    dni: number | null
    isAllowed: boolean
    canShow: boolean
    isAllowedIn: string | null
    houseType: string | null
    _count: PatentCountAggregateOutputType | null
    _avg: PatentAvgAggregateOutputType | null
    _sum: PatentSumAggregateOutputType | null
    _min: PatentMinAggregateOutputType | null
    _max: PatentMaxAggregateOutputType | null
  }

  type GetPatentGroupByPayload<T extends PatentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatentGroupByOutputType[P]>
            : GetScalarType<T[P], PatentGroupByOutputType[P]>
        }
      >
    >


  export type PatentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patentId?: boolean
    userId?: boolean
    createdAt?: boolean
    hasSingleHours?: boolean
    singleHours?: boolean
    dni?: boolean
    isAllowed?: boolean
    canShow?: boolean
    isAllowedIn?: boolean
    houseType?: boolean
    user?: boolean | Patent$userArgs<ExtArgs>
  }, ExtArgs["result"]["patent"]>

  export type PatentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patentId?: boolean
    userId?: boolean
    createdAt?: boolean
    hasSingleHours?: boolean
    singleHours?: boolean
    dni?: boolean
    isAllowed?: boolean
    canShow?: boolean
    isAllowedIn?: boolean
    houseType?: boolean
    user?: boolean | Patent$userArgs<ExtArgs>
  }, ExtArgs["result"]["patent"]>

  export type PatentSelectScalar = {
    id?: boolean
    patentId?: boolean
    userId?: boolean
    createdAt?: boolean
    hasSingleHours?: boolean
    singleHours?: boolean
    dni?: boolean
    isAllowed?: boolean
    canShow?: boolean
    isAllowedIn?: boolean
    houseType?: boolean
  }

  export type PatentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Patent$userArgs<ExtArgs>
  }
  export type PatentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Patent$userArgs<ExtArgs>
  }

  export type $PatentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patentId: string
      userId: number | null
      createdAt: Date
      hasSingleHours: boolean
      singleHours: number
      dni: number | null
      isAllowed: boolean
      canShow: boolean
      isAllowedIn: string | null
      houseType: string | null
    }, ExtArgs["result"]["patent"]>
    composites: {}
  }

  type PatentGetPayload<S extends boolean | null | undefined | PatentDefaultArgs> = $Result.GetResult<Prisma.$PatentPayload, S>

  type PatentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PatentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PatentCountAggregateInputType | true
    }

  export interface PatentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patent'], meta: { name: 'Patent' } }
    /**
     * Find zero or one Patent that matches the filter.
     * @param {PatentFindUniqueArgs} args - Arguments to find a Patent
     * @example
     * // Get one Patent
     * const patent = await prisma.patent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatentFindUniqueArgs>(args: SelectSubset<T, PatentFindUniqueArgs<ExtArgs>>): Prisma__PatentClient<$Result.GetResult<Prisma.$PatentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Patent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PatentFindUniqueOrThrowArgs} args - Arguments to find a Patent
     * @example
     * // Get one Patent
     * const patent = await prisma.patent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatentFindUniqueOrThrowArgs>(args: SelectSubset<T, PatentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatentClient<$Result.GetResult<Prisma.$PatentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Patent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatentFindFirstArgs} args - Arguments to find a Patent
     * @example
     * // Get one Patent
     * const patent = await prisma.patent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatentFindFirstArgs>(args?: SelectSubset<T, PatentFindFirstArgs<ExtArgs>>): Prisma__PatentClient<$Result.GetResult<Prisma.$PatentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Patent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatentFindFirstOrThrowArgs} args - Arguments to find a Patent
     * @example
     * // Get one Patent
     * const patent = await prisma.patent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatentFindFirstOrThrowArgs>(args?: SelectSubset<T, PatentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatentClient<$Result.GetResult<Prisma.$PatentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Patents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patents
     * const patents = await prisma.patent.findMany()
     * 
     * // Get first 10 Patents
     * const patents = await prisma.patent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patentWithIdOnly = await prisma.patent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatentFindManyArgs>(args?: SelectSubset<T, PatentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Patent.
     * @param {PatentCreateArgs} args - Arguments to create a Patent.
     * @example
     * // Create one Patent
     * const Patent = await prisma.patent.create({
     *   data: {
     *     // ... data to create a Patent
     *   }
     * })
     * 
     */
    create<T extends PatentCreateArgs>(args: SelectSubset<T, PatentCreateArgs<ExtArgs>>): Prisma__PatentClient<$Result.GetResult<Prisma.$PatentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Patents.
     * @param {PatentCreateManyArgs} args - Arguments to create many Patents.
     * @example
     * // Create many Patents
     * const patent = await prisma.patent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatentCreateManyArgs>(args?: SelectSubset<T, PatentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patents and returns the data saved in the database.
     * @param {PatentCreateManyAndReturnArgs} args - Arguments to create many Patents.
     * @example
     * // Create many Patents
     * const patent = await prisma.patent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patents and only return the `id`
     * const patentWithIdOnly = await prisma.patent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatentCreateManyAndReturnArgs>(args?: SelectSubset<T, PatentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Patent.
     * @param {PatentDeleteArgs} args - Arguments to delete one Patent.
     * @example
     * // Delete one Patent
     * const Patent = await prisma.patent.delete({
     *   where: {
     *     // ... filter to delete one Patent
     *   }
     * })
     * 
     */
    delete<T extends PatentDeleteArgs>(args: SelectSubset<T, PatentDeleteArgs<ExtArgs>>): Prisma__PatentClient<$Result.GetResult<Prisma.$PatentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Patent.
     * @param {PatentUpdateArgs} args - Arguments to update one Patent.
     * @example
     * // Update one Patent
     * const patent = await prisma.patent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatentUpdateArgs>(args: SelectSubset<T, PatentUpdateArgs<ExtArgs>>): Prisma__PatentClient<$Result.GetResult<Prisma.$PatentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Patents.
     * @param {PatentDeleteManyArgs} args - Arguments to filter Patents to delete.
     * @example
     * // Delete a few Patents
     * const { count } = await prisma.patent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatentDeleteManyArgs>(args?: SelectSubset<T, PatentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patents
     * const patent = await prisma.patent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatentUpdateManyArgs>(args: SelectSubset<T, PatentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Patent.
     * @param {PatentUpsertArgs} args - Arguments to update or create a Patent.
     * @example
     * // Update or create a Patent
     * const patent = await prisma.patent.upsert({
     *   create: {
     *     // ... data to create a Patent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patent we want to update
     *   }
     * })
     */
    upsert<T extends PatentUpsertArgs>(args: SelectSubset<T, PatentUpsertArgs<ExtArgs>>): Prisma__PatentClient<$Result.GetResult<Prisma.$PatentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Patents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatentCountArgs} args - Arguments to filter Patents to count.
     * @example
     * // Count the number of Patents
     * const count = await prisma.patent.count({
     *   where: {
     *     // ... the filter for the Patents we want to count
     *   }
     * })
    **/
    count<T extends PatentCountArgs>(
      args?: Subset<T, PatentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatentAggregateArgs>(args: Subset<T, PatentAggregateArgs>): Prisma.PrismaPromise<GetPatentAggregateType<T>>

    /**
     * Group by Patent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatentGroupByArgs['orderBy'] }
        : { orderBy?: PatentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patent model
   */
  readonly fields: PatentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Patent$userArgs<ExtArgs> = {}>(args?: Subset<T, Patent$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patent model
   */ 
  interface PatentFieldRefs {
    readonly id: FieldRef<"Patent", 'Int'>
    readonly patentId: FieldRef<"Patent", 'String'>
    readonly userId: FieldRef<"Patent", 'Int'>
    readonly createdAt: FieldRef<"Patent", 'DateTime'>
    readonly hasSingleHours: FieldRef<"Patent", 'Boolean'>
    readonly singleHours: FieldRef<"Patent", 'Int'>
    readonly dni: FieldRef<"Patent", 'Int'>
    readonly isAllowed: FieldRef<"Patent", 'Boolean'>
    readonly canShow: FieldRef<"Patent", 'Boolean'>
    readonly isAllowedIn: FieldRef<"Patent", 'String'>
    readonly houseType: FieldRef<"Patent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Patent findUnique
   */
  export type PatentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patent
     */
    select?: PatentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentInclude<ExtArgs> | null
    /**
     * Filter, which Patent to fetch.
     */
    where: PatentWhereUniqueInput
  }

  /**
   * Patent findUniqueOrThrow
   */
  export type PatentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patent
     */
    select?: PatentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentInclude<ExtArgs> | null
    /**
     * Filter, which Patent to fetch.
     */
    where: PatentWhereUniqueInput
  }

  /**
   * Patent findFirst
   */
  export type PatentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patent
     */
    select?: PatentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentInclude<ExtArgs> | null
    /**
     * Filter, which Patent to fetch.
     */
    where?: PatentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patents to fetch.
     */
    orderBy?: PatentOrderByWithRelationInput | PatentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patents.
     */
    cursor?: PatentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patents.
     */
    distinct?: PatentScalarFieldEnum | PatentScalarFieldEnum[]
  }

  /**
   * Patent findFirstOrThrow
   */
  export type PatentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patent
     */
    select?: PatentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentInclude<ExtArgs> | null
    /**
     * Filter, which Patent to fetch.
     */
    where?: PatentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patents to fetch.
     */
    orderBy?: PatentOrderByWithRelationInput | PatentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patents.
     */
    cursor?: PatentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patents.
     */
    distinct?: PatentScalarFieldEnum | PatentScalarFieldEnum[]
  }

  /**
   * Patent findMany
   */
  export type PatentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patent
     */
    select?: PatentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentInclude<ExtArgs> | null
    /**
     * Filter, which Patents to fetch.
     */
    where?: PatentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patents to fetch.
     */
    orderBy?: PatentOrderByWithRelationInput | PatentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patents.
     */
    cursor?: PatentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patents.
     */
    skip?: number
    distinct?: PatentScalarFieldEnum | PatentScalarFieldEnum[]
  }

  /**
   * Patent create
   */
  export type PatentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patent
     */
    select?: PatentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentInclude<ExtArgs> | null
    /**
     * The data needed to create a Patent.
     */
    data: XOR<PatentCreateInput, PatentUncheckedCreateInput>
  }

  /**
   * Patent createMany
   */
  export type PatentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patents.
     */
    data: PatentCreateManyInput | PatentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patent createManyAndReturn
   */
  export type PatentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patent
     */
    select?: PatentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Patents.
     */
    data: PatentCreateManyInput | PatentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Patent update
   */
  export type PatentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patent
     */
    select?: PatentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentInclude<ExtArgs> | null
    /**
     * The data needed to update a Patent.
     */
    data: XOR<PatentUpdateInput, PatentUncheckedUpdateInput>
    /**
     * Choose, which Patent to update.
     */
    where: PatentWhereUniqueInput
  }

  /**
   * Patent updateMany
   */
  export type PatentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patents.
     */
    data: XOR<PatentUpdateManyMutationInput, PatentUncheckedUpdateManyInput>
    /**
     * Filter which Patents to update
     */
    where?: PatentWhereInput
  }

  /**
   * Patent upsert
   */
  export type PatentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patent
     */
    select?: PatentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentInclude<ExtArgs> | null
    /**
     * The filter to search for the Patent to update in case it exists.
     */
    where: PatentWhereUniqueInput
    /**
     * In case the Patent found by the `where` argument doesn't exist, create a new Patent with this data.
     */
    create: XOR<PatentCreateInput, PatentUncheckedCreateInput>
    /**
     * In case the Patent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatentUpdateInput, PatentUncheckedUpdateInput>
  }

  /**
   * Patent delete
   */
  export type PatentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patent
     */
    select?: PatentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentInclude<ExtArgs> | null
    /**
     * Filter which Patent to delete.
     */
    where: PatentWhereUniqueInput
  }

  /**
   * Patent deleteMany
   */
  export type PatentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patents to delete
     */
    where?: PatentWhereInput
  }

  /**
   * Patent.user
   */
  export type Patent$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Patent without action
   */
  export type PatentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patent
     */
    select?: PatentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatentInclude<ExtArgs> | null
  }


  /**
   * Model PatentValidation
   */

  export type AggregatePatentValidation = {
    _count: PatentValidationCountAggregateOutputType | null
    _avg: PatentValidationAvgAggregateOutputType | null
    _sum: PatentValidationSumAggregateOutputType | null
    _min: PatentValidationMinAggregateOutputType | null
    _max: PatentValidationMaxAggregateOutputType | null
  }

  export type PatentValidationAvgAggregateOutputType = {
    id: number | null
    validationsToday: number | null
  }

  export type PatentValidationSumAggregateOutputType = {
    id: number | null
    validationsToday: number | null
  }

  export type PatentValidationMinAggregateOutputType = {
    id: number | null
    patentId: string | null
    validationsToday: number | null
    validatedAt: Date | null
  }

  export type PatentValidationMaxAggregateOutputType = {
    id: number | null
    patentId: string | null
    validationsToday: number | null
    validatedAt: Date | null
  }

  export type PatentValidationCountAggregateOutputType = {
    id: number
    patentId: number
    validationsToday: number
    validatedAt: number
    _all: number
  }


  export type PatentValidationAvgAggregateInputType = {
    id?: true
    validationsToday?: true
  }

  export type PatentValidationSumAggregateInputType = {
    id?: true
    validationsToday?: true
  }

  export type PatentValidationMinAggregateInputType = {
    id?: true
    patentId?: true
    validationsToday?: true
    validatedAt?: true
  }

  export type PatentValidationMaxAggregateInputType = {
    id?: true
    patentId?: true
    validationsToday?: true
    validatedAt?: true
  }

  export type PatentValidationCountAggregateInputType = {
    id?: true
    patentId?: true
    validationsToday?: true
    validatedAt?: true
    _all?: true
  }

  export type PatentValidationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatentValidation to aggregate.
     */
    where?: PatentValidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatentValidations to fetch.
     */
    orderBy?: PatentValidationOrderByWithRelationInput | PatentValidationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatentValidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatentValidations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatentValidations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PatentValidations
    **/
    _count?: true | PatentValidationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatentValidationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatentValidationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatentValidationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatentValidationMaxAggregateInputType
  }

  export type GetPatentValidationAggregateType<T extends PatentValidationAggregateArgs> = {
        [P in keyof T & keyof AggregatePatentValidation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatentValidation[P]>
      : GetScalarType<T[P], AggregatePatentValidation[P]>
  }




  export type PatentValidationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatentValidationWhereInput
    orderBy?: PatentValidationOrderByWithAggregationInput | PatentValidationOrderByWithAggregationInput[]
    by: PatentValidationScalarFieldEnum[] | PatentValidationScalarFieldEnum
    having?: PatentValidationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatentValidationCountAggregateInputType | true
    _avg?: PatentValidationAvgAggregateInputType
    _sum?: PatentValidationSumAggregateInputType
    _min?: PatentValidationMinAggregateInputType
    _max?: PatentValidationMaxAggregateInputType
  }

  export type PatentValidationGroupByOutputType = {
    id: number
    patentId: string
    validationsToday: number
    validatedAt: Date | null
    _count: PatentValidationCountAggregateOutputType | null
    _avg: PatentValidationAvgAggregateOutputType | null
    _sum: PatentValidationSumAggregateOutputType | null
    _min: PatentValidationMinAggregateOutputType | null
    _max: PatentValidationMaxAggregateOutputType | null
  }

  type GetPatentValidationGroupByPayload<T extends PatentValidationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatentValidationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatentValidationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatentValidationGroupByOutputType[P]>
            : GetScalarType<T[P], PatentValidationGroupByOutputType[P]>
        }
      >
    >


  export type PatentValidationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patentId?: boolean
    validationsToday?: boolean
    validatedAt?: boolean
  }, ExtArgs["result"]["patentValidation"]>

  export type PatentValidationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patentId?: boolean
    validationsToday?: boolean
    validatedAt?: boolean
  }, ExtArgs["result"]["patentValidation"]>

  export type PatentValidationSelectScalar = {
    id?: boolean
    patentId?: boolean
    validationsToday?: boolean
    validatedAt?: boolean
  }


  export type $PatentValidationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PatentValidation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patentId: string
      validationsToday: number
      validatedAt: Date | null
    }, ExtArgs["result"]["patentValidation"]>
    composites: {}
  }

  type PatentValidationGetPayload<S extends boolean | null | undefined | PatentValidationDefaultArgs> = $Result.GetResult<Prisma.$PatentValidationPayload, S>

  type PatentValidationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PatentValidationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PatentValidationCountAggregateInputType | true
    }

  export interface PatentValidationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PatentValidation'], meta: { name: 'PatentValidation' } }
    /**
     * Find zero or one PatentValidation that matches the filter.
     * @param {PatentValidationFindUniqueArgs} args - Arguments to find a PatentValidation
     * @example
     * // Get one PatentValidation
     * const patentValidation = await prisma.patentValidation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatentValidationFindUniqueArgs>(args: SelectSubset<T, PatentValidationFindUniqueArgs<ExtArgs>>): Prisma__PatentValidationClient<$Result.GetResult<Prisma.$PatentValidationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PatentValidation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PatentValidationFindUniqueOrThrowArgs} args - Arguments to find a PatentValidation
     * @example
     * // Get one PatentValidation
     * const patentValidation = await prisma.patentValidation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatentValidationFindUniqueOrThrowArgs>(args: SelectSubset<T, PatentValidationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatentValidationClient<$Result.GetResult<Prisma.$PatentValidationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PatentValidation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatentValidationFindFirstArgs} args - Arguments to find a PatentValidation
     * @example
     * // Get one PatentValidation
     * const patentValidation = await prisma.patentValidation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatentValidationFindFirstArgs>(args?: SelectSubset<T, PatentValidationFindFirstArgs<ExtArgs>>): Prisma__PatentValidationClient<$Result.GetResult<Prisma.$PatentValidationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PatentValidation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatentValidationFindFirstOrThrowArgs} args - Arguments to find a PatentValidation
     * @example
     * // Get one PatentValidation
     * const patentValidation = await prisma.patentValidation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatentValidationFindFirstOrThrowArgs>(args?: SelectSubset<T, PatentValidationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatentValidationClient<$Result.GetResult<Prisma.$PatentValidationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PatentValidations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatentValidationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PatentValidations
     * const patentValidations = await prisma.patentValidation.findMany()
     * 
     * // Get first 10 PatentValidations
     * const patentValidations = await prisma.patentValidation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patentValidationWithIdOnly = await prisma.patentValidation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatentValidationFindManyArgs>(args?: SelectSubset<T, PatentValidationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatentValidationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PatentValidation.
     * @param {PatentValidationCreateArgs} args - Arguments to create a PatentValidation.
     * @example
     * // Create one PatentValidation
     * const PatentValidation = await prisma.patentValidation.create({
     *   data: {
     *     // ... data to create a PatentValidation
     *   }
     * })
     * 
     */
    create<T extends PatentValidationCreateArgs>(args: SelectSubset<T, PatentValidationCreateArgs<ExtArgs>>): Prisma__PatentValidationClient<$Result.GetResult<Prisma.$PatentValidationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PatentValidations.
     * @param {PatentValidationCreateManyArgs} args - Arguments to create many PatentValidations.
     * @example
     * // Create many PatentValidations
     * const patentValidation = await prisma.patentValidation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatentValidationCreateManyArgs>(args?: SelectSubset<T, PatentValidationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PatentValidations and returns the data saved in the database.
     * @param {PatentValidationCreateManyAndReturnArgs} args - Arguments to create many PatentValidations.
     * @example
     * // Create many PatentValidations
     * const patentValidation = await prisma.patentValidation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PatentValidations and only return the `id`
     * const patentValidationWithIdOnly = await prisma.patentValidation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatentValidationCreateManyAndReturnArgs>(args?: SelectSubset<T, PatentValidationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatentValidationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PatentValidation.
     * @param {PatentValidationDeleteArgs} args - Arguments to delete one PatentValidation.
     * @example
     * // Delete one PatentValidation
     * const PatentValidation = await prisma.patentValidation.delete({
     *   where: {
     *     // ... filter to delete one PatentValidation
     *   }
     * })
     * 
     */
    delete<T extends PatentValidationDeleteArgs>(args: SelectSubset<T, PatentValidationDeleteArgs<ExtArgs>>): Prisma__PatentValidationClient<$Result.GetResult<Prisma.$PatentValidationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PatentValidation.
     * @param {PatentValidationUpdateArgs} args - Arguments to update one PatentValidation.
     * @example
     * // Update one PatentValidation
     * const patentValidation = await prisma.patentValidation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatentValidationUpdateArgs>(args: SelectSubset<T, PatentValidationUpdateArgs<ExtArgs>>): Prisma__PatentValidationClient<$Result.GetResult<Prisma.$PatentValidationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PatentValidations.
     * @param {PatentValidationDeleteManyArgs} args - Arguments to filter PatentValidations to delete.
     * @example
     * // Delete a few PatentValidations
     * const { count } = await prisma.patentValidation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatentValidationDeleteManyArgs>(args?: SelectSubset<T, PatentValidationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatentValidations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatentValidationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PatentValidations
     * const patentValidation = await prisma.patentValidation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatentValidationUpdateManyArgs>(args: SelectSubset<T, PatentValidationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PatentValidation.
     * @param {PatentValidationUpsertArgs} args - Arguments to update or create a PatentValidation.
     * @example
     * // Update or create a PatentValidation
     * const patentValidation = await prisma.patentValidation.upsert({
     *   create: {
     *     // ... data to create a PatentValidation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PatentValidation we want to update
     *   }
     * })
     */
    upsert<T extends PatentValidationUpsertArgs>(args: SelectSubset<T, PatentValidationUpsertArgs<ExtArgs>>): Prisma__PatentValidationClient<$Result.GetResult<Prisma.$PatentValidationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PatentValidations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatentValidationCountArgs} args - Arguments to filter PatentValidations to count.
     * @example
     * // Count the number of PatentValidations
     * const count = await prisma.patentValidation.count({
     *   where: {
     *     // ... the filter for the PatentValidations we want to count
     *   }
     * })
    **/
    count<T extends PatentValidationCountArgs>(
      args?: Subset<T, PatentValidationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatentValidationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PatentValidation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatentValidationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatentValidationAggregateArgs>(args: Subset<T, PatentValidationAggregateArgs>): Prisma.PrismaPromise<GetPatentValidationAggregateType<T>>

    /**
     * Group by PatentValidation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatentValidationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatentValidationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatentValidationGroupByArgs['orderBy'] }
        : { orderBy?: PatentValidationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatentValidationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatentValidationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PatentValidation model
   */
  readonly fields: PatentValidationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PatentValidation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatentValidationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PatentValidation model
   */ 
  interface PatentValidationFieldRefs {
    readonly id: FieldRef<"PatentValidation", 'Int'>
    readonly patentId: FieldRef<"PatentValidation", 'String'>
    readonly validationsToday: FieldRef<"PatentValidation", 'Int'>
    readonly validatedAt: FieldRef<"PatentValidation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PatentValidation findUnique
   */
  export type PatentValidationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatentValidation
     */
    select?: PatentValidationSelect<ExtArgs> | null
    /**
     * Filter, which PatentValidation to fetch.
     */
    where: PatentValidationWhereUniqueInput
  }

  /**
   * PatentValidation findUniqueOrThrow
   */
  export type PatentValidationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatentValidation
     */
    select?: PatentValidationSelect<ExtArgs> | null
    /**
     * Filter, which PatentValidation to fetch.
     */
    where: PatentValidationWhereUniqueInput
  }

  /**
   * PatentValidation findFirst
   */
  export type PatentValidationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatentValidation
     */
    select?: PatentValidationSelect<ExtArgs> | null
    /**
     * Filter, which PatentValidation to fetch.
     */
    where?: PatentValidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatentValidations to fetch.
     */
    orderBy?: PatentValidationOrderByWithRelationInput | PatentValidationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatentValidations.
     */
    cursor?: PatentValidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatentValidations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatentValidations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatentValidations.
     */
    distinct?: PatentValidationScalarFieldEnum | PatentValidationScalarFieldEnum[]
  }

  /**
   * PatentValidation findFirstOrThrow
   */
  export type PatentValidationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatentValidation
     */
    select?: PatentValidationSelect<ExtArgs> | null
    /**
     * Filter, which PatentValidation to fetch.
     */
    where?: PatentValidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatentValidations to fetch.
     */
    orderBy?: PatentValidationOrderByWithRelationInput | PatentValidationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatentValidations.
     */
    cursor?: PatentValidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatentValidations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatentValidations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatentValidations.
     */
    distinct?: PatentValidationScalarFieldEnum | PatentValidationScalarFieldEnum[]
  }

  /**
   * PatentValidation findMany
   */
  export type PatentValidationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatentValidation
     */
    select?: PatentValidationSelect<ExtArgs> | null
    /**
     * Filter, which PatentValidations to fetch.
     */
    where?: PatentValidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatentValidations to fetch.
     */
    orderBy?: PatentValidationOrderByWithRelationInput | PatentValidationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PatentValidations.
     */
    cursor?: PatentValidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatentValidations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatentValidations.
     */
    skip?: number
    distinct?: PatentValidationScalarFieldEnum | PatentValidationScalarFieldEnum[]
  }

  /**
   * PatentValidation create
   */
  export type PatentValidationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatentValidation
     */
    select?: PatentValidationSelect<ExtArgs> | null
    /**
     * The data needed to create a PatentValidation.
     */
    data: XOR<PatentValidationCreateInput, PatentValidationUncheckedCreateInput>
  }

  /**
   * PatentValidation createMany
   */
  export type PatentValidationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PatentValidations.
     */
    data: PatentValidationCreateManyInput | PatentValidationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PatentValidation createManyAndReturn
   */
  export type PatentValidationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatentValidation
     */
    select?: PatentValidationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PatentValidations.
     */
    data: PatentValidationCreateManyInput | PatentValidationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PatentValidation update
   */
  export type PatentValidationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatentValidation
     */
    select?: PatentValidationSelect<ExtArgs> | null
    /**
     * The data needed to update a PatentValidation.
     */
    data: XOR<PatentValidationUpdateInput, PatentValidationUncheckedUpdateInput>
    /**
     * Choose, which PatentValidation to update.
     */
    where: PatentValidationWhereUniqueInput
  }

  /**
   * PatentValidation updateMany
   */
  export type PatentValidationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PatentValidations.
     */
    data: XOR<PatentValidationUpdateManyMutationInput, PatentValidationUncheckedUpdateManyInput>
    /**
     * Filter which PatentValidations to update
     */
    where?: PatentValidationWhereInput
  }

  /**
   * PatentValidation upsert
   */
  export type PatentValidationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatentValidation
     */
    select?: PatentValidationSelect<ExtArgs> | null
    /**
     * The filter to search for the PatentValidation to update in case it exists.
     */
    where: PatentValidationWhereUniqueInput
    /**
     * In case the PatentValidation found by the `where` argument doesn't exist, create a new PatentValidation with this data.
     */
    create: XOR<PatentValidationCreateInput, PatentValidationUncheckedCreateInput>
    /**
     * In case the PatentValidation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatentValidationUpdateInput, PatentValidationUncheckedUpdateInput>
  }

  /**
   * PatentValidation delete
   */
  export type PatentValidationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatentValidation
     */
    select?: PatentValidationSelect<ExtArgs> | null
    /**
     * Filter which PatentValidation to delete.
     */
    where: PatentValidationWhereUniqueInput
  }

  /**
   * PatentValidation deleteMany
   */
  export type PatentValidationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatentValidations to delete
     */
    where?: PatentValidationWhereInput
  }

  /**
   * PatentValidation without action
   */
  export type PatentValidationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatentValidation
     */
    select?: PatentValidationSelect<ExtArgs> | null
  }


  /**
   * Model DeletedPatents
   */

  export type AggregateDeletedPatents = {
    _count: DeletedPatentsCountAggregateOutputType | null
    _avg: DeletedPatentsAvgAggregateOutputType | null
    _sum: DeletedPatentsSumAggregateOutputType | null
    _min: DeletedPatentsMinAggregateOutputType | null
    _max: DeletedPatentsMaxAggregateOutputType | null
  }

  export type DeletedPatentsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type DeletedPatentsSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type DeletedPatentsMinAggregateOutputType = {
    id: number | null
    patentId: string | null
    userId: number | null
    deletedAt: Date | null
  }

  export type DeletedPatentsMaxAggregateOutputType = {
    id: number | null
    patentId: string | null
    userId: number | null
    deletedAt: Date | null
  }

  export type DeletedPatentsCountAggregateOutputType = {
    id: number
    patentId: number
    userId: number
    deletedAt: number
    _all: number
  }


  export type DeletedPatentsAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type DeletedPatentsSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type DeletedPatentsMinAggregateInputType = {
    id?: true
    patentId?: true
    userId?: true
    deletedAt?: true
  }

  export type DeletedPatentsMaxAggregateInputType = {
    id?: true
    patentId?: true
    userId?: true
    deletedAt?: true
  }

  export type DeletedPatentsCountAggregateInputType = {
    id?: true
    patentId?: true
    userId?: true
    deletedAt?: true
    _all?: true
  }

  export type DeletedPatentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeletedPatents to aggregate.
     */
    where?: DeletedPatentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeletedPatents to fetch.
     */
    orderBy?: DeletedPatentsOrderByWithRelationInput | DeletedPatentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeletedPatentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeletedPatents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeletedPatents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeletedPatents
    **/
    _count?: true | DeletedPatentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeletedPatentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeletedPatentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeletedPatentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeletedPatentsMaxAggregateInputType
  }

  export type GetDeletedPatentsAggregateType<T extends DeletedPatentsAggregateArgs> = {
        [P in keyof T & keyof AggregateDeletedPatents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeletedPatents[P]>
      : GetScalarType<T[P], AggregateDeletedPatents[P]>
  }




  export type DeletedPatentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeletedPatentsWhereInput
    orderBy?: DeletedPatentsOrderByWithAggregationInput | DeletedPatentsOrderByWithAggregationInput[]
    by: DeletedPatentsScalarFieldEnum[] | DeletedPatentsScalarFieldEnum
    having?: DeletedPatentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeletedPatentsCountAggregateInputType | true
    _avg?: DeletedPatentsAvgAggregateInputType
    _sum?: DeletedPatentsSumAggregateInputType
    _min?: DeletedPatentsMinAggregateInputType
    _max?: DeletedPatentsMaxAggregateInputType
  }

  export type DeletedPatentsGroupByOutputType = {
    id: number
    patentId: string
    userId: number
    deletedAt: Date | null
    _count: DeletedPatentsCountAggregateOutputType | null
    _avg: DeletedPatentsAvgAggregateOutputType | null
    _sum: DeletedPatentsSumAggregateOutputType | null
    _min: DeletedPatentsMinAggregateOutputType | null
    _max: DeletedPatentsMaxAggregateOutputType | null
  }

  type GetDeletedPatentsGroupByPayload<T extends DeletedPatentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeletedPatentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeletedPatentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeletedPatentsGroupByOutputType[P]>
            : GetScalarType<T[P], DeletedPatentsGroupByOutputType[P]>
        }
      >
    >


  export type DeletedPatentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patentId?: boolean
    userId?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deletedPatents"]>

  export type DeletedPatentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patentId?: boolean
    userId?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deletedPatents"]>

  export type DeletedPatentsSelectScalar = {
    id?: boolean
    patentId?: boolean
    userId?: boolean
    deletedAt?: boolean
  }

  export type DeletedPatentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeletedPatentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DeletedPatentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeletedPatents"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patentId: string
      userId: number
      deletedAt: Date | null
    }, ExtArgs["result"]["deletedPatents"]>
    composites: {}
  }

  type DeletedPatentsGetPayload<S extends boolean | null | undefined | DeletedPatentsDefaultArgs> = $Result.GetResult<Prisma.$DeletedPatentsPayload, S>

  type DeletedPatentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeletedPatentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeletedPatentsCountAggregateInputType | true
    }

  export interface DeletedPatentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeletedPatents'], meta: { name: 'DeletedPatents' } }
    /**
     * Find zero or one DeletedPatents that matches the filter.
     * @param {DeletedPatentsFindUniqueArgs} args - Arguments to find a DeletedPatents
     * @example
     * // Get one DeletedPatents
     * const deletedPatents = await prisma.deletedPatents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeletedPatentsFindUniqueArgs>(args: SelectSubset<T, DeletedPatentsFindUniqueArgs<ExtArgs>>): Prisma__DeletedPatentsClient<$Result.GetResult<Prisma.$DeletedPatentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DeletedPatents that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeletedPatentsFindUniqueOrThrowArgs} args - Arguments to find a DeletedPatents
     * @example
     * // Get one DeletedPatents
     * const deletedPatents = await prisma.deletedPatents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeletedPatentsFindUniqueOrThrowArgs>(args: SelectSubset<T, DeletedPatentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeletedPatentsClient<$Result.GetResult<Prisma.$DeletedPatentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DeletedPatents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletedPatentsFindFirstArgs} args - Arguments to find a DeletedPatents
     * @example
     * // Get one DeletedPatents
     * const deletedPatents = await prisma.deletedPatents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeletedPatentsFindFirstArgs>(args?: SelectSubset<T, DeletedPatentsFindFirstArgs<ExtArgs>>): Prisma__DeletedPatentsClient<$Result.GetResult<Prisma.$DeletedPatentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DeletedPatents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletedPatentsFindFirstOrThrowArgs} args - Arguments to find a DeletedPatents
     * @example
     * // Get one DeletedPatents
     * const deletedPatents = await prisma.deletedPatents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeletedPatentsFindFirstOrThrowArgs>(args?: SelectSubset<T, DeletedPatentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeletedPatentsClient<$Result.GetResult<Prisma.$DeletedPatentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DeletedPatents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletedPatentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeletedPatents
     * const deletedPatents = await prisma.deletedPatents.findMany()
     * 
     * // Get first 10 DeletedPatents
     * const deletedPatents = await prisma.deletedPatents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deletedPatentsWithIdOnly = await prisma.deletedPatents.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeletedPatentsFindManyArgs>(args?: SelectSubset<T, DeletedPatentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeletedPatentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DeletedPatents.
     * @param {DeletedPatentsCreateArgs} args - Arguments to create a DeletedPatents.
     * @example
     * // Create one DeletedPatents
     * const DeletedPatents = await prisma.deletedPatents.create({
     *   data: {
     *     // ... data to create a DeletedPatents
     *   }
     * })
     * 
     */
    create<T extends DeletedPatentsCreateArgs>(args: SelectSubset<T, DeletedPatentsCreateArgs<ExtArgs>>): Prisma__DeletedPatentsClient<$Result.GetResult<Prisma.$DeletedPatentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DeletedPatents.
     * @param {DeletedPatentsCreateManyArgs} args - Arguments to create many DeletedPatents.
     * @example
     * // Create many DeletedPatents
     * const deletedPatents = await prisma.deletedPatents.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeletedPatentsCreateManyArgs>(args?: SelectSubset<T, DeletedPatentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeletedPatents and returns the data saved in the database.
     * @param {DeletedPatentsCreateManyAndReturnArgs} args - Arguments to create many DeletedPatents.
     * @example
     * // Create many DeletedPatents
     * const deletedPatents = await prisma.deletedPatents.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeletedPatents and only return the `id`
     * const deletedPatentsWithIdOnly = await prisma.deletedPatents.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeletedPatentsCreateManyAndReturnArgs>(args?: SelectSubset<T, DeletedPatentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeletedPatentsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DeletedPatents.
     * @param {DeletedPatentsDeleteArgs} args - Arguments to delete one DeletedPatents.
     * @example
     * // Delete one DeletedPatents
     * const DeletedPatents = await prisma.deletedPatents.delete({
     *   where: {
     *     // ... filter to delete one DeletedPatents
     *   }
     * })
     * 
     */
    delete<T extends DeletedPatentsDeleteArgs>(args: SelectSubset<T, DeletedPatentsDeleteArgs<ExtArgs>>): Prisma__DeletedPatentsClient<$Result.GetResult<Prisma.$DeletedPatentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DeletedPatents.
     * @param {DeletedPatentsUpdateArgs} args - Arguments to update one DeletedPatents.
     * @example
     * // Update one DeletedPatents
     * const deletedPatents = await prisma.deletedPatents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeletedPatentsUpdateArgs>(args: SelectSubset<T, DeletedPatentsUpdateArgs<ExtArgs>>): Prisma__DeletedPatentsClient<$Result.GetResult<Prisma.$DeletedPatentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DeletedPatents.
     * @param {DeletedPatentsDeleteManyArgs} args - Arguments to filter DeletedPatents to delete.
     * @example
     * // Delete a few DeletedPatents
     * const { count } = await prisma.deletedPatents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeletedPatentsDeleteManyArgs>(args?: SelectSubset<T, DeletedPatentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeletedPatents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletedPatentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeletedPatents
     * const deletedPatents = await prisma.deletedPatents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeletedPatentsUpdateManyArgs>(args: SelectSubset<T, DeletedPatentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeletedPatents.
     * @param {DeletedPatentsUpsertArgs} args - Arguments to update or create a DeletedPatents.
     * @example
     * // Update or create a DeletedPatents
     * const deletedPatents = await prisma.deletedPatents.upsert({
     *   create: {
     *     // ... data to create a DeletedPatents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeletedPatents we want to update
     *   }
     * })
     */
    upsert<T extends DeletedPatentsUpsertArgs>(args: SelectSubset<T, DeletedPatentsUpsertArgs<ExtArgs>>): Prisma__DeletedPatentsClient<$Result.GetResult<Prisma.$DeletedPatentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DeletedPatents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletedPatentsCountArgs} args - Arguments to filter DeletedPatents to count.
     * @example
     * // Count the number of DeletedPatents
     * const count = await prisma.deletedPatents.count({
     *   where: {
     *     // ... the filter for the DeletedPatents we want to count
     *   }
     * })
    **/
    count<T extends DeletedPatentsCountArgs>(
      args?: Subset<T, DeletedPatentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeletedPatentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeletedPatents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletedPatentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeletedPatentsAggregateArgs>(args: Subset<T, DeletedPatentsAggregateArgs>): Prisma.PrismaPromise<GetDeletedPatentsAggregateType<T>>

    /**
     * Group by DeletedPatents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletedPatentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeletedPatentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeletedPatentsGroupByArgs['orderBy'] }
        : { orderBy?: DeletedPatentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeletedPatentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeletedPatentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeletedPatents model
   */
  readonly fields: DeletedPatentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeletedPatents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeletedPatentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeletedPatents model
   */ 
  interface DeletedPatentsFieldRefs {
    readonly id: FieldRef<"DeletedPatents", 'Int'>
    readonly patentId: FieldRef<"DeletedPatents", 'String'>
    readonly userId: FieldRef<"DeletedPatents", 'Int'>
    readonly deletedAt: FieldRef<"DeletedPatents", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeletedPatents findUnique
   */
  export type DeletedPatentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedPatents
     */
    select?: DeletedPatentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletedPatentsInclude<ExtArgs> | null
    /**
     * Filter, which DeletedPatents to fetch.
     */
    where: DeletedPatentsWhereUniqueInput
  }

  /**
   * DeletedPatents findUniqueOrThrow
   */
  export type DeletedPatentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedPatents
     */
    select?: DeletedPatentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletedPatentsInclude<ExtArgs> | null
    /**
     * Filter, which DeletedPatents to fetch.
     */
    where: DeletedPatentsWhereUniqueInput
  }

  /**
   * DeletedPatents findFirst
   */
  export type DeletedPatentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedPatents
     */
    select?: DeletedPatentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletedPatentsInclude<ExtArgs> | null
    /**
     * Filter, which DeletedPatents to fetch.
     */
    where?: DeletedPatentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeletedPatents to fetch.
     */
    orderBy?: DeletedPatentsOrderByWithRelationInput | DeletedPatentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeletedPatents.
     */
    cursor?: DeletedPatentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeletedPatents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeletedPatents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeletedPatents.
     */
    distinct?: DeletedPatentsScalarFieldEnum | DeletedPatentsScalarFieldEnum[]
  }

  /**
   * DeletedPatents findFirstOrThrow
   */
  export type DeletedPatentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedPatents
     */
    select?: DeletedPatentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletedPatentsInclude<ExtArgs> | null
    /**
     * Filter, which DeletedPatents to fetch.
     */
    where?: DeletedPatentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeletedPatents to fetch.
     */
    orderBy?: DeletedPatentsOrderByWithRelationInput | DeletedPatentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeletedPatents.
     */
    cursor?: DeletedPatentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeletedPatents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeletedPatents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeletedPatents.
     */
    distinct?: DeletedPatentsScalarFieldEnum | DeletedPatentsScalarFieldEnum[]
  }

  /**
   * DeletedPatents findMany
   */
  export type DeletedPatentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedPatents
     */
    select?: DeletedPatentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletedPatentsInclude<ExtArgs> | null
    /**
     * Filter, which DeletedPatents to fetch.
     */
    where?: DeletedPatentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeletedPatents to fetch.
     */
    orderBy?: DeletedPatentsOrderByWithRelationInput | DeletedPatentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeletedPatents.
     */
    cursor?: DeletedPatentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeletedPatents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeletedPatents.
     */
    skip?: number
    distinct?: DeletedPatentsScalarFieldEnum | DeletedPatentsScalarFieldEnum[]
  }

  /**
   * DeletedPatents create
   */
  export type DeletedPatentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedPatents
     */
    select?: DeletedPatentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletedPatentsInclude<ExtArgs> | null
    /**
     * The data needed to create a DeletedPatents.
     */
    data: XOR<DeletedPatentsCreateInput, DeletedPatentsUncheckedCreateInput>
  }

  /**
   * DeletedPatents createMany
   */
  export type DeletedPatentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeletedPatents.
     */
    data: DeletedPatentsCreateManyInput | DeletedPatentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeletedPatents createManyAndReturn
   */
  export type DeletedPatentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedPatents
     */
    select?: DeletedPatentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DeletedPatents.
     */
    data: DeletedPatentsCreateManyInput | DeletedPatentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletedPatentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeletedPatents update
   */
  export type DeletedPatentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedPatents
     */
    select?: DeletedPatentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletedPatentsInclude<ExtArgs> | null
    /**
     * The data needed to update a DeletedPatents.
     */
    data: XOR<DeletedPatentsUpdateInput, DeletedPatentsUncheckedUpdateInput>
    /**
     * Choose, which DeletedPatents to update.
     */
    where: DeletedPatentsWhereUniqueInput
  }

  /**
   * DeletedPatents updateMany
   */
  export type DeletedPatentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeletedPatents.
     */
    data: XOR<DeletedPatentsUpdateManyMutationInput, DeletedPatentsUncheckedUpdateManyInput>
    /**
     * Filter which DeletedPatents to update
     */
    where?: DeletedPatentsWhereInput
  }

  /**
   * DeletedPatents upsert
   */
  export type DeletedPatentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedPatents
     */
    select?: DeletedPatentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletedPatentsInclude<ExtArgs> | null
    /**
     * The filter to search for the DeletedPatents to update in case it exists.
     */
    where: DeletedPatentsWhereUniqueInput
    /**
     * In case the DeletedPatents found by the `where` argument doesn't exist, create a new DeletedPatents with this data.
     */
    create: XOR<DeletedPatentsCreateInput, DeletedPatentsUncheckedCreateInput>
    /**
     * In case the DeletedPatents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeletedPatentsUpdateInput, DeletedPatentsUncheckedUpdateInput>
  }

  /**
   * DeletedPatents delete
   */
  export type DeletedPatentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedPatents
     */
    select?: DeletedPatentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletedPatentsInclude<ExtArgs> | null
    /**
     * Filter which DeletedPatents to delete.
     */
    where: DeletedPatentsWhereUniqueInput
  }

  /**
   * DeletedPatents deleteMany
   */
  export type DeletedPatentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeletedPatents to delete
     */
    where?: DeletedPatentsWhereInput
  }

  /**
   * DeletedPatents without action
   */
  export type DeletedPatentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedPatents
     */
    select?: DeletedPatentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeletedPatentsInclude<ExtArgs> | null
  }


  /**
   * Model AssignHoursReports
   */

  export type AggregateAssignHoursReports = {
    _count: AssignHoursReportsCountAggregateOutputType | null
    _avg: AssignHoursReportsAvgAggregateOutputType | null
    _sum: AssignHoursReportsSumAggregateOutputType | null
    _min: AssignHoursReportsMinAggregateOutputType | null
    _max: AssignHoursReportsMaxAggregateOutputType | null
  }

  export type AssignHoursReportsAvgAggregateOutputType = {
    hoursAdded: number | null
    sellPointId: number | null
    hourPrice: number | null
    soldBy: number | null
  }

  export type AssignHoursReportsSumAggregateOutputType = {
    hoursAdded: number | null
    sellPointId: number | null
    hourPrice: number | null
    soldBy: number | null
  }

  export type AssignHoursReportsMinAggregateOutputType = {
    id: string | null
    hoursAdded: number | null
    addedAt: Date | null
    sellPointId: number | null
    hourPrice: number | null
    soldBy: number | null
  }

  export type AssignHoursReportsMaxAggregateOutputType = {
    id: string | null
    hoursAdded: number | null
    addedAt: Date | null
    sellPointId: number | null
    hourPrice: number | null
    soldBy: number | null
  }

  export type AssignHoursReportsCountAggregateOutputType = {
    id: number
    hoursAdded: number
    addedAt: number
    sellPointId: number
    hourPrice: number
    soldBy: number
    _all: number
  }


  export type AssignHoursReportsAvgAggregateInputType = {
    hoursAdded?: true
    sellPointId?: true
    hourPrice?: true
    soldBy?: true
  }

  export type AssignHoursReportsSumAggregateInputType = {
    hoursAdded?: true
    sellPointId?: true
    hourPrice?: true
    soldBy?: true
  }

  export type AssignHoursReportsMinAggregateInputType = {
    id?: true
    hoursAdded?: true
    addedAt?: true
    sellPointId?: true
    hourPrice?: true
    soldBy?: true
  }

  export type AssignHoursReportsMaxAggregateInputType = {
    id?: true
    hoursAdded?: true
    addedAt?: true
    sellPointId?: true
    hourPrice?: true
    soldBy?: true
  }

  export type AssignHoursReportsCountAggregateInputType = {
    id?: true
    hoursAdded?: true
    addedAt?: true
    sellPointId?: true
    hourPrice?: true
    soldBy?: true
    _all?: true
  }

  export type AssignHoursReportsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssignHoursReports to aggregate.
     */
    where?: AssignHoursReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignHoursReports to fetch.
     */
    orderBy?: AssignHoursReportsOrderByWithRelationInput | AssignHoursReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssignHoursReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignHoursReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignHoursReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssignHoursReports
    **/
    _count?: true | AssignHoursReportsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssignHoursReportsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssignHoursReportsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssignHoursReportsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssignHoursReportsMaxAggregateInputType
  }

  export type GetAssignHoursReportsAggregateType<T extends AssignHoursReportsAggregateArgs> = {
        [P in keyof T & keyof AggregateAssignHoursReports]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssignHoursReports[P]>
      : GetScalarType<T[P], AggregateAssignHoursReports[P]>
  }




  export type AssignHoursReportsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignHoursReportsWhereInput
    orderBy?: AssignHoursReportsOrderByWithAggregationInput | AssignHoursReportsOrderByWithAggregationInput[]
    by: AssignHoursReportsScalarFieldEnum[] | AssignHoursReportsScalarFieldEnum
    having?: AssignHoursReportsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssignHoursReportsCountAggregateInputType | true
    _avg?: AssignHoursReportsAvgAggregateInputType
    _sum?: AssignHoursReportsSumAggregateInputType
    _min?: AssignHoursReportsMinAggregateInputType
    _max?: AssignHoursReportsMaxAggregateInputType
  }

  export type AssignHoursReportsGroupByOutputType = {
    id: string
    hoursAdded: number
    addedAt: Date
    sellPointId: number
    hourPrice: number
    soldBy: number | null
    _count: AssignHoursReportsCountAggregateOutputType | null
    _avg: AssignHoursReportsAvgAggregateOutputType | null
    _sum: AssignHoursReportsSumAggregateOutputType | null
    _min: AssignHoursReportsMinAggregateOutputType | null
    _max: AssignHoursReportsMaxAggregateOutputType | null
  }

  type GetAssignHoursReportsGroupByPayload<T extends AssignHoursReportsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssignHoursReportsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssignHoursReportsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssignHoursReportsGroupByOutputType[P]>
            : GetScalarType<T[P], AssignHoursReportsGroupByOutputType[P]>
        }
      >
    >


  export type AssignHoursReportsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hoursAdded?: boolean
    addedAt?: boolean
    sellPointId?: boolean
    hourPrice?: boolean
    soldBy?: boolean
    sellPoint?: boolean | SellPointDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignHoursReports"]>

  export type AssignHoursReportsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hoursAdded?: boolean
    addedAt?: boolean
    sellPointId?: boolean
    hourPrice?: boolean
    soldBy?: boolean
    sellPoint?: boolean | SellPointDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignHoursReports"]>

  export type AssignHoursReportsSelectScalar = {
    id?: boolean
    hoursAdded?: boolean
    addedAt?: boolean
    sellPointId?: boolean
    hourPrice?: boolean
    soldBy?: boolean
  }

  export type AssignHoursReportsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sellPoint?: boolean | SellPointDefaultArgs<ExtArgs>
  }
  export type AssignHoursReportsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sellPoint?: boolean | SellPointDefaultArgs<ExtArgs>
  }

  export type $AssignHoursReportsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssignHoursReports"
    objects: {
      sellPoint: Prisma.$SellPointPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hoursAdded: number
      addedAt: Date
      sellPointId: number
      hourPrice: number
      soldBy: number | null
    }, ExtArgs["result"]["assignHoursReports"]>
    composites: {}
  }

  type AssignHoursReportsGetPayload<S extends boolean | null | undefined | AssignHoursReportsDefaultArgs> = $Result.GetResult<Prisma.$AssignHoursReportsPayload, S>

  type AssignHoursReportsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssignHoursReportsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssignHoursReportsCountAggregateInputType | true
    }

  export interface AssignHoursReportsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssignHoursReports'], meta: { name: 'AssignHoursReports' } }
    /**
     * Find zero or one AssignHoursReports that matches the filter.
     * @param {AssignHoursReportsFindUniqueArgs} args - Arguments to find a AssignHoursReports
     * @example
     * // Get one AssignHoursReports
     * const assignHoursReports = await prisma.assignHoursReports.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssignHoursReportsFindUniqueArgs>(args: SelectSubset<T, AssignHoursReportsFindUniqueArgs<ExtArgs>>): Prisma__AssignHoursReportsClient<$Result.GetResult<Prisma.$AssignHoursReportsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AssignHoursReports that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssignHoursReportsFindUniqueOrThrowArgs} args - Arguments to find a AssignHoursReports
     * @example
     * // Get one AssignHoursReports
     * const assignHoursReports = await prisma.assignHoursReports.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssignHoursReportsFindUniqueOrThrowArgs>(args: SelectSubset<T, AssignHoursReportsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssignHoursReportsClient<$Result.GetResult<Prisma.$AssignHoursReportsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AssignHoursReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignHoursReportsFindFirstArgs} args - Arguments to find a AssignHoursReports
     * @example
     * // Get one AssignHoursReports
     * const assignHoursReports = await prisma.assignHoursReports.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssignHoursReportsFindFirstArgs>(args?: SelectSubset<T, AssignHoursReportsFindFirstArgs<ExtArgs>>): Prisma__AssignHoursReportsClient<$Result.GetResult<Prisma.$AssignHoursReportsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AssignHoursReports that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignHoursReportsFindFirstOrThrowArgs} args - Arguments to find a AssignHoursReports
     * @example
     * // Get one AssignHoursReports
     * const assignHoursReports = await prisma.assignHoursReports.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssignHoursReportsFindFirstOrThrowArgs>(args?: SelectSubset<T, AssignHoursReportsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssignHoursReportsClient<$Result.GetResult<Prisma.$AssignHoursReportsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AssignHoursReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignHoursReportsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssignHoursReports
     * const assignHoursReports = await prisma.assignHoursReports.findMany()
     * 
     * // Get first 10 AssignHoursReports
     * const assignHoursReports = await prisma.assignHoursReports.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assignHoursReportsWithIdOnly = await prisma.assignHoursReports.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssignHoursReportsFindManyArgs>(args?: SelectSubset<T, AssignHoursReportsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignHoursReportsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AssignHoursReports.
     * @param {AssignHoursReportsCreateArgs} args - Arguments to create a AssignHoursReports.
     * @example
     * // Create one AssignHoursReports
     * const AssignHoursReports = await prisma.assignHoursReports.create({
     *   data: {
     *     // ... data to create a AssignHoursReports
     *   }
     * })
     * 
     */
    create<T extends AssignHoursReportsCreateArgs>(args: SelectSubset<T, AssignHoursReportsCreateArgs<ExtArgs>>): Prisma__AssignHoursReportsClient<$Result.GetResult<Prisma.$AssignHoursReportsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AssignHoursReports.
     * @param {AssignHoursReportsCreateManyArgs} args - Arguments to create many AssignHoursReports.
     * @example
     * // Create many AssignHoursReports
     * const assignHoursReports = await prisma.assignHoursReports.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssignHoursReportsCreateManyArgs>(args?: SelectSubset<T, AssignHoursReportsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssignHoursReports and returns the data saved in the database.
     * @param {AssignHoursReportsCreateManyAndReturnArgs} args - Arguments to create many AssignHoursReports.
     * @example
     * // Create many AssignHoursReports
     * const assignHoursReports = await prisma.assignHoursReports.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssignHoursReports and only return the `id`
     * const assignHoursReportsWithIdOnly = await prisma.assignHoursReports.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssignHoursReportsCreateManyAndReturnArgs>(args?: SelectSubset<T, AssignHoursReportsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignHoursReportsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AssignHoursReports.
     * @param {AssignHoursReportsDeleteArgs} args - Arguments to delete one AssignHoursReports.
     * @example
     * // Delete one AssignHoursReports
     * const AssignHoursReports = await prisma.assignHoursReports.delete({
     *   where: {
     *     // ... filter to delete one AssignHoursReports
     *   }
     * })
     * 
     */
    delete<T extends AssignHoursReportsDeleteArgs>(args: SelectSubset<T, AssignHoursReportsDeleteArgs<ExtArgs>>): Prisma__AssignHoursReportsClient<$Result.GetResult<Prisma.$AssignHoursReportsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AssignHoursReports.
     * @param {AssignHoursReportsUpdateArgs} args - Arguments to update one AssignHoursReports.
     * @example
     * // Update one AssignHoursReports
     * const assignHoursReports = await prisma.assignHoursReports.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssignHoursReportsUpdateArgs>(args: SelectSubset<T, AssignHoursReportsUpdateArgs<ExtArgs>>): Prisma__AssignHoursReportsClient<$Result.GetResult<Prisma.$AssignHoursReportsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AssignHoursReports.
     * @param {AssignHoursReportsDeleteManyArgs} args - Arguments to filter AssignHoursReports to delete.
     * @example
     * // Delete a few AssignHoursReports
     * const { count } = await prisma.assignHoursReports.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssignHoursReportsDeleteManyArgs>(args?: SelectSubset<T, AssignHoursReportsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssignHoursReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignHoursReportsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssignHoursReports
     * const assignHoursReports = await prisma.assignHoursReports.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssignHoursReportsUpdateManyArgs>(args: SelectSubset<T, AssignHoursReportsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AssignHoursReports.
     * @param {AssignHoursReportsUpsertArgs} args - Arguments to update or create a AssignHoursReports.
     * @example
     * // Update or create a AssignHoursReports
     * const assignHoursReports = await prisma.assignHoursReports.upsert({
     *   create: {
     *     // ... data to create a AssignHoursReports
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssignHoursReports we want to update
     *   }
     * })
     */
    upsert<T extends AssignHoursReportsUpsertArgs>(args: SelectSubset<T, AssignHoursReportsUpsertArgs<ExtArgs>>): Prisma__AssignHoursReportsClient<$Result.GetResult<Prisma.$AssignHoursReportsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AssignHoursReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignHoursReportsCountArgs} args - Arguments to filter AssignHoursReports to count.
     * @example
     * // Count the number of AssignHoursReports
     * const count = await prisma.assignHoursReports.count({
     *   where: {
     *     // ... the filter for the AssignHoursReports we want to count
     *   }
     * })
    **/
    count<T extends AssignHoursReportsCountArgs>(
      args?: Subset<T, AssignHoursReportsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssignHoursReportsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssignHoursReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignHoursReportsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssignHoursReportsAggregateArgs>(args: Subset<T, AssignHoursReportsAggregateArgs>): Prisma.PrismaPromise<GetAssignHoursReportsAggregateType<T>>

    /**
     * Group by AssignHoursReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignHoursReportsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssignHoursReportsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssignHoursReportsGroupByArgs['orderBy'] }
        : { orderBy?: AssignHoursReportsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssignHoursReportsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssignHoursReportsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssignHoursReports model
   */
  readonly fields: AssignHoursReportsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssignHoursReports.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssignHoursReportsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sellPoint<T extends SellPointDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SellPointDefaultArgs<ExtArgs>>): Prisma__SellPointClient<$Result.GetResult<Prisma.$SellPointPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssignHoursReports model
   */ 
  interface AssignHoursReportsFieldRefs {
    readonly id: FieldRef<"AssignHoursReports", 'String'>
    readonly hoursAdded: FieldRef<"AssignHoursReports", 'Int'>
    readonly addedAt: FieldRef<"AssignHoursReports", 'DateTime'>
    readonly sellPointId: FieldRef<"AssignHoursReports", 'Int'>
    readonly hourPrice: FieldRef<"AssignHoursReports", 'Float'>
    readonly soldBy: FieldRef<"AssignHoursReports", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AssignHoursReports findUnique
   */
  export type AssignHoursReportsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignHoursReports
     */
    select?: AssignHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignHoursReportsInclude<ExtArgs> | null
    /**
     * Filter, which AssignHoursReports to fetch.
     */
    where: AssignHoursReportsWhereUniqueInput
  }

  /**
   * AssignHoursReports findUniqueOrThrow
   */
  export type AssignHoursReportsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignHoursReports
     */
    select?: AssignHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignHoursReportsInclude<ExtArgs> | null
    /**
     * Filter, which AssignHoursReports to fetch.
     */
    where: AssignHoursReportsWhereUniqueInput
  }

  /**
   * AssignHoursReports findFirst
   */
  export type AssignHoursReportsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignHoursReports
     */
    select?: AssignHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignHoursReportsInclude<ExtArgs> | null
    /**
     * Filter, which AssignHoursReports to fetch.
     */
    where?: AssignHoursReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignHoursReports to fetch.
     */
    orderBy?: AssignHoursReportsOrderByWithRelationInput | AssignHoursReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssignHoursReports.
     */
    cursor?: AssignHoursReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignHoursReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignHoursReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssignHoursReports.
     */
    distinct?: AssignHoursReportsScalarFieldEnum | AssignHoursReportsScalarFieldEnum[]
  }

  /**
   * AssignHoursReports findFirstOrThrow
   */
  export type AssignHoursReportsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignHoursReports
     */
    select?: AssignHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignHoursReportsInclude<ExtArgs> | null
    /**
     * Filter, which AssignHoursReports to fetch.
     */
    where?: AssignHoursReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignHoursReports to fetch.
     */
    orderBy?: AssignHoursReportsOrderByWithRelationInput | AssignHoursReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssignHoursReports.
     */
    cursor?: AssignHoursReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignHoursReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignHoursReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssignHoursReports.
     */
    distinct?: AssignHoursReportsScalarFieldEnum | AssignHoursReportsScalarFieldEnum[]
  }

  /**
   * AssignHoursReports findMany
   */
  export type AssignHoursReportsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignHoursReports
     */
    select?: AssignHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignHoursReportsInclude<ExtArgs> | null
    /**
     * Filter, which AssignHoursReports to fetch.
     */
    where?: AssignHoursReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignHoursReports to fetch.
     */
    orderBy?: AssignHoursReportsOrderByWithRelationInput | AssignHoursReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssignHoursReports.
     */
    cursor?: AssignHoursReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignHoursReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignHoursReports.
     */
    skip?: number
    distinct?: AssignHoursReportsScalarFieldEnum | AssignHoursReportsScalarFieldEnum[]
  }

  /**
   * AssignHoursReports create
   */
  export type AssignHoursReportsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignHoursReports
     */
    select?: AssignHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignHoursReportsInclude<ExtArgs> | null
    /**
     * The data needed to create a AssignHoursReports.
     */
    data: XOR<AssignHoursReportsCreateInput, AssignHoursReportsUncheckedCreateInput>
  }

  /**
   * AssignHoursReports createMany
   */
  export type AssignHoursReportsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssignHoursReports.
     */
    data: AssignHoursReportsCreateManyInput | AssignHoursReportsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssignHoursReports createManyAndReturn
   */
  export type AssignHoursReportsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignHoursReports
     */
    select?: AssignHoursReportsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AssignHoursReports.
     */
    data: AssignHoursReportsCreateManyInput | AssignHoursReportsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignHoursReportsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssignHoursReports update
   */
  export type AssignHoursReportsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignHoursReports
     */
    select?: AssignHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignHoursReportsInclude<ExtArgs> | null
    /**
     * The data needed to update a AssignHoursReports.
     */
    data: XOR<AssignHoursReportsUpdateInput, AssignHoursReportsUncheckedUpdateInput>
    /**
     * Choose, which AssignHoursReports to update.
     */
    where: AssignHoursReportsWhereUniqueInput
  }

  /**
   * AssignHoursReports updateMany
   */
  export type AssignHoursReportsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssignHoursReports.
     */
    data: XOR<AssignHoursReportsUpdateManyMutationInput, AssignHoursReportsUncheckedUpdateManyInput>
    /**
     * Filter which AssignHoursReports to update
     */
    where?: AssignHoursReportsWhereInput
  }

  /**
   * AssignHoursReports upsert
   */
  export type AssignHoursReportsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignHoursReports
     */
    select?: AssignHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignHoursReportsInclude<ExtArgs> | null
    /**
     * The filter to search for the AssignHoursReports to update in case it exists.
     */
    where: AssignHoursReportsWhereUniqueInput
    /**
     * In case the AssignHoursReports found by the `where` argument doesn't exist, create a new AssignHoursReports with this data.
     */
    create: XOR<AssignHoursReportsCreateInput, AssignHoursReportsUncheckedCreateInput>
    /**
     * In case the AssignHoursReports was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssignHoursReportsUpdateInput, AssignHoursReportsUncheckedUpdateInput>
  }

  /**
   * AssignHoursReports delete
   */
  export type AssignHoursReportsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignHoursReports
     */
    select?: AssignHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignHoursReportsInclude<ExtArgs> | null
    /**
     * Filter which AssignHoursReports to delete.
     */
    where: AssignHoursReportsWhereUniqueInput
  }

  /**
   * AssignHoursReports deleteMany
   */
  export type AssignHoursReportsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssignHoursReports to delete
     */
    where?: AssignHoursReportsWhereInput
  }

  /**
   * AssignHoursReports without action
   */
  export type AssignHoursReportsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignHoursReports
     */
    select?: AssignHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignHoursReportsInclude<ExtArgs> | null
  }


  /**
   * Model AssignPatentHoursReports
   */

  export type AggregateAssignPatentHoursReports = {
    _count: AssignPatentHoursReportsCountAggregateOutputType | null
    _avg: AssignPatentHoursReportsAvgAggregateOutputType | null
    _sum: AssignPatentHoursReportsSumAggregateOutputType | null
    _min: AssignPatentHoursReportsMinAggregateOutputType | null
    _max: AssignPatentHoursReportsMaxAggregateOutputType | null
  }

  export type AssignPatentHoursReportsAvgAggregateOutputType = {
    hoursAdded: number | null
    sellPointId: number | null
    hourPrice: number | null
    dni: number | null
    soldBy: number | null
  }

  export type AssignPatentHoursReportsSumAggregateOutputType = {
    hoursAdded: number | null
    sellPointId: number | null
    hourPrice: number | null
    dni: number | null
    soldBy: number | null
  }

  export type AssignPatentHoursReportsMinAggregateOutputType = {
    id: string | null
    hoursAdded: number | null
    addedAt: Date | null
    sellPointId: number | null
    hourPrice: number | null
    patentId: string | null
    dni: number | null
    soldBy: number | null
  }

  export type AssignPatentHoursReportsMaxAggregateOutputType = {
    id: string | null
    hoursAdded: number | null
    addedAt: Date | null
    sellPointId: number | null
    hourPrice: number | null
    patentId: string | null
    dni: number | null
    soldBy: number | null
  }

  export type AssignPatentHoursReportsCountAggregateOutputType = {
    id: number
    hoursAdded: number
    addedAt: number
    sellPointId: number
    hourPrice: number
    patentId: number
    dni: number
    soldBy: number
    _all: number
  }


  export type AssignPatentHoursReportsAvgAggregateInputType = {
    hoursAdded?: true
    sellPointId?: true
    hourPrice?: true
    dni?: true
    soldBy?: true
  }

  export type AssignPatentHoursReportsSumAggregateInputType = {
    hoursAdded?: true
    sellPointId?: true
    hourPrice?: true
    dni?: true
    soldBy?: true
  }

  export type AssignPatentHoursReportsMinAggregateInputType = {
    id?: true
    hoursAdded?: true
    addedAt?: true
    sellPointId?: true
    hourPrice?: true
    patentId?: true
    dni?: true
    soldBy?: true
  }

  export type AssignPatentHoursReportsMaxAggregateInputType = {
    id?: true
    hoursAdded?: true
    addedAt?: true
    sellPointId?: true
    hourPrice?: true
    patentId?: true
    dni?: true
    soldBy?: true
  }

  export type AssignPatentHoursReportsCountAggregateInputType = {
    id?: true
    hoursAdded?: true
    addedAt?: true
    sellPointId?: true
    hourPrice?: true
    patentId?: true
    dni?: true
    soldBy?: true
    _all?: true
  }

  export type AssignPatentHoursReportsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssignPatentHoursReports to aggregate.
     */
    where?: AssignPatentHoursReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignPatentHoursReports to fetch.
     */
    orderBy?: AssignPatentHoursReportsOrderByWithRelationInput | AssignPatentHoursReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssignPatentHoursReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignPatentHoursReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignPatentHoursReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssignPatentHoursReports
    **/
    _count?: true | AssignPatentHoursReportsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssignPatentHoursReportsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssignPatentHoursReportsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssignPatentHoursReportsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssignPatentHoursReportsMaxAggregateInputType
  }

  export type GetAssignPatentHoursReportsAggregateType<T extends AssignPatentHoursReportsAggregateArgs> = {
        [P in keyof T & keyof AggregateAssignPatentHoursReports]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssignPatentHoursReports[P]>
      : GetScalarType<T[P], AggregateAssignPatentHoursReports[P]>
  }




  export type AssignPatentHoursReportsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignPatentHoursReportsWhereInput
    orderBy?: AssignPatentHoursReportsOrderByWithAggregationInput | AssignPatentHoursReportsOrderByWithAggregationInput[]
    by: AssignPatentHoursReportsScalarFieldEnum[] | AssignPatentHoursReportsScalarFieldEnum
    having?: AssignPatentHoursReportsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssignPatentHoursReportsCountAggregateInputType | true
    _avg?: AssignPatentHoursReportsAvgAggregateInputType
    _sum?: AssignPatentHoursReportsSumAggregateInputType
    _min?: AssignPatentHoursReportsMinAggregateInputType
    _max?: AssignPatentHoursReportsMaxAggregateInputType
  }

  export type AssignPatentHoursReportsGroupByOutputType = {
    id: string
    hoursAdded: number
    addedAt: Date
    sellPointId: number | null
    hourPrice: number
    patentId: string
    dni: number
    soldBy: number | null
    _count: AssignPatentHoursReportsCountAggregateOutputType | null
    _avg: AssignPatentHoursReportsAvgAggregateOutputType | null
    _sum: AssignPatentHoursReportsSumAggregateOutputType | null
    _min: AssignPatentHoursReportsMinAggregateOutputType | null
    _max: AssignPatentHoursReportsMaxAggregateOutputType | null
  }

  type GetAssignPatentHoursReportsGroupByPayload<T extends AssignPatentHoursReportsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssignPatentHoursReportsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssignPatentHoursReportsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssignPatentHoursReportsGroupByOutputType[P]>
            : GetScalarType<T[P], AssignPatentHoursReportsGroupByOutputType[P]>
        }
      >
    >


  export type AssignPatentHoursReportsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hoursAdded?: boolean
    addedAt?: boolean
    sellPointId?: boolean
    hourPrice?: boolean
    patentId?: boolean
    dni?: boolean
    soldBy?: boolean
    sellPoint?: boolean | AssignPatentHoursReports$sellPointArgs<ExtArgs>
  }, ExtArgs["result"]["assignPatentHoursReports"]>

  export type AssignPatentHoursReportsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hoursAdded?: boolean
    addedAt?: boolean
    sellPointId?: boolean
    hourPrice?: boolean
    patentId?: boolean
    dni?: boolean
    soldBy?: boolean
    sellPoint?: boolean | AssignPatentHoursReports$sellPointArgs<ExtArgs>
  }, ExtArgs["result"]["assignPatentHoursReports"]>

  export type AssignPatentHoursReportsSelectScalar = {
    id?: boolean
    hoursAdded?: boolean
    addedAt?: boolean
    sellPointId?: boolean
    hourPrice?: boolean
    patentId?: boolean
    dni?: boolean
    soldBy?: boolean
  }

  export type AssignPatentHoursReportsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sellPoint?: boolean | AssignPatentHoursReports$sellPointArgs<ExtArgs>
  }
  export type AssignPatentHoursReportsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sellPoint?: boolean | AssignPatentHoursReports$sellPointArgs<ExtArgs>
  }

  export type $AssignPatentHoursReportsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssignPatentHoursReports"
    objects: {
      sellPoint: Prisma.$SellPointPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hoursAdded: number
      addedAt: Date
      sellPointId: number | null
      hourPrice: number
      patentId: string
      dni: number
      soldBy: number | null
    }, ExtArgs["result"]["assignPatentHoursReports"]>
    composites: {}
  }

  type AssignPatentHoursReportsGetPayload<S extends boolean | null | undefined | AssignPatentHoursReportsDefaultArgs> = $Result.GetResult<Prisma.$AssignPatentHoursReportsPayload, S>

  type AssignPatentHoursReportsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssignPatentHoursReportsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssignPatentHoursReportsCountAggregateInputType | true
    }

  export interface AssignPatentHoursReportsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssignPatentHoursReports'], meta: { name: 'AssignPatentHoursReports' } }
    /**
     * Find zero or one AssignPatentHoursReports that matches the filter.
     * @param {AssignPatentHoursReportsFindUniqueArgs} args - Arguments to find a AssignPatentHoursReports
     * @example
     * // Get one AssignPatentHoursReports
     * const assignPatentHoursReports = await prisma.assignPatentHoursReports.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssignPatentHoursReportsFindUniqueArgs>(args: SelectSubset<T, AssignPatentHoursReportsFindUniqueArgs<ExtArgs>>): Prisma__AssignPatentHoursReportsClient<$Result.GetResult<Prisma.$AssignPatentHoursReportsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AssignPatentHoursReports that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssignPatentHoursReportsFindUniqueOrThrowArgs} args - Arguments to find a AssignPatentHoursReports
     * @example
     * // Get one AssignPatentHoursReports
     * const assignPatentHoursReports = await prisma.assignPatentHoursReports.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssignPatentHoursReportsFindUniqueOrThrowArgs>(args: SelectSubset<T, AssignPatentHoursReportsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssignPatentHoursReportsClient<$Result.GetResult<Prisma.$AssignPatentHoursReportsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AssignPatentHoursReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignPatentHoursReportsFindFirstArgs} args - Arguments to find a AssignPatentHoursReports
     * @example
     * // Get one AssignPatentHoursReports
     * const assignPatentHoursReports = await prisma.assignPatentHoursReports.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssignPatentHoursReportsFindFirstArgs>(args?: SelectSubset<T, AssignPatentHoursReportsFindFirstArgs<ExtArgs>>): Prisma__AssignPatentHoursReportsClient<$Result.GetResult<Prisma.$AssignPatentHoursReportsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AssignPatentHoursReports that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignPatentHoursReportsFindFirstOrThrowArgs} args - Arguments to find a AssignPatentHoursReports
     * @example
     * // Get one AssignPatentHoursReports
     * const assignPatentHoursReports = await prisma.assignPatentHoursReports.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssignPatentHoursReportsFindFirstOrThrowArgs>(args?: SelectSubset<T, AssignPatentHoursReportsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssignPatentHoursReportsClient<$Result.GetResult<Prisma.$AssignPatentHoursReportsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AssignPatentHoursReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignPatentHoursReportsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssignPatentHoursReports
     * const assignPatentHoursReports = await prisma.assignPatentHoursReports.findMany()
     * 
     * // Get first 10 AssignPatentHoursReports
     * const assignPatentHoursReports = await prisma.assignPatentHoursReports.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assignPatentHoursReportsWithIdOnly = await prisma.assignPatentHoursReports.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssignPatentHoursReportsFindManyArgs>(args?: SelectSubset<T, AssignPatentHoursReportsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignPatentHoursReportsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AssignPatentHoursReports.
     * @param {AssignPatentHoursReportsCreateArgs} args - Arguments to create a AssignPatentHoursReports.
     * @example
     * // Create one AssignPatentHoursReports
     * const AssignPatentHoursReports = await prisma.assignPatentHoursReports.create({
     *   data: {
     *     // ... data to create a AssignPatentHoursReports
     *   }
     * })
     * 
     */
    create<T extends AssignPatentHoursReportsCreateArgs>(args: SelectSubset<T, AssignPatentHoursReportsCreateArgs<ExtArgs>>): Prisma__AssignPatentHoursReportsClient<$Result.GetResult<Prisma.$AssignPatentHoursReportsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AssignPatentHoursReports.
     * @param {AssignPatentHoursReportsCreateManyArgs} args - Arguments to create many AssignPatentHoursReports.
     * @example
     * // Create many AssignPatentHoursReports
     * const assignPatentHoursReports = await prisma.assignPatentHoursReports.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssignPatentHoursReportsCreateManyArgs>(args?: SelectSubset<T, AssignPatentHoursReportsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssignPatentHoursReports and returns the data saved in the database.
     * @param {AssignPatentHoursReportsCreateManyAndReturnArgs} args - Arguments to create many AssignPatentHoursReports.
     * @example
     * // Create many AssignPatentHoursReports
     * const assignPatentHoursReports = await prisma.assignPatentHoursReports.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssignPatentHoursReports and only return the `id`
     * const assignPatentHoursReportsWithIdOnly = await prisma.assignPatentHoursReports.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssignPatentHoursReportsCreateManyAndReturnArgs>(args?: SelectSubset<T, AssignPatentHoursReportsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignPatentHoursReportsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AssignPatentHoursReports.
     * @param {AssignPatentHoursReportsDeleteArgs} args - Arguments to delete one AssignPatentHoursReports.
     * @example
     * // Delete one AssignPatentHoursReports
     * const AssignPatentHoursReports = await prisma.assignPatentHoursReports.delete({
     *   where: {
     *     // ... filter to delete one AssignPatentHoursReports
     *   }
     * })
     * 
     */
    delete<T extends AssignPatentHoursReportsDeleteArgs>(args: SelectSubset<T, AssignPatentHoursReportsDeleteArgs<ExtArgs>>): Prisma__AssignPatentHoursReportsClient<$Result.GetResult<Prisma.$AssignPatentHoursReportsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AssignPatentHoursReports.
     * @param {AssignPatentHoursReportsUpdateArgs} args - Arguments to update one AssignPatentHoursReports.
     * @example
     * // Update one AssignPatentHoursReports
     * const assignPatentHoursReports = await prisma.assignPatentHoursReports.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssignPatentHoursReportsUpdateArgs>(args: SelectSubset<T, AssignPatentHoursReportsUpdateArgs<ExtArgs>>): Prisma__AssignPatentHoursReportsClient<$Result.GetResult<Prisma.$AssignPatentHoursReportsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AssignPatentHoursReports.
     * @param {AssignPatentHoursReportsDeleteManyArgs} args - Arguments to filter AssignPatentHoursReports to delete.
     * @example
     * // Delete a few AssignPatentHoursReports
     * const { count } = await prisma.assignPatentHoursReports.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssignPatentHoursReportsDeleteManyArgs>(args?: SelectSubset<T, AssignPatentHoursReportsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssignPatentHoursReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignPatentHoursReportsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssignPatentHoursReports
     * const assignPatentHoursReports = await prisma.assignPatentHoursReports.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssignPatentHoursReportsUpdateManyArgs>(args: SelectSubset<T, AssignPatentHoursReportsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AssignPatentHoursReports.
     * @param {AssignPatentHoursReportsUpsertArgs} args - Arguments to update or create a AssignPatentHoursReports.
     * @example
     * // Update or create a AssignPatentHoursReports
     * const assignPatentHoursReports = await prisma.assignPatentHoursReports.upsert({
     *   create: {
     *     // ... data to create a AssignPatentHoursReports
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssignPatentHoursReports we want to update
     *   }
     * })
     */
    upsert<T extends AssignPatentHoursReportsUpsertArgs>(args: SelectSubset<T, AssignPatentHoursReportsUpsertArgs<ExtArgs>>): Prisma__AssignPatentHoursReportsClient<$Result.GetResult<Prisma.$AssignPatentHoursReportsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AssignPatentHoursReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignPatentHoursReportsCountArgs} args - Arguments to filter AssignPatentHoursReports to count.
     * @example
     * // Count the number of AssignPatentHoursReports
     * const count = await prisma.assignPatentHoursReports.count({
     *   where: {
     *     // ... the filter for the AssignPatentHoursReports we want to count
     *   }
     * })
    **/
    count<T extends AssignPatentHoursReportsCountArgs>(
      args?: Subset<T, AssignPatentHoursReportsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssignPatentHoursReportsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssignPatentHoursReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignPatentHoursReportsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssignPatentHoursReportsAggregateArgs>(args: Subset<T, AssignPatentHoursReportsAggregateArgs>): Prisma.PrismaPromise<GetAssignPatentHoursReportsAggregateType<T>>

    /**
     * Group by AssignPatentHoursReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignPatentHoursReportsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssignPatentHoursReportsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssignPatentHoursReportsGroupByArgs['orderBy'] }
        : { orderBy?: AssignPatentHoursReportsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssignPatentHoursReportsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssignPatentHoursReportsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssignPatentHoursReports model
   */
  readonly fields: AssignPatentHoursReportsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssignPatentHoursReports.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssignPatentHoursReportsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sellPoint<T extends AssignPatentHoursReports$sellPointArgs<ExtArgs> = {}>(args?: Subset<T, AssignPatentHoursReports$sellPointArgs<ExtArgs>>): Prisma__SellPointClient<$Result.GetResult<Prisma.$SellPointPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssignPatentHoursReports model
   */ 
  interface AssignPatentHoursReportsFieldRefs {
    readonly id: FieldRef<"AssignPatentHoursReports", 'String'>
    readonly hoursAdded: FieldRef<"AssignPatentHoursReports", 'Int'>
    readonly addedAt: FieldRef<"AssignPatentHoursReports", 'DateTime'>
    readonly sellPointId: FieldRef<"AssignPatentHoursReports", 'Int'>
    readonly hourPrice: FieldRef<"AssignPatentHoursReports", 'Float'>
    readonly patentId: FieldRef<"AssignPatentHoursReports", 'String'>
    readonly dni: FieldRef<"AssignPatentHoursReports", 'Int'>
    readonly soldBy: FieldRef<"AssignPatentHoursReports", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AssignPatentHoursReports findUnique
   */
  export type AssignPatentHoursReportsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignPatentHoursReports
     */
    select?: AssignPatentHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignPatentHoursReportsInclude<ExtArgs> | null
    /**
     * Filter, which AssignPatentHoursReports to fetch.
     */
    where: AssignPatentHoursReportsWhereUniqueInput
  }

  /**
   * AssignPatentHoursReports findUniqueOrThrow
   */
  export type AssignPatentHoursReportsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignPatentHoursReports
     */
    select?: AssignPatentHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignPatentHoursReportsInclude<ExtArgs> | null
    /**
     * Filter, which AssignPatentHoursReports to fetch.
     */
    where: AssignPatentHoursReportsWhereUniqueInput
  }

  /**
   * AssignPatentHoursReports findFirst
   */
  export type AssignPatentHoursReportsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignPatentHoursReports
     */
    select?: AssignPatentHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignPatentHoursReportsInclude<ExtArgs> | null
    /**
     * Filter, which AssignPatentHoursReports to fetch.
     */
    where?: AssignPatentHoursReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignPatentHoursReports to fetch.
     */
    orderBy?: AssignPatentHoursReportsOrderByWithRelationInput | AssignPatentHoursReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssignPatentHoursReports.
     */
    cursor?: AssignPatentHoursReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignPatentHoursReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignPatentHoursReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssignPatentHoursReports.
     */
    distinct?: AssignPatentHoursReportsScalarFieldEnum | AssignPatentHoursReportsScalarFieldEnum[]
  }

  /**
   * AssignPatentHoursReports findFirstOrThrow
   */
  export type AssignPatentHoursReportsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignPatentHoursReports
     */
    select?: AssignPatentHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignPatentHoursReportsInclude<ExtArgs> | null
    /**
     * Filter, which AssignPatentHoursReports to fetch.
     */
    where?: AssignPatentHoursReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignPatentHoursReports to fetch.
     */
    orderBy?: AssignPatentHoursReportsOrderByWithRelationInput | AssignPatentHoursReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssignPatentHoursReports.
     */
    cursor?: AssignPatentHoursReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignPatentHoursReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignPatentHoursReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssignPatentHoursReports.
     */
    distinct?: AssignPatentHoursReportsScalarFieldEnum | AssignPatentHoursReportsScalarFieldEnum[]
  }

  /**
   * AssignPatentHoursReports findMany
   */
  export type AssignPatentHoursReportsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignPatentHoursReports
     */
    select?: AssignPatentHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignPatentHoursReportsInclude<ExtArgs> | null
    /**
     * Filter, which AssignPatentHoursReports to fetch.
     */
    where?: AssignPatentHoursReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignPatentHoursReports to fetch.
     */
    orderBy?: AssignPatentHoursReportsOrderByWithRelationInput | AssignPatentHoursReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssignPatentHoursReports.
     */
    cursor?: AssignPatentHoursReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignPatentHoursReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignPatentHoursReports.
     */
    skip?: number
    distinct?: AssignPatentHoursReportsScalarFieldEnum | AssignPatentHoursReportsScalarFieldEnum[]
  }

  /**
   * AssignPatentHoursReports create
   */
  export type AssignPatentHoursReportsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignPatentHoursReports
     */
    select?: AssignPatentHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignPatentHoursReportsInclude<ExtArgs> | null
    /**
     * The data needed to create a AssignPatentHoursReports.
     */
    data: XOR<AssignPatentHoursReportsCreateInput, AssignPatentHoursReportsUncheckedCreateInput>
  }

  /**
   * AssignPatentHoursReports createMany
   */
  export type AssignPatentHoursReportsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssignPatentHoursReports.
     */
    data: AssignPatentHoursReportsCreateManyInput | AssignPatentHoursReportsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssignPatentHoursReports createManyAndReturn
   */
  export type AssignPatentHoursReportsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignPatentHoursReports
     */
    select?: AssignPatentHoursReportsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AssignPatentHoursReports.
     */
    data: AssignPatentHoursReportsCreateManyInput | AssignPatentHoursReportsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignPatentHoursReportsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssignPatentHoursReports update
   */
  export type AssignPatentHoursReportsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignPatentHoursReports
     */
    select?: AssignPatentHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignPatentHoursReportsInclude<ExtArgs> | null
    /**
     * The data needed to update a AssignPatentHoursReports.
     */
    data: XOR<AssignPatentHoursReportsUpdateInput, AssignPatentHoursReportsUncheckedUpdateInput>
    /**
     * Choose, which AssignPatentHoursReports to update.
     */
    where: AssignPatentHoursReportsWhereUniqueInput
  }

  /**
   * AssignPatentHoursReports updateMany
   */
  export type AssignPatentHoursReportsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssignPatentHoursReports.
     */
    data: XOR<AssignPatentHoursReportsUpdateManyMutationInput, AssignPatentHoursReportsUncheckedUpdateManyInput>
    /**
     * Filter which AssignPatentHoursReports to update
     */
    where?: AssignPatentHoursReportsWhereInput
  }

  /**
   * AssignPatentHoursReports upsert
   */
  export type AssignPatentHoursReportsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignPatentHoursReports
     */
    select?: AssignPatentHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignPatentHoursReportsInclude<ExtArgs> | null
    /**
     * The filter to search for the AssignPatentHoursReports to update in case it exists.
     */
    where: AssignPatentHoursReportsWhereUniqueInput
    /**
     * In case the AssignPatentHoursReports found by the `where` argument doesn't exist, create a new AssignPatentHoursReports with this data.
     */
    create: XOR<AssignPatentHoursReportsCreateInput, AssignPatentHoursReportsUncheckedCreateInput>
    /**
     * In case the AssignPatentHoursReports was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssignPatentHoursReportsUpdateInput, AssignPatentHoursReportsUncheckedUpdateInput>
  }

  /**
   * AssignPatentHoursReports delete
   */
  export type AssignPatentHoursReportsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignPatentHoursReports
     */
    select?: AssignPatentHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignPatentHoursReportsInclude<ExtArgs> | null
    /**
     * Filter which AssignPatentHoursReports to delete.
     */
    where: AssignPatentHoursReportsWhereUniqueInput
  }

  /**
   * AssignPatentHoursReports deleteMany
   */
  export type AssignPatentHoursReportsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssignPatentHoursReports to delete
     */
    where?: AssignPatentHoursReportsWhereInput
  }

  /**
   * AssignPatentHoursReports.sellPoint
   */
  export type AssignPatentHoursReports$sellPointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellPoint
     */
    select?: SellPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellPointInclude<ExtArgs> | null
    where?: SellPointWhereInput
  }

  /**
   * AssignPatentHoursReports without action
   */
  export type AssignPatentHoursReportsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignPatentHoursReports
     */
    select?: AssignPatentHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignPatentHoursReportsInclude<ExtArgs> | null
  }


  /**
   * Model SellingHoursReports
   */

  export type AggregateSellingHoursReports = {
    _count: SellingHoursReportsCountAggregateOutputType | null
    _avg: SellingHoursReportsAvgAggregateOutputType | null
    _sum: SellingHoursReportsSumAggregateOutputType | null
    _min: SellingHoursReportsMinAggregateOutputType | null
    _max: SellingHoursReportsMaxAggregateOutputType | null
  }

  export type SellingHoursReportsAvgAggregateOutputType = {
    hoursAdded: number | null
    userId: number | null
    hourPrice: number | null
    soldBy: number | null
    targetUserId: number | null
  }

  export type SellingHoursReportsSumAggregateOutputType = {
    hoursAdded: number | null
    userId: number | null
    hourPrice: number | null
    soldBy: number | null
    targetUserId: number | null
  }

  export type SellingHoursReportsMinAggregateOutputType = {
    id: string | null
    hoursAdded: number | null
    addedAt: Date | null
    userId: number | null
    hourPrice: number | null
    soldBy: number | null
    targetUserId: number | null
  }

  export type SellingHoursReportsMaxAggregateOutputType = {
    id: string | null
    hoursAdded: number | null
    addedAt: Date | null
    userId: number | null
    hourPrice: number | null
    soldBy: number | null
    targetUserId: number | null
  }

  export type SellingHoursReportsCountAggregateOutputType = {
    id: number
    hoursAdded: number
    addedAt: number
    userId: number
    hourPrice: number
    soldBy: number
    targetUserId: number
    _all: number
  }


  export type SellingHoursReportsAvgAggregateInputType = {
    hoursAdded?: true
    userId?: true
    hourPrice?: true
    soldBy?: true
    targetUserId?: true
  }

  export type SellingHoursReportsSumAggregateInputType = {
    hoursAdded?: true
    userId?: true
    hourPrice?: true
    soldBy?: true
    targetUserId?: true
  }

  export type SellingHoursReportsMinAggregateInputType = {
    id?: true
    hoursAdded?: true
    addedAt?: true
    userId?: true
    hourPrice?: true
    soldBy?: true
    targetUserId?: true
  }

  export type SellingHoursReportsMaxAggregateInputType = {
    id?: true
    hoursAdded?: true
    addedAt?: true
    userId?: true
    hourPrice?: true
    soldBy?: true
    targetUserId?: true
  }

  export type SellingHoursReportsCountAggregateInputType = {
    id?: true
    hoursAdded?: true
    addedAt?: true
    userId?: true
    hourPrice?: true
    soldBy?: true
    targetUserId?: true
    _all?: true
  }

  export type SellingHoursReportsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellingHoursReports to aggregate.
     */
    where?: SellingHoursReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellingHoursReports to fetch.
     */
    orderBy?: SellingHoursReportsOrderByWithRelationInput | SellingHoursReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SellingHoursReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellingHoursReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellingHoursReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SellingHoursReports
    **/
    _count?: true | SellingHoursReportsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SellingHoursReportsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SellingHoursReportsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellingHoursReportsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellingHoursReportsMaxAggregateInputType
  }

  export type GetSellingHoursReportsAggregateType<T extends SellingHoursReportsAggregateArgs> = {
        [P in keyof T & keyof AggregateSellingHoursReports]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSellingHoursReports[P]>
      : GetScalarType<T[P], AggregateSellingHoursReports[P]>
  }




  export type SellingHoursReportsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellingHoursReportsWhereInput
    orderBy?: SellingHoursReportsOrderByWithAggregationInput | SellingHoursReportsOrderByWithAggregationInput[]
    by: SellingHoursReportsScalarFieldEnum[] | SellingHoursReportsScalarFieldEnum
    having?: SellingHoursReportsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellingHoursReportsCountAggregateInputType | true
    _avg?: SellingHoursReportsAvgAggregateInputType
    _sum?: SellingHoursReportsSumAggregateInputType
    _min?: SellingHoursReportsMinAggregateInputType
    _max?: SellingHoursReportsMaxAggregateInputType
  }

  export type SellingHoursReportsGroupByOutputType = {
    id: string
    hoursAdded: number
    addedAt: Date
    userId: number
    hourPrice: number
    soldBy: number | null
    targetUserId: number | null
    _count: SellingHoursReportsCountAggregateOutputType | null
    _avg: SellingHoursReportsAvgAggregateOutputType | null
    _sum: SellingHoursReportsSumAggregateOutputType | null
    _min: SellingHoursReportsMinAggregateOutputType | null
    _max: SellingHoursReportsMaxAggregateOutputType | null
  }

  type GetSellingHoursReportsGroupByPayload<T extends SellingHoursReportsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SellingHoursReportsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellingHoursReportsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellingHoursReportsGroupByOutputType[P]>
            : GetScalarType<T[P], SellingHoursReportsGroupByOutputType[P]>
        }
      >
    >


  export type SellingHoursReportsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hoursAdded?: boolean
    addedAt?: boolean
    userId?: boolean
    hourPrice?: boolean
    soldBy?: boolean
    targetUserId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    targetUser?: boolean | SellingHoursReports$targetUserArgs<ExtArgs>
  }, ExtArgs["result"]["sellingHoursReports"]>

  export type SellingHoursReportsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hoursAdded?: boolean
    addedAt?: boolean
    userId?: boolean
    hourPrice?: boolean
    soldBy?: boolean
    targetUserId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    targetUser?: boolean | SellingHoursReports$targetUserArgs<ExtArgs>
  }, ExtArgs["result"]["sellingHoursReports"]>

  export type SellingHoursReportsSelectScalar = {
    id?: boolean
    hoursAdded?: boolean
    addedAt?: boolean
    userId?: boolean
    hourPrice?: boolean
    soldBy?: boolean
    targetUserId?: boolean
  }

  export type SellingHoursReportsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    targetUser?: boolean | SellingHoursReports$targetUserArgs<ExtArgs>
  }
  export type SellingHoursReportsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    targetUser?: boolean | SellingHoursReports$targetUserArgs<ExtArgs>
  }

  export type $SellingHoursReportsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SellingHoursReports"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      targetUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hoursAdded: number
      addedAt: Date
      userId: number
      hourPrice: number
      soldBy: number | null
      targetUserId: number | null
    }, ExtArgs["result"]["sellingHoursReports"]>
    composites: {}
  }

  type SellingHoursReportsGetPayload<S extends boolean | null | undefined | SellingHoursReportsDefaultArgs> = $Result.GetResult<Prisma.$SellingHoursReportsPayload, S>

  type SellingHoursReportsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SellingHoursReportsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SellingHoursReportsCountAggregateInputType | true
    }

  export interface SellingHoursReportsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SellingHoursReports'], meta: { name: 'SellingHoursReports' } }
    /**
     * Find zero or one SellingHoursReports that matches the filter.
     * @param {SellingHoursReportsFindUniqueArgs} args - Arguments to find a SellingHoursReports
     * @example
     * // Get one SellingHoursReports
     * const sellingHoursReports = await prisma.sellingHoursReports.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SellingHoursReportsFindUniqueArgs>(args: SelectSubset<T, SellingHoursReportsFindUniqueArgs<ExtArgs>>): Prisma__SellingHoursReportsClient<$Result.GetResult<Prisma.$SellingHoursReportsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SellingHoursReports that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SellingHoursReportsFindUniqueOrThrowArgs} args - Arguments to find a SellingHoursReports
     * @example
     * // Get one SellingHoursReports
     * const sellingHoursReports = await prisma.sellingHoursReports.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SellingHoursReportsFindUniqueOrThrowArgs>(args: SelectSubset<T, SellingHoursReportsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SellingHoursReportsClient<$Result.GetResult<Prisma.$SellingHoursReportsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SellingHoursReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingHoursReportsFindFirstArgs} args - Arguments to find a SellingHoursReports
     * @example
     * // Get one SellingHoursReports
     * const sellingHoursReports = await prisma.sellingHoursReports.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SellingHoursReportsFindFirstArgs>(args?: SelectSubset<T, SellingHoursReportsFindFirstArgs<ExtArgs>>): Prisma__SellingHoursReportsClient<$Result.GetResult<Prisma.$SellingHoursReportsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SellingHoursReports that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingHoursReportsFindFirstOrThrowArgs} args - Arguments to find a SellingHoursReports
     * @example
     * // Get one SellingHoursReports
     * const sellingHoursReports = await prisma.sellingHoursReports.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SellingHoursReportsFindFirstOrThrowArgs>(args?: SelectSubset<T, SellingHoursReportsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SellingHoursReportsClient<$Result.GetResult<Prisma.$SellingHoursReportsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SellingHoursReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingHoursReportsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SellingHoursReports
     * const sellingHoursReports = await prisma.sellingHoursReports.findMany()
     * 
     * // Get first 10 SellingHoursReports
     * const sellingHoursReports = await prisma.sellingHoursReports.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sellingHoursReportsWithIdOnly = await prisma.sellingHoursReports.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SellingHoursReportsFindManyArgs>(args?: SelectSubset<T, SellingHoursReportsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellingHoursReportsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SellingHoursReports.
     * @param {SellingHoursReportsCreateArgs} args - Arguments to create a SellingHoursReports.
     * @example
     * // Create one SellingHoursReports
     * const SellingHoursReports = await prisma.sellingHoursReports.create({
     *   data: {
     *     // ... data to create a SellingHoursReports
     *   }
     * })
     * 
     */
    create<T extends SellingHoursReportsCreateArgs>(args: SelectSubset<T, SellingHoursReportsCreateArgs<ExtArgs>>): Prisma__SellingHoursReportsClient<$Result.GetResult<Prisma.$SellingHoursReportsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SellingHoursReports.
     * @param {SellingHoursReportsCreateManyArgs} args - Arguments to create many SellingHoursReports.
     * @example
     * // Create many SellingHoursReports
     * const sellingHoursReports = await prisma.sellingHoursReports.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SellingHoursReportsCreateManyArgs>(args?: SelectSubset<T, SellingHoursReportsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SellingHoursReports and returns the data saved in the database.
     * @param {SellingHoursReportsCreateManyAndReturnArgs} args - Arguments to create many SellingHoursReports.
     * @example
     * // Create many SellingHoursReports
     * const sellingHoursReports = await prisma.sellingHoursReports.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SellingHoursReports and only return the `id`
     * const sellingHoursReportsWithIdOnly = await prisma.sellingHoursReports.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SellingHoursReportsCreateManyAndReturnArgs>(args?: SelectSubset<T, SellingHoursReportsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellingHoursReportsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SellingHoursReports.
     * @param {SellingHoursReportsDeleteArgs} args - Arguments to delete one SellingHoursReports.
     * @example
     * // Delete one SellingHoursReports
     * const SellingHoursReports = await prisma.sellingHoursReports.delete({
     *   where: {
     *     // ... filter to delete one SellingHoursReports
     *   }
     * })
     * 
     */
    delete<T extends SellingHoursReportsDeleteArgs>(args: SelectSubset<T, SellingHoursReportsDeleteArgs<ExtArgs>>): Prisma__SellingHoursReportsClient<$Result.GetResult<Prisma.$SellingHoursReportsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SellingHoursReports.
     * @param {SellingHoursReportsUpdateArgs} args - Arguments to update one SellingHoursReports.
     * @example
     * // Update one SellingHoursReports
     * const sellingHoursReports = await prisma.sellingHoursReports.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SellingHoursReportsUpdateArgs>(args: SelectSubset<T, SellingHoursReportsUpdateArgs<ExtArgs>>): Prisma__SellingHoursReportsClient<$Result.GetResult<Prisma.$SellingHoursReportsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SellingHoursReports.
     * @param {SellingHoursReportsDeleteManyArgs} args - Arguments to filter SellingHoursReports to delete.
     * @example
     * // Delete a few SellingHoursReports
     * const { count } = await prisma.sellingHoursReports.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SellingHoursReportsDeleteManyArgs>(args?: SelectSubset<T, SellingHoursReportsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellingHoursReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingHoursReportsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SellingHoursReports
     * const sellingHoursReports = await prisma.sellingHoursReports.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SellingHoursReportsUpdateManyArgs>(args: SelectSubset<T, SellingHoursReportsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SellingHoursReports.
     * @param {SellingHoursReportsUpsertArgs} args - Arguments to update or create a SellingHoursReports.
     * @example
     * // Update or create a SellingHoursReports
     * const sellingHoursReports = await prisma.sellingHoursReports.upsert({
     *   create: {
     *     // ... data to create a SellingHoursReports
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SellingHoursReports we want to update
     *   }
     * })
     */
    upsert<T extends SellingHoursReportsUpsertArgs>(args: SelectSubset<T, SellingHoursReportsUpsertArgs<ExtArgs>>): Prisma__SellingHoursReportsClient<$Result.GetResult<Prisma.$SellingHoursReportsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SellingHoursReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingHoursReportsCountArgs} args - Arguments to filter SellingHoursReports to count.
     * @example
     * // Count the number of SellingHoursReports
     * const count = await prisma.sellingHoursReports.count({
     *   where: {
     *     // ... the filter for the SellingHoursReports we want to count
     *   }
     * })
    **/
    count<T extends SellingHoursReportsCountArgs>(
      args?: Subset<T, SellingHoursReportsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellingHoursReportsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SellingHoursReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingHoursReportsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellingHoursReportsAggregateArgs>(args: Subset<T, SellingHoursReportsAggregateArgs>): Prisma.PrismaPromise<GetSellingHoursReportsAggregateType<T>>

    /**
     * Group by SellingHoursReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingHoursReportsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellingHoursReportsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellingHoursReportsGroupByArgs['orderBy'] }
        : { orderBy?: SellingHoursReportsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellingHoursReportsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellingHoursReportsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SellingHoursReports model
   */
  readonly fields: SellingHoursReportsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SellingHoursReports.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SellingHoursReportsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    targetUser<T extends SellingHoursReports$targetUserArgs<ExtArgs> = {}>(args?: Subset<T, SellingHoursReports$targetUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SellingHoursReports model
   */ 
  interface SellingHoursReportsFieldRefs {
    readonly id: FieldRef<"SellingHoursReports", 'String'>
    readonly hoursAdded: FieldRef<"SellingHoursReports", 'Int'>
    readonly addedAt: FieldRef<"SellingHoursReports", 'DateTime'>
    readonly userId: FieldRef<"SellingHoursReports", 'Int'>
    readonly hourPrice: FieldRef<"SellingHoursReports", 'Float'>
    readonly soldBy: FieldRef<"SellingHoursReports", 'Int'>
    readonly targetUserId: FieldRef<"SellingHoursReports", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SellingHoursReports findUnique
   */
  export type SellingHoursReportsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHoursReports
     */
    select?: SellingHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellingHoursReportsInclude<ExtArgs> | null
    /**
     * Filter, which SellingHoursReports to fetch.
     */
    where: SellingHoursReportsWhereUniqueInput
  }

  /**
   * SellingHoursReports findUniqueOrThrow
   */
  export type SellingHoursReportsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHoursReports
     */
    select?: SellingHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellingHoursReportsInclude<ExtArgs> | null
    /**
     * Filter, which SellingHoursReports to fetch.
     */
    where: SellingHoursReportsWhereUniqueInput
  }

  /**
   * SellingHoursReports findFirst
   */
  export type SellingHoursReportsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHoursReports
     */
    select?: SellingHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellingHoursReportsInclude<ExtArgs> | null
    /**
     * Filter, which SellingHoursReports to fetch.
     */
    where?: SellingHoursReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellingHoursReports to fetch.
     */
    orderBy?: SellingHoursReportsOrderByWithRelationInput | SellingHoursReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellingHoursReports.
     */
    cursor?: SellingHoursReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellingHoursReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellingHoursReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellingHoursReports.
     */
    distinct?: SellingHoursReportsScalarFieldEnum | SellingHoursReportsScalarFieldEnum[]
  }

  /**
   * SellingHoursReports findFirstOrThrow
   */
  export type SellingHoursReportsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHoursReports
     */
    select?: SellingHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellingHoursReportsInclude<ExtArgs> | null
    /**
     * Filter, which SellingHoursReports to fetch.
     */
    where?: SellingHoursReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellingHoursReports to fetch.
     */
    orderBy?: SellingHoursReportsOrderByWithRelationInput | SellingHoursReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellingHoursReports.
     */
    cursor?: SellingHoursReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellingHoursReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellingHoursReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellingHoursReports.
     */
    distinct?: SellingHoursReportsScalarFieldEnum | SellingHoursReportsScalarFieldEnum[]
  }

  /**
   * SellingHoursReports findMany
   */
  export type SellingHoursReportsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHoursReports
     */
    select?: SellingHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellingHoursReportsInclude<ExtArgs> | null
    /**
     * Filter, which SellingHoursReports to fetch.
     */
    where?: SellingHoursReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellingHoursReports to fetch.
     */
    orderBy?: SellingHoursReportsOrderByWithRelationInput | SellingHoursReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SellingHoursReports.
     */
    cursor?: SellingHoursReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellingHoursReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellingHoursReports.
     */
    skip?: number
    distinct?: SellingHoursReportsScalarFieldEnum | SellingHoursReportsScalarFieldEnum[]
  }

  /**
   * SellingHoursReports create
   */
  export type SellingHoursReportsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHoursReports
     */
    select?: SellingHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellingHoursReportsInclude<ExtArgs> | null
    /**
     * The data needed to create a SellingHoursReports.
     */
    data: XOR<SellingHoursReportsCreateInput, SellingHoursReportsUncheckedCreateInput>
  }

  /**
   * SellingHoursReports createMany
   */
  export type SellingHoursReportsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SellingHoursReports.
     */
    data: SellingHoursReportsCreateManyInput | SellingHoursReportsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SellingHoursReports createManyAndReturn
   */
  export type SellingHoursReportsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHoursReports
     */
    select?: SellingHoursReportsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SellingHoursReports.
     */
    data: SellingHoursReportsCreateManyInput | SellingHoursReportsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellingHoursReportsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SellingHoursReports update
   */
  export type SellingHoursReportsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHoursReports
     */
    select?: SellingHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellingHoursReportsInclude<ExtArgs> | null
    /**
     * The data needed to update a SellingHoursReports.
     */
    data: XOR<SellingHoursReportsUpdateInput, SellingHoursReportsUncheckedUpdateInput>
    /**
     * Choose, which SellingHoursReports to update.
     */
    where: SellingHoursReportsWhereUniqueInput
  }

  /**
   * SellingHoursReports updateMany
   */
  export type SellingHoursReportsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SellingHoursReports.
     */
    data: XOR<SellingHoursReportsUpdateManyMutationInput, SellingHoursReportsUncheckedUpdateManyInput>
    /**
     * Filter which SellingHoursReports to update
     */
    where?: SellingHoursReportsWhereInput
  }

  /**
   * SellingHoursReports upsert
   */
  export type SellingHoursReportsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHoursReports
     */
    select?: SellingHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellingHoursReportsInclude<ExtArgs> | null
    /**
     * The filter to search for the SellingHoursReports to update in case it exists.
     */
    where: SellingHoursReportsWhereUniqueInput
    /**
     * In case the SellingHoursReports found by the `where` argument doesn't exist, create a new SellingHoursReports with this data.
     */
    create: XOR<SellingHoursReportsCreateInput, SellingHoursReportsUncheckedCreateInput>
    /**
     * In case the SellingHoursReports was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SellingHoursReportsUpdateInput, SellingHoursReportsUncheckedUpdateInput>
  }

  /**
   * SellingHoursReports delete
   */
  export type SellingHoursReportsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHoursReports
     */
    select?: SellingHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellingHoursReportsInclude<ExtArgs> | null
    /**
     * Filter which SellingHoursReports to delete.
     */
    where: SellingHoursReportsWhereUniqueInput
  }

  /**
   * SellingHoursReports deleteMany
   */
  export type SellingHoursReportsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellingHoursReports to delete
     */
    where?: SellingHoursReportsWhereInput
  }

  /**
   * SellingHoursReports.targetUser
   */
  export type SellingHoursReports$targetUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SellingHoursReports without action
   */
  export type SellingHoursReportsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHoursReports
     */
    select?: SellingHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellingHoursReportsInclude<ExtArgs> | null
  }


  /**
   * Model UserHoursReports
   */

  export type AggregateUserHoursReports = {
    _count: UserHoursReportsCountAggregateOutputType | null
    _avg: UserHoursReportsAvgAggregateOutputType | null
    _sum: UserHoursReportsSumAggregateOutputType | null
    _min: UserHoursReportsMinAggregateOutputType | null
    _max: UserHoursReportsMaxAggregateOutputType | null
  }

  export type UserHoursReportsAvgAggregateOutputType = {
    userId: number | null
    hoursBought: number | null
    hourPrice: number | null
    soldBy: number | null
  }

  export type UserHoursReportsSumAggregateOutputType = {
    userId: number | null
    hoursBought: number | null
    hourPrice: number | null
    soldBy: number | null
  }

  export type UserHoursReportsMinAggregateOutputType = {
    id: string | null
    userId: number | null
    hoursBought: number | null
    boughtAt: Date | null
    hourPrice: number | null
    soldBy: number | null
  }

  export type UserHoursReportsMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    hoursBought: number | null
    boughtAt: Date | null
    hourPrice: number | null
    soldBy: number | null
  }

  export type UserHoursReportsCountAggregateOutputType = {
    id: number
    userId: number
    hoursBought: number
    boughtAt: number
    hourPrice: number
    soldBy: number
    _all: number
  }


  export type UserHoursReportsAvgAggregateInputType = {
    userId?: true
    hoursBought?: true
    hourPrice?: true
    soldBy?: true
  }

  export type UserHoursReportsSumAggregateInputType = {
    userId?: true
    hoursBought?: true
    hourPrice?: true
    soldBy?: true
  }

  export type UserHoursReportsMinAggregateInputType = {
    id?: true
    userId?: true
    hoursBought?: true
    boughtAt?: true
    hourPrice?: true
    soldBy?: true
  }

  export type UserHoursReportsMaxAggregateInputType = {
    id?: true
    userId?: true
    hoursBought?: true
    boughtAt?: true
    hourPrice?: true
    soldBy?: true
  }

  export type UserHoursReportsCountAggregateInputType = {
    id?: true
    userId?: true
    hoursBought?: true
    boughtAt?: true
    hourPrice?: true
    soldBy?: true
    _all?: true
  }

  export type UserHoursReportsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserHoursReports to aggregate.
     */
    where?: UserHoursReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserHoursReports to fetch.
     */
    orderBy?: UserHoursReportsOrderByWithRelationInput | UserHoursReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserHoursReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserHoursReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserHoursReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserHoursReports
    **/
    _count?: true | UserHoursReportsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserHoursReportsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserHoursReportsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserHoursReportsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserHoursReportsMaxAggregateInputType
  }

  export type GetUserHoursReportsAggregateType<T extends UserHoursReportsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserHoursReports]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserHoursReports[P]>
      : GetScalarType<T[P], AggregateUserHoursReports[P]>
  }




  export type UserHoursReportsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserHoursReportsWhereInput
    orderBy?: UserHoursReportsOrderByWithAggregationInput | UserHoursReportsOrderByWithAggregationInput[]
    by: UserHoursReportsScalarFieldEnum[] | UserHoursReportsScalarFieldEnum
    having?: UserHoursReportsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserHoursReportsCountAggregateInputType | true
    _avg?: UserHoursReportsAvgAggregateInputType
    _sum?: UserHoursReportsSumAggregateInputType
    _min?: UserHoursReportsMinAggregateInputType
    _max?: UserHoursReportsMaxAggregateInputType
  }

  export type UserHoursReportsGroupByOutputType = {
    id: string
    userId: number
    hoursBought: number
    boughtAt: Date
    hourPrice: number
    soldBy: number
    _count: UserHoursReportsCountAggregateOutputType | null
    _avg: UserHoursReportsAvgAggregateOutputType | null
    _sum: UserHoursReportsSumAggregateOutputType | null
    _min: UserHoursReportsMinAggregateOutputType | null
    _max: UserHoursReportsMaxAggregateOutputType | null
  }

  type GetUserHoursReportsGroupByPayload<T extends UserHoursReportsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserHoursReportsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserHoursReportsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserHoursReportsGroupByOutputType[P]>
            : GetScalarType<T[P], UserHoursReportsGroupByOutputType[P]>
        }
      >
    >


  export type UserHoursReportsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    hoursBought?: boolean
    boughtAt?: boolean
    hourPrice?: boolean
    soldBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userHoursReports"]>

  export type UserHoursReportsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    hoursBought?: boolean
    boughtAt?: boolean
    hourPrice?: boolean
    soldBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userHoursReports"]>

  export type UserHoursReportsSelectScalar = {
    id?: boolean
    userId?: boolean
    hoursBought?: boolean
    boughtAt?: boolean
    hourPrice?: boolean
    soldBy?: boolean
  }

  export type UserHoursReportsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserHoursReportsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserHoursReportsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserHoursReports"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number
      hoursBought: number
      boughtAt: Date
      hourPrice: number
      soldBy: number
    }, ExtArgs["result"]["userHoursReports"]>
    composites: {}
  }

  type UserHoursReportsGetPayload<S extends boolean | null | undefined | UserHoursReportsDefaultArgs> = $Result.GetResult<Prisma.$UserHoursReportsPayload, S>

  type UserHoursReportsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserHoursReportsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserHoursReportsCountAggregateInputType | true
    }

  export interface UserHoursReportsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserHoursReports'], meta: { name: 'UserHoursReports' } }
    /**
     * Find zero or one UserHoursReports that matches the filter.
     * @param {UserHoursReportsFindUniqueArgs} args - Arguments to find a UserHoursReports
     * @example
     * // Get one UserHoursReports
     * const userHoursReports = await prisma.userHoursReports.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserHoursReportsFindUniqueArgs>(args: SelectSubset<T, UserHoursReportsFindUniqueArgs<ExtArgs>>): Prisma__UserHoursReportsClient<$Result.GetResult<Prisma.$UserHoursReportsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserHoursReports that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserHoursReportsFindUniqueOrThrowArgs} args - Arguments to find a UserHoursReports
     * @example
     * // Get one UserHoursReports
     * const userHoursReports = await prisma.userHoursReports.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserHoursReportsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserHoursReportsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserHoursReportsClient<$Result.GetResult<Prisma.$UserHoursReportsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserHoursReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserHoursReportsFindFirstArgs} args - Arguments to find a UserHoursReports
     * @example
     * // Get one UserHoursReports
     * const userHoursReports = await prisma.userHoursReports.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserHoursReportsFindFirstArgs>(args?: SelectSubset<T, UserHoursReportsFindFirstArgs<ExtArgs>>): Prisma__UserHoursReportsClient<$Result.GetResult<Prisma.$UserHoursReportsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserHoursReports that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserHoursReportsFindFirstOrThrowArgs} args - Arguments to find a UserHoursReports
     * @example
     * // Get one UserHoursReports
     * const userHoursReports = await prisma.userHoursReports.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserHoursReportsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserHoursReportsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserHoursReportsClient<$Result.GetResult<Prisma.$UserHoursReportsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserHoursReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserHoursReportsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserHoursReports
     * const userHoursReports = await prisma.userHoursReports.findMany()
     * 
     * // Get first 10 UserHoursReports
     * const userHoursReports = await prisma.userHoursReports.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userHoursReportsWithIdOnly = await prisma.userHoursReports.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserHoursReportsFindManyArgs>(args?: SelectSubset<T, UserHoursReportsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserHoursReportsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserHoursReports.
     * @param {UserHoursReportsCreateArgs} args - Arguments to create a UserHoursReports.
     * @example
     * // Create one UserHoursReports
     * const UserHoursReports = await prisma.userHoursReports.create({
     *   data: {
     *     // ... data to create a UserHoursReports
     *   }
     * })
     * 
     */
    create<T extends UserHoursReportsCreateArgs>(args: SelectSubset<T, UserHoursReportsCreateArgs<ExtArgs>>): Prisma__UserHoursReportsClient<$Result.GetResult<Prisma.$UserHoursReportsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserHoursReports.
     * @param {UserHoursReportsCreateManyArgs} args - Arguments to create many UserHoursReports.
     * @example
     * // Create many UserHoursReports
     * const userHoursReports = await prisma.userHoursReports.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserHoursReportsCreateManyArgs>(args?: SelectSubset<T, UserHoursReportsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserHoursReports and returns the data saved in the database.
     * @param {UserHoursReportsCreateManyAndReturnArgs} args - Arguments to create many UserHoursReports.
     * @example
     * // Create many UserHoursReports
     * const userHoursReports = await prisma.userHoursReports.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserHoursReports and only return the `id`
     * const userHoursReportsWithIdOnly = await prisma.userHoursReports.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserHoursReportsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserHoursReportsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserHoursReportsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserHoursReports.
     * @param {UserHoursReportsDeleteArgs} args - Arguments to delete one UserHoursReports.
     * @example
     * // Delete one UserHoursReports
     * const UserHoursReports = await prisma.userHoursReports.delete({
     *   where: {
     *     // ... filter to delete one UserHoursReports
     *   }
     * })
     * 
     */
    delete<T extends UserHoursReportsDeleteArgs>(args: SelectSubset<T, UserHoursReportsDeleteArgs<ExtArgs>>): Prisma__UserHoursReportsClient<$Result.GetResult<Prisma.$UserHoursReportsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserHoursReports.
     * @param {UserHoursReportsUpdateArgs} args - Arguments to update one UserHoursReports.
     * @example
     * // Update one UserHoursReports
     * const userHoursReports = await prisma.userHoursReports.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserHoursReportsUpdateArgs>(args: SelectSubset<T, UserHoursReportsUpdateArgs<ExtArgs>>): Prisma__UserHoursReportsClient<$Result.GetResult<Prisma.$UserHoursReportsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserHoursReports.
     * @param {UserHoursReportsDeleteManyArgs} args - Arguments to filter UserHoursReports to delete.
     * @example
     * // Delete a few UserHoursReports
     * const { count } = await prisma.userHoursReports.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserHoursReportsDeleteManyArgs>(args?: SelectSubset<T, UserHoursReportsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserHoursReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserHoursReportsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserHoursReports
     * const userHoursReports = await prisma.userHoursReports.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserHoursReportsUpdateManyArgs>(args: SelectSubset<T, UserHoursReportsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserHoursReports.
     * @param {UserHoursReportsUpsertArgs} args - Arguments to update or create a UserHoursReports.
     * @example
     * // Update or create a UserHoursReports
     * const userHoursReports = await prisma.userHoursReports.upsert({
     *   create: {
     *     // ... data to create a UserHoursReports
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserHoursReports we want to update
     *   }
     * })
     */
    upsert<T extends UserHoursReportsUpsertArgs>(args: SelectSubset<T, UserHoursReportsUpsertArgs<ExtArgs>>): Prisma__UserHoursReportsClient<$Result.GetResult<Prisma.$UserHoursReportsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserHoursReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserHoursReportsCountArgs} args - Arguments to filter UserHoursReports to count.
     * @example
     * // Count the number of UserHoursReports
     * const count = await prisma.userHoursReports.count({
     *   where: {
     *     // ... the filter for the UserHoursReports we want to count
     *   }
     * })
    **/
    count<T extends UserHoursReportsCountArgs>(
      args?: Subset<T, UserHoursReportsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserHoursReportsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserHoursReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserHoursReportsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserHoursReportsAggregateArgs>(args: Subset<T, UserHoursReportsAggregateArgs>): Prisma.PrismaPromise<GetUserHoursReportsAggregateType<T>>

    /**
     * Group by UserHoursReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserHoursReportsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserHoursReportsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserHoursReportsGroupByArgs['orderBy'] }
        : { orderBy?: UserHoursReportsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserHoursReportsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserHoursReportsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserHoursReports model
   */
  readonly fields: UserHoursReportsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserHoursReports.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserHoursReportsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserHoursReports model
   */ 
  interface UserHoursReportsFieldRefs {
    readonly id: FieldRef<"UserHoursReports", 'String'>
    readonly userId: FieldRef<"UserHoursReports", 'Int'>
    readonly hoursBought: FieldRef<"UserHoursReports", 'Int'>
    readonly boughtAt: FieldRef<"UserHoursReports", 'DateTime'>
    readonly hourPrice: FieldRef<"UserHoursReports", 'Float'>
    readonly soldBy: FieldRef<"UserHoursReports", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserHoursReports findUnique
   */
  export type UserHoursReportsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserHoursReports
     */
    select?: UserHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserHoursReportsInclude<ExtArgs> | null
    /**
     * Filter, which UserHoursReports to fetch.
     */
    where: UserHoursReportsWhereUniqueInput
  }

  /**
   * UserHoursReports findUniqueOrThrow
   */
  export type UserHoursReportsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserHoursReports
     */
    select?: UserHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserHoursReportsInclude<ExtArgs> | null
    /**
     * Filter, which UserHoursReports to fetch.
     */
    where: UserHoursReportsWhereUniqueInput
  }

  /**
   * UserHoursReports findFirst
   */
  export type UserHoursReportsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserHoursReports
     */
    select?: UserHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserHoursReportsInclude<ExtArgs> | null
    /**
     * Filter, which UserHoursReports to fetch.
     */
    where?: UserHoursReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserHoursReports to fetch.
     */
    orderBy?: UserHoursReportsOrderByWithRelationInput | UserHoursReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserHoursReports.
     */
    cursor?: UserHoursReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserHoursReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserHoursReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserHoursReports.
     */
    distinct?: UserHoursReportsScalarFieldEnum | UserHoursReportsScalarFieldEnum[]
  }

  /**
   * UserHoursReports findFirstOrThrow
   */
  export type UserHoursReportsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserHoursReports
     */
    select?: UserHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserHoursReportsInclude<ExtArgs> | null
    /**
     * Filter, which UserHoursReports to fetch.
     */
    where?: UserHoursReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserHoursReports to fetch.
     */
    orderBy?: UserHoursReportsOrderByWithRelationInput | UserHoursReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserHoursReports.
     */
    cursor?: UserHoursReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserHoursReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserHoursReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserHoursReports.
     */
    distinct?: UserHoursReportsScalarFieldEnum | UserHoursReportsScalarFieldEnum[]
  }

  /**
   * UserHoursReports findMany
   */
  export type UserHoursReportsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserHoursReports
     */
    select?: UserHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserHoursReportsInclude<ExtArgs> | null
    /**
     * Filter, which UserHoursReports to fetch.
     */
    where?: UserHoursReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserHoursReports to fetch.
     */
    orderBy?: UserHoursReportsOrderByWithRelationInput | UserHoursReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserHoursReports.
     */
    cursor?: UserHoursReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserHoursReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserHoursReports.
     */
    skip?: number
    distinct?: UserHoursReportsScalarFieldEnum | UserHoursReportsScalarFieldEnum[]
  }

  /**
   * UserHoursReports create
   */
  export type UserHoursReportsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserHoursReports
     */
    select?: UserHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserHoursReportsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserHoursReports.
     */
    data: XOR<UserHoursReportsCreateInput, UserHoursReportsUncheckedCreateInput>
  }

  /**
   * UserHoursReports createMany
   */
  export type UserHoursReportsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserHoursReports.
     */
    data: UserHoursReportsCreateManyInput | UserHoursReportsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserHoursReports createManyAndReturn
   */
  export type UserHoursReportsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserHoursReports
     */
    select?: UserHoursReportsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserHoursReports.
     */
    data: UserHoursReportsCreateManyInput | UserHoursReportsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserHoursReportsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserHoursReports update
   */
  export type UserHoursReportsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserHoursReports
     */
    select?: UserHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserHoursReportsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserHoursReports.
     */
    data: XOR<UserHoursReportsUpdateInput, UserHoursReportsUncheckedUpdateInput>
    /**
     * Choose, which UserHoursReports to update.
     */
    where: UserHoursReportsWhereUniqueInput
  }

  /**
   * UserHoursReports updateMany
   */
  export type UserHoursReportsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserHoursReports.
     */
    data: XOR<UserHoursReportsUpdateManyMutationInput, UserHoursReportsUncheckedUpdateManyInput>
    /**
     * Filter which UserHoursReports to update
     */
    where?: UserHoursReportsWhereInput
  }

  /**
   * UserHoursReports upsert
   */
  export type UserHoursReportsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserHoursReports
     */
    select?: UserHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserHoursReportsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserHoursReports to update in case it exists.
     */
    where: UserHoursReportsWhereUniqueInput
    /**
     * In case the UserHoursReports found by the `where` argument doesn't exist, create a new UserHoursReports with this data.
     */
    create: XOR<UserHoursReportsCreateInput, UserHoursReportsUncheckedCreateInput>
    /**
     * In case the UserHoursReports was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserHoursReportsUpdateInput, UserHoursReportsUncheckedUpdateInput>
  }

  /**
   * UserHoursReports delete
   */
  export type UserHoursReportsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserHoursReports
     */
    select?: UserHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserHoursReportsInclude<ExtArgs> | null
    /**
     * Filter which UserHoursReports to delete.
     */
    where: UserHoursReportsWhereUniqueInput
  }

  /**
   * UserHoursReports deleteMany
   */
  export type UserHoursReportsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserHoursReports to delete
     */
    where?: UserHoursReportsWhereInput
  }

  /**
   * UserHoursReports without action
   */
  export type UserHoursReportsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserHoursReports
     */
    select?: UserHoursReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserHoursReportsInclude<ExtArgs> | null
  }


  /**
   * Model UserParkingReports
   */

  export type AggregateUserParkingReports = {
    _count: UserParkingReportsCountAggregateOutputType | null
    _avg: UserParkingReportsAvgAggregateOutputType | null
    _sum: UserParkingReportsSumAggregateOutputType | null
    _min: UserParkingReportsMinAggregateOutputType | null
    _max: UserParkingReportsMaxAggregateOutputType | null
  }

  export type UserParkingReportsAvgAggregateOutputType = {
    userId: number | null
    totalHours: number | null
    hourPrice: number | null
  }

  export type UserParkingReportsSumAggregateOutputType = {
    userId: number | null
    totalHours: number | null
    hourPrice: number | null
  }

  export type UserParkingReportsMinAggregateOutputType = {
    id: string | null
    userId: number | null
    startedAt: Date | null
    finishedAt: Date | null
    patentId: string | null
    totalHours: number | null
    hourPrice: number | null
  }

  export type UserParkingReportsMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    startedAt: Date | null
    finishedAt: Date | null
    patentId: string | null
    totalHours: number | null
    hourPrice: number | null
  }

  export type UserParkingReportsCountAggregateOutputType = {
    id: number
    userId: number
    startedAt: number
    finishedAt: number
    patentId: number
    totalHours: number
    hourPrice: number
    _all: number
  }


  export type UserParkingReportsAvgAggregateInputType = {
    userId?: true
    totalHours?: true
    hourPrice?: true
  }

  export type UserParkingReportsSumAggregateInputType = {
    userId?: true
    totalHours?: true
    hourPrice?: true
  }

  export type UserParkingReportsMinAggregateInputType = {
    id?: true
    userId?: true
    startedAt?: true
    finishedAt?: true
    patentId?: true
    totalHours?: true
    hourPrice?: true
  }

  export type UserParkingReportsMaxAggregateInputType = {
    id?: true
    userId?: true
    startedAt?: true
    finishedAt?: true
    patentId?: true
    totalHours?: true
    hourPrice?: true
  }

  export type UserParkingReportsCountAggregateInputType = {
    id?: true
    userId?: true
    startedAt?: true
    finishedAt?: true
    patentId?: true
    totalHours?: true
    hourPrice?: true
    _all?: true
  }

  export type UserParkingReportsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserParkingReports to aggregate.
     */
    where?: UserParkingReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserParkingReports to fetch.
     */
    orderBy?: UserParkingReportsOrderByWithRelationInput | UserParkingReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserParkingReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserParkingReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserParkingReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserParkingReports
    **/
    _count?: true | UserParkingReportsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserParkingReportsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserParkingReportsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserParkingReportsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserParkingReportsMaxAggregateInputType
  }

  export type GetUserParkingReportsAggregateType<T extends UserParkingReportsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserParkingReports]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserParkingReports[P]>
      : GetScalarType<T[P], AggregateUserParkingReports[P]>
  }




  export type UserParkingReportsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserParkingReportsWhereInput
    orderBy?: UserParkingReportsOrderByWithAggregationInput | UserParkingReportsOrderByWithAggregationInput[]
    by: UserParkingReportsScalarFieldEnum[] | UserParkingReportsScalarFieldEnum
    having?: UserParkingReportsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserParkingReportsCountAggregateInputType | true
    _avg?: UserParkingReportsAvgAggregateInputType
    _sum?: UserParkingReportsSumAggregateInputType
    _min?: UserParkingReportsMinAggregateInputType
    _max?: UserParkingReportsMaxAggregateInputType
  }

  export type UserParkingReportsGroupByOutputType = {
    id: string
    userId: number
    startedAt: Date
    finishedAt: Date
    patentId: string
    totalHours: number
    hourPrice: number
    _count: UserParkingReportsCountAggregateOutputType | null
    _avg: UserParkingReportsAvgAggregateOutputType | null
    _sum: UserParkingReportsSumAggregateOutputType | null
    _min: UserParkingReportsMinAggregateOutputType | null
    _max: UserParkingReportsMaxAggregateOutputType | null
  }

  type GetUserParkingReportsGroupByPayload<T extends UserParkingReportsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserParkingReportsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserParkingReportsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserParkingReportsGroupByOutputType[P]>
            : GetScalarType<T[P], UserParkingReportsGroupByOutputType[P]>
        }
      >
    >


  export type UserParkingReportsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    patentId?: boolean
    totalHours?: boolean
    hourPrice?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userParkingReports"]>

  export type UserParkingReportsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    patentId?: boolean
    totalHours?: boolean
    hourPrice?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userParkingReports"]>

  export type UserParkingReportsSelectScalar = {
    id?: boolean
    userId?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    patentId?: boolean
    totalHours?: boolean
    hourPrice?: boolean
  }

  export type UserParkingReportsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserParkingReportsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserParkingReportsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserParkingReports"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number
      startedAt: Date
      finishedAt: Date
      patentId: string
      totalHours: number
      hourPrice: number
    }, ExtArgs["result"]["userParkingReports"]>
    composites: {}
  }

  type UserParkingReportsGetPayload<S extends boolean | null | undefined | UserParkingReportsDefaultArgs> = $Result.GetResult<Prisma.$UserParkingReportsPayload, S>

  type UserParkingReportsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserParkingReportsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserParkingReportsCountAggregateInputType | true
    }

  export interface UserParkingReportsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserParkingReports'], meta: { name: 'UserParkingReports' } }
    /**
     * Find zero or one UserParkingReports that matches the filter.
     * @param {UserParkingReportsFindUniqueArgs} args - Arguments to find a UserParkingReports
     * @example
     * // Get one UserParkingReports
     * const userParkingReports = await prisma.userParkingReports.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserParkingReportsFindUniqueArgs>(args: SelectSubset<T, UserParkingReportsFindUniqueArgs<ExtArgs>>): Prisma__UserParkingReportsClient<$Result.GetResult<Prisma.$UserParkingReportsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserParkingReports that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserParkingReportsFindUniqueOrThrowArgs} args - Arguments to find a UserParkingReports
     * @example
     * // Get one UserParkingReports
     * const userParkingReports = await prisma.userParkingReports.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserParkingReportsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserParkingReportsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserParkingReportsClient<$Result.GetResult<Prisma.$UserParkingReportsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserParkingReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserParkingReportsFindFirstArgs} args - Arguments to find a UserParkingReports
     * @example
     * // Get one UserParkingReports
     * const userParkingReports = await prisma.userParkingReports.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserParkingReportsFindFirstArgs>(args?: SelectSubset<T, UserParkingReportsFindFirstArgs<ExtArgs>>): Prisma__UserParkingReportsClient<$Result.GetResult<Prisma.$UserParkingReportsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserParkingReports that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserParkingReportsFindFirstOrThrowArgs} args - Arguments to find a UserParkingReports
     * @example
     * // Get one UserParkingReports
     * const userParkingReports = await prisma.userParkingReports.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserParkingReportsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserParkingReportsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserParkingReportsClient<$Result.GetResult<Prisma.$UserParkingReportsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserParkingReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserParkingReportsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserParkingReports
     * const userParkingReports = await prisma.userParkingReports.findMany()
     * 
     * // Get first 10 UserParkingReports
     * const userParkingReports = await prisma.userParkingReports.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userParkingReportsWithIdOnly = await prisma.userParkingReports.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserParkingReportsFindManyArgs>(args?: SelectSubset<T, UserParkingReportsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserParkingReportsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserParkingReports.
     * @param {UserParkingReportsCreateArgs} args - Arguments to create a UserParkingReports.
     * @example
     * // Create one UserParkingReports
     * const UserParkingReports = await prisma.userParkingReports.create({
     *   data: {
     *     // ... data to create a UserParkingReports
     *   }
     * })
     * 
     */
    create<T extends UserParkingReportsCreateArgs>(args: SelectSubset<T, UserParkingReportsCreateArgs<ExtArgs>>): Prisma__UserParkingReportsClient<$Result.GetResult<Prisma.$UserParkingReportsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserParkingReports.
     * @param {UserParkingReportsCreateManyArgs} args - Arguments to create many UserParkingReports.
     * @example
     * // Create many UserParkingReports
     * const userParkingReports = await prisma.userParkingReports.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserParkingReportsCreateManyArgs>(args?: SelectSubset<T, UserParkingReportsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserParkingReports and returns the data saved in the database.
     * @param {UserParkingReportsCreateManyAndReturnArgs} args - Arguments to create many UserParkingReports.
     * @example
     * // Create many UserParkingReports
     * const userParkingReports = await prisma.userParkingReports.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserParkingReports and only return the `id`
     * const userParkingReportsWithIdOnly = await prisma.userParkingReports.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserParkingReportsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserParkingReportsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserParkingReportsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserParkingReports.
     * @param {UserParkingReportsDeleteArgs} args - Arguments to delete one UserParkingReports.
     * @example
     * // Delete one UserParkingReports
     * const UserParkingReports = await prisma.userParkingReports.delete({
     *   where: {
     *     // ... filter to delete one UserParkingReports
     *   }
     * })
     * 
     */
    delete<T extends UserParkingReportsDeleteArgs>(args: SelectSubset<T, UserParkingReportsDeleteArgs<ExtArgs>>): Prisma__UserParkingReportsClient<$Result.GetResult<Prisma.$UserParkingReportsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserParkingReports.
     * @param {UserParkingReportsUpdateArgs} args - Arguments to update one UserParkingReports.
     * @example
     * // Update one UserParkingReports
     * const userParkingReports = await prisma.userParkingReports.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserParkingReportsUpdateArgs>(args: SelectSubset<T, UserParkingReportsUpdateArgs<ExtArgs>>): Prisma__UserParkingReportsClient<$Result.GetResult<Prisma.$UserParkingReportsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserParkingReports.
     * @param {UserParkingReportsDeleteManyArgs} args - Arguments to filter UserParkingReports to delete.
     * @example
     * // Delete a few UserParkingReports
     * const { count } = await prisma.userParkingReports.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserParkingReportsDeleteManyArgs>(args?: SelectSubset<T, UserParkingReportsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserParkingReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserParkingReportsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserParkingReports
     * const userParkingReports = await prisma.userParkingReports.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserParkingReportsUpdateManyArgs>(args: SelectSubset<T, UserParkingReportsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserParkingReports.
     * @param {UserParkingReportsUpsertArgs} args - Arguments to update or create a UserParkingReports.
     * @example
     * // Update or create a UserParkingReports
     * const userParkingReports = await prisma.userParkingReports.upsert({
     *   create: {
     *     // ... data to create a UserParkingReports
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserParkingReports we want to update
     *   }
     * })
     */
    upsert<T extends UserParkingReportsUpsertArgs>(args: SelectSubset<T, UserParkingReportsUpsertArgs<ExtArgs>>): Prisma__UserParkingReportsClient<$Result.GetResult<Prisma.$UserParkingReportsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserParkingReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserParkingReportsCountArgs} args - Arguments to filter UserParkingReports to count.
     * @example
     * // Count the number of UserParkingReports
     * const count = await prisma.userParkingReports.count({
     *   where: {
     *     // ... the filter for the UserParkingReports we want to count
     *   }
     * })
    **/
    count<T extends UserParkingReportsCountArgs>(
      args?: Subset<T, UserParkingReportsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserParkingReportsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserParkingReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserParkingReportsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserParkingReportsAggregateArgs>(args: Subset<T, UserParkingReportsAggregateArgs>): Prisma.PrismaPromise<GetUserParkingReportsAggregateType<T>>

    /**
     * Group by UserParkingReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserParkingReportsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserParkingReportsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserParkingReportsGroupByArgs['orderBy'] }
        : { orderBy?: UserParkingReportsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserParkingReportsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserParkingReportsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserParkingReports model
   */
  readonly fields: UserParkingReportsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserParkingReports.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserParkingReportsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserParkingReports model
   */ 
  interface UserParkingReportsFieldRefs {
    readonly id: FieldRef<"UserParkingReports", 'String'>
    readonly userId: FieldRef<"UserParkingReports", 'Int'>
    readonly startedAt: FieldRef<"UserParkingReports", 'DateTime'>
    readonly finishedAt: FieldRef<"UserParkingReports", 'DateTime'>
    readonly patentId: FieldRef<"UserParkingReports", 'String'>
    readonly totalHours: FieldRef<"UserParkingReports", 'Int'>
    readonly hourPrice: FieldRef<"UserParkingReports", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * UserParkingReports findUnique
   */
  export type UserParkingReportsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserParkingReports
     */
    select?: UserParkingReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserParkingReportsInclude<ExtArgs> | null
    /**
     * Filter, which UserParkingReports to fetch.
     */
    where: UserParkingReportsWhereUniqueInput
  }

  /**
   * UserParkingReports findUniqueOrThrow
   */
  export type UserParkingReportsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserParkingReports
     */
    select?: UserParkingReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserParkingReportsInclude<ExtArgs> | null
    /**
     * Filter, which UserParkingReports to fetch.
     */
    where: UserParkingReportsWhereUniqueInput
  }

  /**
   * UserParkingReports findFirst
   */
  export type UserParkingReportsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserParkingReports
     */
    select?: UserParkingReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserParkingReportsInclude<ExtArgs> | null
    /**
     * Filter, which UserParkingReports to fetch.
     */
    where?: UserParkingReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserParkingReports to fetch.
     */
    orderBy?: UserParkingReportsOrderByWithRelationInput | UserParkingReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserParkingReports.
     */
    cursor?: UserParkingReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserParkingReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserParkingReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserParkingReports.
     */
    distinct?: UserParkingReportsScalarFieldEnum | UserParkingReportsScalarFieldEnum[]
  }

  /**
   * UserParkingReports findFirstOrThrow
   */
  export type UserParkingReportsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserParkingReports
     */
    select?: UserParkingReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserParkingReportsInclude<ExtArgs> | null
    /**
     * Filter, which UserParkingReports to fetch.
     */
    where?: UserParkingReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserParkingReports to fetch.
     */
    orderBy?: UserParkingReportsOrderByWithRelationInput | UserParkingReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserParkingReports.
     */
    cursor?: UserParkingReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserParkingReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserParkingReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserParkingReports.
     */
    distinct?: UserParkingReportsScalarFieldEnum | UserParkingReportsScalarFieldEnum[]
  }

  /**
   * UserParkingReports findMany
   */
  export type UserParkingReportsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserParkingReports
     */
    select?: UserParkingReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserParkingReportsInclude<ExtArgs> | null
    /**
     * Filter, which UserParkingReports to fetch.
     */
    where?: UserParkingReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserParkingReports to fetch.
     */
    orderBy?: UserParkingReportsOrderByWithRelationInput | UserParkingReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserParkingReports.
     */
    cursor?: UserParkingReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserParkingReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserParkingReports.
     */
    skip?: number
    distinct?: UserParkingReportsScalarFieldEnum | UserParkingReportsScalarFieldEnum[]
  }

  /**
   * UserParkingReports create
   */
  export type UserParkingReportsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserParkingReports
     */
    select?: UserParkingReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserParkingReportsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserParkingReports.
     */
    data: XOR<UserParkingReportsCreateInput, UserParkingReportsUncheckedCreateInput>
  }

  /**
   * UserParkingReports createMany
   */
  export type UserParkingReportsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserParkingReports.
     */
    data: UserParkingReportsCreateManyInput | UserParkingReportsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserParkingReports createManyAndReturn
   */
  export type UserParkingReportsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserParkingReports
     */
    select?: UserParkingReportsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserParkingReports.
     */
    data: UserParkingReportsCreateManyInput | UserParkingReportsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserParkingReportsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserParkingReports update
   */
  export type UserParkingReportsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserParkingReports
     */
    select?: UserParkingReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserParkingReportsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserParkingReports.
     */
    data: XOR<UserParkingReportsUpdateInput, UserParkingReportsUncheckedUpdateInput>
    /**
     * Choose, which UserParkingReports to update.
     */
    where: UserParkingReportsWhereUniqueInput
  }

  /**
   * UserParkingReports updateMany
   */
  export type UserParkingReportsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserParkingReports.
     */
    data: XOR<UserParkingReportsUpdateManyMutationInput, UserParkingReportsUncheckedUpdateManyInput>
    /**
     * Filter which UserParkingReports to update
     */
    where?: UserParkingReportsWhereInput
  }

  /**
   * UserParkingReports upsert
   */
  export type UserParkingReportsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserParkingReports
     */
    select?: UserParkingReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserParkingReportsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserParkingReports to update in case it exists.
     */
    where: UserParkingReportsWhereUniqueInput
    /**
     * In case the UserParkingReports found by the `where` argument doesn't exist, create a new UserParkingReports with this data.
     */
    create: XOR<UserParkingReportsCreateInput, UserParkingReportsUncheckedCreateInput>
    /**
     * In case the UserParkingReports was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserParkingReportsUpdateInput, UserParkingReportsUncheckedUpdateInput>
  }

  /**
   * UserParkingReports delete
   */
  export type UserParkingReportsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserParkingReports
     */
    select?: UserParkingReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserParkingReportsInclude<ExtArgs> | null
    /**
     * Filter which UserParkingReports to delete.
     */
    where: UserParkingReportsWhereUniqueInput
  }

  /**
   * UserParkingReports deleteMany
   */
  export type UserParkingReportsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserParkingReports to delete
     */
    where?: UserParkingReportsWhereInput
  }

  /**
   * UserParkingReports without action
   */
  export type UserParkingReportsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserParkingReports
     */
    select?: UserParkingReportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserParkingReportsInclude<ExtArgs> | null
  }


  /**
   * Model HoursPrices
   */

  export type AggregateHoursPrices = {
    _count: HoursPricesCountAggregateOutputType | null
    _avg: HoursPricesAvgAggregateOutputType | null
    _sum: HoursPricesSumAggregateOutputType | null
    _min: HoursPricesMinAggregateOutputType | null
    _max: HoursPricesMaxAggregateOutputType | null
  }

  export type HoursPricesAvgAggregateOutputType = {
    id: number | null
    hourPrice: number | null
    dayPrice: number | null
    weekPrice: number | null
  }

  export type HoursPricesSumAggregateOutputType = {
    id: number | null
    hourPrice: number | null
    dayPrice: number | null
    weekPrice: number | null
  }

  export type HoursPricesMinAggregateOutputType = {
    id: number | null
    currency: string | null
    hourPrice: number | null
    createdAt: Date | null
    deleted: boolean | null
    deletedAt: Date | null
    dayPrice: number | null
    weekPrice: number | null
  }

  export type HoursPricesMaxAggregateOutputType = {
    id: number | null
    currency: string | null
    hourPrice: number | null
    createdAt: Date | null
    deleted: boolean | null
    deletedAt: Date | null
    dayPrice: number | null
    weekPrice: number | null
  }

  export type HoursPricesCountAggregateOutputType = {
    id: number
    currency: number
    hourPrice: number
    createdAt: number
    deleted: number
    deletedAt: number
    dayPrice: number
    weekPrice: number
    _all: number
  }


  export type HoursPricesAvgAggregateInputType = {
    id?: true
    hourPrice?: true
    dayPrice?: true
    weekPrice?: true
  }

  export type HoursPricesSumAggregateInputType = {
    id?: true
    hourPrice?: true
    dayPrice?: true
    weekPrice?: true
  }

  export type HoursPricesMinAggregateInputType = {
    id?: true
    currency?: true
    hourPrice?: true
    createdAt?: true
    deleted?: true
    deletedAt?: true
    dayPrice?: true
    weekPrice?: true
  }

  export type HoursPricesMaxAggregateInputType = {
    id?: true
    currency?: true
    hourPrice?: true
    createdAt?: true
    deleted?: true
    deletedAt?: true
    dayPrice?: true
    weekPrice?: true
  }

  export type HoursPricesCountAggregateInputType = {
    id?: true
    currency?: true
    hourPrice?: true
    createdAt?: true
    deleted?: true
    deletedAt?: true
    dayPrice?: true
    weekPrice?: true
    _all?: true
  }

  export type HoursPricesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HoursPrices to aggregate.
     */
    where?: HoursPricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HoursPrices to fetch.
     */
    orderBy?: HoursPricesOrderByWithRelationInput | HoursPricesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HoursPricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HoursPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HoursPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HoursPrices
    **/
    _count?: true | HoursPricesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HoursPricesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HoursPricesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HoursPricesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HoursPricesMaxAggregateInputType
  }

  export type GetHoursPricesAggregateType<T extends HoursPricesAggregateArgs> = {
        [P in keyof T & keyof AggregateHoursPrices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHoursPrices[P]>
      : GetScalarType<T[P], AggregateHoursPrices[P]>
  }




  export type HoursPricesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HoursPricesWhereInput
    orderBy?: HoursPricesOrderByWithAggregationInput | HoursPricesOrderByWithAggregationInput[]
    by: HoursPricesScalarFieldEnum[] | HoursPricesScalarFieldEnum
    having?: HoursPricesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HoursPricesCountAggregateInputType | true
    _avg?: HoursPricesAvgAggregateInputType
    _sum?: HoursPricesSumAggregateInputType
    _min?: HoursPricesMinAggregateInputType
    _max?: HoursPricesMaxAggregateInputType
  }

  export type HoursPricesGroupByOutputType = {
    id: number
    currency: string
    hourPrice: number
    createdAt: Date
    deleted: boolean
    deletedAt: Date | null
    dayPrice: number | null
    weekPrice: number | null
    _count: HoursPricesCountAggregateOutputType | null
    _avg: HoursPricesAvgAggregateOutputType | null
    _sum: HoursPricesSumAggregateOutputType | null
    _min: HoursPricesMinAggregateOutputType | null
    _max: HoursPricesMaxAggregateOutputType | null
  }

  type GetHoursPricesGroupByPayload<T extends HoursPricesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HoursPricesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HoursPricesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HoursPricesGroupByOutputType[P]>
            : GetScalarType<T[P], HoursPricesGroupByOutputType[P]>
        }
      >
    >


  export type HoursPricesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currency?: boolean
    hourPrice?: boolean
    createdAt?: boolean
    deleted?: boolean
    deletedAt?: boolean
    dayPrice?: boolean
    weekPrice?: boolean
  }, ExtArgs["result"]["hoursPrices"]>

  export type HoursPricesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currency?: boolean
    hourPrice?: boolean
    createdAt?: boolean
    deleted?: boolean
    deletedAt?: boolean
    dayPrice?: boolean
    weekPrice?: boolean
  }, ExtArgs["result"]["hoursPrices"]>

  export type HoursPricesSelectScalar = {
    id?: boolean
    currency?: boolean
    hourPrice?: boolean
    createdAt?: boolean
    deleted?: boolean
    deletedAt?: boolean
    dayPrice?: boolean
    weekPrice?: boolean
  }


  export type $HoursPricesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HoursPrices"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      currency: string
      hourPrice: number
      createdAt: Date
      deleted: boolean
      deletedAt: Date | null
      dayPrice: number | null
      weekPrice: number | null
    }, ExtArgs["result"]["hoursPrices"]>
    composites: {}
  }

  type HoursPricesGetPayload<S extends boolean | null | undefined | HoursPricesDefaultArgs> = $Result.GetResult<Prisma.$HoursPricesPayload, S>

  type HoursPricesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HoursPricesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HoursPricesCountAggregateInputType | true
    }

  export interface HoursPricesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HoursPrices'], meta: { name: 'HoursPrices' } }
    /**
     * Find zero or one HoursPrices that matches the filter.
     * @param {HoursPricesFindUniqueArgs} args - Arguments to find a HoursPrices
     * @example
     * // Get one HoursPrices
     * const hoursPrices = await prisma.hoursPrices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HoursPricesFindUniqueArgs>(args: SelectSubset<T, HoursPricesFindUniqueArgs<ExtArgs>>): Prisma__HoursPricesClient<$Result.GetResult<Prisma.$HoursPricesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HoursPrices that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HoursPricesFindUniqueOrThrowArgs} args - Arguments to find a HoursPrices
     * @example
     * // Get one HoursPrices
     * const hoursPrices = await prisma.hoursPrices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HoursPricesFindUniqueOrThrowArgs>(args: SelectSubset<T, HoursPricesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HoursPricesClient<$Result.GetResult<Prisma.$HoursPricesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HoursPrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoursPricesFindFirstArgs} args - Arguments to find a HoursPrices
     * @example
     * // Get one HoursPrices
     * const hoursPrices = await prisma.hoursPrices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HoursPricesFindFirstArgs>(args?: SelectSubset<T, HoursPricesFindFirstArgs<ExtArgs>>): Prisma__HoursPricesClient<$Result.GetResult<Prisma.$HoursPricesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HoursPrices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoursPricesFindFirstOrThrowArgs} args - Arguments to find a HoursPrices
     * @example
     * // Get one HoursPrices
     * const hoursPrices = await prisma.hoursPrices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HoursPricesFindFirstOrThrowArgs>(args?: SelectSubset<T, HoursPricesFindFirstOrThrowArgs<ExtArgs>>): Prisma__HoursPricesClient<$Result.GetResult<Prisma.$HoursPricesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HoursPrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoursPricesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HoursPrices
     * const hoursPrices = await prisma.hoursPrices.findMany()
     * 
     * // Get first 10 HoursPrices
     * const hoursPrices = await prisma.hoursPrices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hoursPricesWithIdOnly = await prisma.hoursPrices.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HoursPricesFindManyArgs>(args?: SelectSubset<T, HoursPricesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HoursPricesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HoursPrices.
     * @param {HoursPricesCreateArgs} args - Arguments to create a HoursPrices.
     * @example
     * // Create one HoursPrices
     * const HoursPrices = await prisma.hoursPrices.create({
     *   data: {
     *     // ... data to create a HoursPrices
     *   }
     * })
     * 
     */
    create<T extends HoursPricesCreateArgs>(args: SelectSubset<T, HoursPricesCreateArgs<ExtArgs>>): Prisma__HoursPricesClient<$Result.GetResult<Prisma.$HoursPricesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HoursPrices.
     * @param {HoursPricesCreateManyArgs} args - Arguments to create many HoursPrices.
     * @example
     * // Create many HoursPrices
     * const hoursPrices = await prisma.hoursPrices.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HoursPricesCreateManyArgs>(args?: SelectSubset<T, HoursPricesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HoursPrices and returns the data saved in the database.
     * @param {HoursPricesCreateManyAndReturnArgs} args - Arguments to create many HoursPrices.
     * @example
     * // Create many HoursPrices
     * const hoursPrices = await prisma.hoursPrices.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HoursPrices and only return the `id`
     * const hoursPricesWithIdOnly = await prisma.hoursPrices.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HoursPricesCreateManyAndReturnArgs>(args?: SelectSubset<T, HoursPricesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HoursPricesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HoursPrices.
     * @param {HoursPricesDeleteArgs} args - Arguments to delete one HoursPrices.
     * @example
     * // Delete one HoursPrices
     * const HoursPrices = await prisma.hoursPrices.delete({
     *   where: {
     *     // ... filter to delete one HoursPrices
     *   }
     * })
     * 
     */
    delete<T extends HoursPricesDeleteArgs>(args: SelectSubset<T, HoursPricesDeleteArgs<ExtArgs>>): Prisma__HoursPricesClient<$Result.GetResult<Prisma.$HoursPricesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HoursPrices.
     * @param {HoursPricesUpdateArgs} args - Arguments to update one HoursPrices.
     * @example
     * // Update one HoursPrices
     * const hoursPrices = await prisma.hoursPrices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HoursPricesUpdateArgs>(args: SelectSubset<T, HoursPricesUpdateArgs<ExtArgs>>): Prisma__HoursPricesClient<$Result.GetResult<Prisma.$HoursPricesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HoursPrices.
     * @param {HoursPricesDeleteManyArgs} args - Arguments to filter HoursPrices to delete.
     * @example
     * // Delete a few HoursPrices
     * const { count } = await prisma.hoursPrices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HoursPricesDeleteManyArgs>(args?: SelectSubset<T, HoursPricesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HoursPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoursPricesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HoursPrices
     * const hoursPrices = await prisma.hoursPrices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HoursPricesUpdateManyArgs>(args: SelectSubset<T, HoursPricesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HoursPrices.
     * @param {HoursPricesUpsertArgs} args - Arguments to update or create a HoursPrices.
     * @example
     * // Update or create a HoursPrices
     * const hoursPrices = await prisma.hoursPrices.upsert({
     *   create: {
     *     // ... data to create a HoursPrices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HoursPrices we want to update
     *   }
     * })
     */
    upsert<T extends HoursPricesUpsertArgs>(args: SelectSubset<T, HoursPricesUpsertArgs<ExtArgs>>): Prisma__HoursPricesClient<$Result.GetResult<Prisma.$HoursPricesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HoursPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoursPricesCountArgs} args - Arguments to filter HoursPrices to count.
     * @example
     * // Count the number of HoursPrices
     * const count = await prisma.hoursPrices.count({
     *   where: {
     *     // ... the filter for the HoursPrices we want to count
     *   }
     * })
    **/
    count<T extends HoursPricesCountArgs>(
      args?: Subset<T, HoursPricesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HoursPricesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HoursPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoursPricesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HoursPricesAggregateArgs>(args: Subset<T, HoursPricesAggregateArgs>): Prisma.PrismaPromise<GetHoursPricesAggregateType<T>>

    /**
     * Group by HoursPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoursPricesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HoursPricesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HoursPricesGroupByArgs['orderBy'] }
        : { orderBy?: HoursPricesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HoursPricesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHoursPricesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HoursPrices model
   */
  readonly fields: HoursPricesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HoursPrices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HoursPricesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HoursPrices model
   */ 
  interface HoursPricesFieldRefs {
    readonly id: FieldRef<"HoursPrices", 'Int'>
    readonly currency: FieldRef<"HoursPrices", 'String'>
    readonly hourPrice: FieldRef<"HoursPrices", 'Float'>
    readonly createdAt: FieldRef<"HoursPrices", 'DateTime'>
    readonly deleted: FieldRef<"HoursPrices", 'Boolean'>
    readonly deletedAt: FieldRef<"HoursPrices", 'DateTime'>
    readonly dayPrice: FieldRef<"HoursPrices", 'Float'>
    readonly weekPrice: FieldRef<"HoursPrices", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * HoursPrices findUnique
   */
  export type HoursPricesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoursPrices
     */
    select?: HoursPricesSelect<ExtArgs> | null
    /**
     * Filter, which HoursPrices to fetch.
     */
    where: HoursPricesWhereUniqueInput
  }

  /**
   * HoursPrices findUniqueOrThrow
   */
  export type HoursPricesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoursPrices
     */
    select?: HoursPricesSelect<ExtArgs> | null
    /**
     * Filter, which HoursPrices to fetch.
     */
    where: HoursPricesWhereUniqueInput
  }

  /**
   * HoursPrices findFirst
   */
  export type HoursPricesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoursPrices
     */
    select?: HoursPricesSelect<ExtArgs> | null
    /**
     * Filter, which HoursPrices to fetch.
     */
    where?: HoursPricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HoursPrices to fetch.
     */
    orderBy?: HoursPricesOrderByWithRelationInput | HoursPricesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HoursPrices.
     */
    cursor?: HoursPricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HoursPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HoursPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HoursPrices.
     */
    distinct?: HoursPricesScalarFieldEnum | HoursPricesScalarFieldEnum[]
  }

  /**
   * HoursPrices findFirstOrThrow
   */
  export type HoursPricesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoursPrices
     */
    select?: HoursPricesSelect<ExtArgs> | null
    /**
     * Filter, which HoursPrices to fetch.
     */
    where?: HoursPricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HoursPrices to fetch.
     */
    orderBy?: HoursPricesOrderByWithRelationInput | HoursPricesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HoursPrices.
     */
    cursor?: HoursPricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HoursPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HoursPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HoursPrices.
     */
    distinct?: HoursPricesScalarFieldEnum | HoursPricesScalarFieldEnum[]
  }

  /**
   * HoursPrices findMany
   */
  export type HoursPricesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoursPrices
     */
    select?: HoursPricesSelect<ExtArgs> | null
    /**
     * Filter, which HoursPrices to fetch.
     */
    where?: HoursPricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HoursPrices to fetch.
     */
    orderBy?: HoursPricesOrderByWithRelationInput | HoursPricesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HoursPrices.
     */
    cursor?: HoursPricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HoursPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HoursPrices.
     */
    skip?: number
    distinct?: HoursPricesScalarFieldEnum | HoursPricesScalarFieldEnum[]
  }

  /**
   * HoursPrices create
   */
  export type HoursPricesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoursPrices
     */
    select?: HoursPricesSelect<ExtArgs> | null
    /**
     * The data needed to create a HoursPrices.
     */
    data: XOR<HoursPricesCreateInput, HoursPricesUncheckedCreateInput>
  }

  /**
   * HoursPrices createMany
   */
  export type HoursPricesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HoursPrices.
     */
    data: HoursPricesCreateManyInput | HoursPricesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HoursPrices createManyAndReturn
   */
  export type HoursPricesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoursPrices
     */
    select?: HoursPricesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HoursPrices.
     */
    data: HoursPricesCreateManyInput | HoursPricesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HoursPrices update
   */
  export type HoursPricesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoursPrices
     */
    select?: HoursPricesSelect<ExtArgs> | null
    /**
     * The data needed to update a HoursPrices.
     */
    data: XOR<HoursPricesUpdateInput, HoursPricesUncheckedUpdateInput>
    /**
     * Choose, which HoursPrices to update.
     */
    where: HoursPricesWhereUniqueInput
  }

  /**
   * HoursPrices updateMany
   */
  export type HoursPricesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HoursPrices.
     */
    data: XOR<HoursPricesUpdateManyMutationInput, HoursPricesUncheckedUpdateManyInput>
    /**
     * Filter which HoursPrices to update
     */
    where?: HoursPricesWhereInput
  }

  /**
   * HoursPrices upsert
   */
  export type HoursPricesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoursPrices
     */
    select?: HoursPricesSelect<ExtArgs> | null
    /**
     * The filter to search for the HoursPrices to update in case it exists.
     */
    where: HoursPricesWhereUniqueInput
    /**
     * In case the HoursPrices found by the `where` argument doesn't exist, create a new HoursPrices with this data.
     */
    create: XOR<HoursPricesCreateInput, HoursPricesUncheckedCreateInput>
    /**
     * In case the HoursPrices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HoursPricesUpdateInput, HoursPricesUncheckedUpdateInput>
  }

  /**
   * HoursPrices delete
   */
  export type HoursPricesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoursPrices
     */
    select?: HoursPricesSelect<ExtArgs> | null
    /**
     * Filter which HoursPrices to delete.
     */
    where: HoursPricesWhereUniqueInput
  }

  /**
   * HoursPrices deleteMany
   */
  export type HoursPricesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HoursPrices to delete
     */
    where?: HoursPricesWhereInput
  }

  /**
   * HoursPrices without action
   */
  export type HoursPricesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HoursPrices
     */
    select?: HoursPricesSelect<ExtArgs> | null
  }


  /**
   * Model Parking
   */

  export type AggregateParking = {
    _count: ParkingCountAggregateOutputType | null
    _avg: ParkingAvgAggregateOutputType | null
    _sum: ParkingSumAggregateOutputType | null
    _min: ParkingMinAggregateOutputType | null
    _max: ParkingMaxAggregateOutputType | null
  }

  export type ParkingAvgAggregateOutputType = {
    hours: number | null
    userId: number | null
  }

  export type ParkingSumAggregateOutputType = {
    hours: number | null
    userId: number | null
  }

  export type ParkingMinAggregateOutputType = {
    id: string | null
    hours: number | null
    startedAt: Date | null
    finishedAt: Date | null
    patentId: string | null
    userId: number | null
    isMonthly: boolean | null
  }

  export type ParkingMaxAggregateOutputType = {
    id: string | null
    hours: number | null
    startedAt: Date | null
    finishedAt: Date | null
    patentId: string | null
    userId: number | null
    isMonthly: boolean | null
  }

  export type ParkingCountAggregateOutputType = {
    id: number
    hours: number
    startedAt: number
    finishedAt: number
    patentId: number
    userId: number
    isMonthly: number
    _all: number
  }


  export type ParkingAvgAggregateInputType = {
    hours?: true
    userId?: true
  }

  export type ParkingSumAggregateInputType = {
    hours?: true
    userId?: true
  }

  export type ParkingMinAggregateInputType = {
    id?: true
    hours?: true
    startedAt?: true
    finishedAt?: true
    patentId?: true
    userId?: true
    isMonthly?: true
  }

  export type ParkingMaxAggregateInputType = {
    id?: true
    hours?: true
    startedAt?: true
    finishedAt?: true
    patentId?: true
    userId?: true
    isMonthly?: true
  }

  export type ParkingCountAggregateInputType = {
    id?: true
    hours?: true
    startedAt?: true
    finishedAt?: true
    patentId?: true
    userId?: true
    isMonthly?: true
    _all?: true
  }

  export type ParkingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parking to aggregate.
     */
    where?: ParkingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parkings to fetch.
     */
    orderBy?: ParkingOrderByWithRelationInput | ParkingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParkingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parkings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parkings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parkings
    **/
    _count?: true | ParkingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParkingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParkingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParkingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParkingMaxAggregateInputType
  }

  export type GetParkingAggregateType<T extends ParkingAggregateArgs> = {
        [P in keyof T & keyof AggregateParking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParking[P]>
      : GetScalarType<T[P], AggregateParking[P]>
  }




  export type ParkingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParkingWhereInput
    orderBy?: ParkingOrderByWithAggregationInput | ParkingOrderByWithAggregationInput[]
    by: ParkingScalarFieldEnum[] | ParkingScalarFieldEnum
    having?: ParkingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParkingCountAggregateInputType | true
    _avg?: ParkingAvgAggregateInputType
    _sum?: ParkingSumAggregateInputType
    _min?: ParkingMinAggregateInputType
    _max?: ParkingMaxAggregateInputType
  }

  export type ParkingGroupByOutputType = {
    id: string
    hours: number
    startedAt: Date
    finishedAt: Date | null
    patentId: string
    userId: number | null
    isMonthly: boolean
    _count: ParkingCountAggregateOutputType | null
    _avg: ParkingAvgAggregateOutputType | null
    _sum: ParkingSumAggregateOutputType | null
    _min: ParkingMinAggregateOutputType | null
    _max: ParkingMaxAggregateOutputType | null
  }

  type GetParkingGroupByPayload<T extends ParkingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParkingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParkingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParkingGroupByOutputType[P]>
            : GetScalarType<T[P], ParkingGroupByOutputType[P]>
        }
      >
    >


  export type ParkingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hours?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    patentId?: boolean
    userId?: boolean
    isMonthly?: boolean
    user?: boolean | Parking$userArgs<ExtArgs>
  }, ExtArgs["result"]["parking"]>

  export type ParkingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hours?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    patentId?: boolean
    userId?: boolean
    isMonthly?: boolean
    user?: boolean | Parking$userArgs<ExtArgs>
  }, ExtArgs["result"]["parking"]>

  export type ParkingSelectScalar = {
    id?: boolean
    hours?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    patentId?: boolean
    userId?: boolean
    isMonthly?: boolean
  }

  export type ParkingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Parking$userArgs<ExtArgs>
  }
  export type ParkingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Parking$userArgs<ExtArgs>
  }

  export type $ParkingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Parking"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hours: number
      startedAt: Date
      finishedAt: Date | null
      patentId: string
      userId: number | null
      isMonthly: boolean
    }, ExtArgs["result"]["parking"]>
    composites: {}
  }

  type ParkingGetPayload<S extends boolean | null | undefined | ParkingDefaultArgs> = $Result.GetResult<Prisma.$ParkingPayload, S>

  type ParkingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ParkingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ParkingCountAggregateInputType | true
    }

  export interface ParkingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Parking'], meta: { name: 'Parking' } }
    /**
     * Find zero or one Parking that matches the filter.
     * @param {ParkingFindUniqueArgs} args - Arguments to find a Parking
     * @example
     * // Get one Parking
     * const parking = await prisma.parking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParkingFindUniqueArgs>(args: SelectSubset<T, ParkingFindUniqueArgs<ExtArgs>>): Prisma__ParkingClient<$Result.GetResult<Prisma.$ParkingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Parking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ParkingFindUniqueOrThrowArgs} args - Arguments to find a Parking
     * @example
     * // Get one Parking
     * const parking = await prisma.parking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParkingFindUniqueOrThrowArgs>(args: SelectSubset<T, ParkingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParkingClient<$Result.GetResult<Prisma.$ParkingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Parking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingFindFirstArgs} args - Arguments to find a Parking
     * @example
     * // Get one Parking
     * const parking = await prisma.parking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParkingFindFirstArgs>(args?: SelectSubset<T, ParkingFindFirstArgs<ExtArgs>>): Prisma__ParkingClient<$Result.GetResult<Prisma.$ParkingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Parking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingFindFirstOrThrowArgs} args - Arguments to find a Parking
     * @example
     * // Get one Parking
     * const parking = await prisma.parking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParkingFindFirstOrThrowArgs>(args?: SelectSubset<T, ParkingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParkingClient<$Result.GetResult<Prisma.$ParkingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Parkings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parkings
     * const parkings = await prisma.parking.findMany()
     * 
     * // Get first 10 Parkings
     * const parkings = await prisma.parking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parkingWithIdOnly = await prisma.parking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParkingFindManyArgs>(args?: SelectSubset<T, ParkingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Parking.
     * @param {ParkingCreateArgs} args - Arguments to create a Parking.
     * @example
     * // Create one Parking
     * const Parking = await prisma.parking.create({
     *   data: {
     *     // ... data to create a Parking
     *   }
     * })
     * 
     */
    create<T extends ParkingCreateArgs>(args: SelectSubset<T, ParkingCreateArgs<ExtArgs>>): Prisma__ParkingClient<$Result.GetResult<Prisma.$ParkingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Parkings.
     * @param {ParkingCreateManyArgs} args - Arguments to create many Parkings.
     * @example
     * // Create many Parkings
     * const parking = await prisma.parking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParkingCreateManyArgs>(args?: SelectSubset<T, ParkingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Parkings and returns the data saved in the database.
     * @param {ParkingCreateManyAndReturnArgs} args - Arguments to create many Parkings.
     * @example
     * // Create many Parkings
     * const parking = await prisma.parking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Parkings and only return the `id`
     * const parkingWithIdOnly = await prisma.parking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParkingCreateManyAndReturnArgs>(args?: SelectSubset<T, ParkingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Parking.
     * @param {ParkingDeleteArgs} args - Arguments to delete one Parking.
     * @example
     * // Delete one Parking
     * const Parking = await prisma.parking.delete({
     *   where: {
     *     // ... filter to delete one Parking
     *   }
     * })
     * 
     */
    delete<T extends ParkingDeleteArgs>(args: SelectSubset<T, ParkingDeleteArgs<ExtArgs>>): Prisma__ParkingClient<$Result.GetResult<Prisma.$ParkingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Parking.
     * @param {ParkingUpdateArgs} args - Arguments to update one Parking.
     * @example
     * // Update one Parking
     * const parking = await prisma.parking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParkingUpdateArgs>(args: SelectSubset<T, ParkingUpdateArgs<ExtArgs>>): Prisma__ParkingClient<$Result.GetResult<Prisma.$ParkingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Parkings.
     * @param {ParkingDeleteManyArgs} args - Arguments to filter Parkings to delete.
     * @example
     * // Delete a few Parkings
     * const { count } = await prisma.parking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParkingDeleteManyArgs>(args?: SelectSubset<T, ParkingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parkings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parkings
     * const parking = await prisma.parking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParkingUpdateManyArgs>(args: SelectSubset<T, ParkingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parking.
     * @param {ParkingUpsertArgs} args - Arguments to update or create a Parking.
     * @example
     * // Update or create a Parking
     * const parking = await prisma.parking.upsert({
     *   create: {
     *     // ... data to create a Parking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parking we want to update
     *   }
     * })
     */
    upsert<T extends ParkingUpsertArgs>(args: SelectSubset<T, ParkingUpsertArgs<ExtArgs>>): Prisma__ParkingClient<$Result.GetResult<Prisma.$ParkingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Parkings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingCountArgs} args - Arguments to filter Parkings to count.
     * @example
     * // Count the number of Parkings
     * const count = await prisma.parking.count({
     *   where: {
     *     // ... the filter for the Parkings we want to count
     *   }
     * })
    **/
    count<T extends ParkingCountArgs>(
      args?: Subset<T, ParkingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParkingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParkingAggregateArgs>(args: Subset<T, ParkingAggregateArgs>): Prisma.PrismaPromise<GetParkingAggregateType<T>>

    /**
     * Group by Parking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParkingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParkingGroupByArgs['orderBy'] }
        : { orderBy?: ParkingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParkingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParkingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Parking model
   */
  readonly fields: ParkingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Parking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParkingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Parking$userArgs<ExtArgs> = {}>(args?: Subset<T, Parking$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Parking model
   */ 
  interface ParkingFieldRefs {
    readonly id: FieldRef<"Parking", 'String'>
    readonly hours: FieldRef<"Parking", 'Int'>
    readonly startedAt: FieldRef<"Parking", 'DateTime'>
    readonly finishedAt: FieldRef<"Parking", 'DateTime'>
    readonly patentId: FieldRef<"Parking", 'String'>
    readonly userId: FieldRef<"Parking", 'Int'>
    readonly isMonthly: FieldRef<"Parking", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Parking findUnique
   */
  export type ParkingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parking
     */
    select?: ParkingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingInclude<ExtArgs> | null
    /**
     * Filter, which Parking to fetch.
     */
    where: ParkingWhereUniqueInput
  }

  /**
   * Parking findUniqueOrThrow
   */
  export type ParkingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parking
     */
    select?: ParkingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingInclude<ExtArgs> | null
    /**
     * Filter, which Parking to fetch.
     */
    where: ParkingWhereUniqueInput
  }

  /**
   * Parking findFirst
   */
  export type ParkingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parking
     */
    select?: ParkingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingInclude<ExtArgs> | null
    /**
     * Filter, which Parking to fetch.
     */
    where?: ParkingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parkings to fetch.
     */
    orderBy?: ParkingOrderByWithRelationInput | ParkingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parkings.
     */
    cursor?: ParkingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parkings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parkings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parkings.
     */
    distinct?: ParkingScalarFieldEnum | ParkingScalarFieldEnum[]
  }

  /**
   * Parking findFirstOrThrow
   */
  export type ParkingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parking
     */
    select?: ParkingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingInclude<ExtArgs> | null
    /**
     * Filter, which Parking to fetch.
     */
    where?: ParkingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parkings to fetch.
     */
    orderBy?: ParkingOrderByWithRelationInput | ParkingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parkings.
     */
    cursor?: ParkingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parkings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parkings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parkings.
     */
    distinct?: ParkingScalarFieldEnum | ParkingScalarFieldEnum[]
  }

  /**
   * Parking findMany
   */
  export type ParkingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parking
     */
    select?: ParkingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingInclude<ExtArgs> | null
    /**
     * Filter, which Parkings to fetch.
     */
    where?: ParkingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parkings to fetch.
     */
    orderBy?: ParkingOrderByWithRelationInput | ParkingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parkings.
     */
    cursor?: ParkingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parkings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parkings.
     */
    skip?: number
    distinct?: ParkingScalarFieldEnum | ParkingScalarFieldEnum[]
  }

  /**
   * Parking create
   */
  export type ParkingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parking
     */
    select?: ParkingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingInclude<ExtArgs> | null
    /**
     * The data needed to create a Parking.
     */
    data: XOR<ParkingCreateInput, ParkingUncheckedCreateInput>
  }

  /**
   * Parking createMany
   */
  export type ParkingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parkings.
     */
    data: ParkingCreateManyInput | ParkingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Parking createManyAndReturn
   */
  export type ParkingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parking
     */
    select?: ParkingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Parkings.
     */
    data: ParkingCreateManyInput | ParkingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Parking update
   */
  export type ParkingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parking
     */
    select?: ParkingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingInclude<ExtArgs> | null
    /**
     * The data needed to update a Parking.
     */
    data: XOR<ParkingUpdateInput, ParkingUncheckedUpdateInput>
    /**
     * Choose, which Parking to update.
     */
    where: ParkingWhereUniqueInput
  }

  /**
   * Parking updateMany
   */
  export type ParkingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parkings.
     */
    data: XOR<ParkingUpdateManyMutationInput, ParkingUncheckedUpdateManyInput>
    /**
     * Filter which Parkings to update
     */
    where?: ParkingWhereInput
  }

  /**
   * Parking upsert
   */
  export type ParkingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parking
     */
    select?: ParkingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingInclude<ExtArgs> | null
    /**
     * The filter to search for the Parking to update in case it exists.
     */
    where: ParkingWhereUniqueInput
    /**
     * In case the Parking found by the `where` argument doesn't exist, create a new Parking with this data.
     */
    create: XOR<ParkingCreateInput, ParkingUncheckedCreateInput>
    /**
     * In case the Parking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParkingUpdateInput, ParkingUncheckedUpdateInput>
  }

  /**
   * Parking delete
   */
  export type ParkingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parking
     */
    select?: ParkingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingInclude<ExtArgs> | null
    /**
     * Filter which Parking to delete.
     */
    where: ParkingWhereUniqueInput
  }

  /**
   * Parking deleteMany
   */
  export type ParkingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parkings to delete
     */
    where?: ParkingWhereInput
  }

  /**
   * Parking.user
   */
  export type Parking$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Parking without action
   */
  export type ParkingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parking
     */
    select?: ParkingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkingInclude<ExtArgs> | null
  }


  /**
   * Model Infraction
   */

  export type AggregateInfraction = {
    _count: InfractionCountAggregateOutputType | null
    _avg: InfractionAvgAggregateOutputType | null
    _sum: InfractionSumAggregateOutputType | null
    _min: InfractionMinAggregateOutputType | null
    _max: InfractionMaxAggregateOutputType | null
  }

  export type InfractionAvgAggregateOutputType = {
    numberId: number | null
    payedByUserId: number | null
  }

  export type InfractionSumAggregateOutputType = {
    numberId: number | null
    payedByUserId: number | null
  }

  export type InfractionMinAggregateOutputType = {
    id: string | null
    numberId: number | null
    createdAt: Date | null
    cancelled: boolean | null
    cancelledAt: Date | null
    cancelledReason: string | null
    patentId: string | null
    street: string | null
    payed: boolean | null
    payedAt: Date | null
    isEnableToPay: boolean | null
    paymentMethod: string | null
    payedByUserId: number | null
  }

  export type InfractionMaxAggregateOutputType = {
    id: string | null
    numberId: number | null
    createdAt: Date | null
    cancelled: boolean | null
    cancelledAt: Date | null
    cancelledReason: string | null
    patentId: string | null
    street: string | null
    payed: boolean | null
    payedAt: Date | null
    isEnableToPay: boolean | null
    paymentMethod: string | null
    payedByUserId: number | null
  }

  export type InfractionCountAggregateOutputType = {
    id: number
    numberId: number
    createdAt: number
    cancelled: number
    cancelledAt: number
    cancelledReason: number
    patentId: number
    street: number
    payed: number
    payedAt: number
    isEnableToPay: number
    paymentMethod: number
    payedByUserId: number
    _all: number
  }


  export type InfractionAvgAggregateInputType = {
    numberId?: true
    payedByUserId?: true
  }

  export type InfractionSumAggregateInputType = {
    numberId?: true
    payedByUserId?: true
  }

  export type InfractionMinAggregateInputType = {
    id?: true
    numberId?: true
    createdAt?: true
    cancelled?: true
    cancelledAt?: true
    cancelledReason?: true
    patentId?: true
    street?: true
    payed?: true
    payedAt?: true
    isEnableToPay?: true
    paymentMethod?: true
    payedByUserId?: true
  }

  export type InfractionMaxAggregateInputType = {
    id?: true
    numberId?: true
    createdAt?: true
    cancelled?: true
    cancelledAt?: true
    cancelledReason?: true
    patentId?: true
    street?: true
    payed?: true
    payedAt?: true
    isEnableToPay?: true
    paymentMethod?: true
    payedByUserId?: true
  }

  export type InfractionCountAggregateInputType = {
    id?: true
    numberId?: true
    createdAt?: true
    cancelled?: true
    cancelledAt?: true
    cancelledReason?: true
    patentId?: true
    street?: true
    payed?: true
    payedAt?: true
    isEnableToPay?: true
    paymentMethod?: true
    payedByUserId?: true
    _all?: true
  }

  export type InfractionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Infraction to aggregate.
     */
    where?: InfractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Infractions to fetch.
     */
    orderBy?: InfractionOrderByWithRelationInput | InfractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InfractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Infractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Infractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Infractions
    **/
    _count?: true | InfractionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InfractionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InfractionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InfractionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InfractionMaxAggregateInputType
  }

  export type GetInfractionAggregateType<T extends InfractionAggregateArgs> = {
        [P in keyof T & keyof AggregateInfraction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInfraction[P]>
      : GetScalarType<T[P], AggregateInfraction[P]>
  }




  export type InfractionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InfractionWhereInput
    orderBy?: InfractionOrderByWithAggregationInput | InfractionOrderByWithAggregationInput[]
    by: InfractionScalarFieldEnum[] | InfractionScalarFieldEnum
    having?: InfractionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InfractionCountAggregateInputType | true
    _avg?: InfractionAvgAggregateInputType
    _sum?: InfractionSumAggregateInputType
    _min?: InfractionMinAggregateInputType
    _max?: InfractionMaxAggregateInputType
  }

  export type InfractionGroupByOutputType = {
    id: string
    numberId: number
    createdAt: Date
    cancelled: boolean
    cancelledAt: Date | null
    cancelledReason: string | null
    patentId: string
    street: string | null
    payed: boolean
    payedAt: Date | null
    isEnableToPay: boolean | null
    paymentMethod: string | null
    payedByUserId: number | null
    _count: InfractionCountAggregateOutputType | null
    _avg: InfractionAvgAggregateOutputType | null
    _sum: InfractionSumAggregateOutputType | null
    _min: InfractionMinAggregateOutputType | null
    _max: InfractionMaxAggregateOutputType | null
  }

  type GetInfractionGroupByPayload<T extends InfractionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InfractionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InfractionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InfractionGroupByOutputType[P]>
            : GetScalarType<T[P], InfractionGroupByOutputType[P]>
        }
      >
    >


  export type InfractionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numberId?: boolean
    createdAt?: boolean
    cancelled?: boolean
    cancelledAt?: boolean
    cancelledReason?: boolean
    patentId?: boolean
    street?: boolean
    payed?: boolean
    payedAt?: boolean
    isEnableToPay?: boolean
    paymentMethod?: boolean
    payedByUserId?: boolean
    images?: boolean | Infraction$imagesArgs<ExtArgs>
    payedByUser?: boolean | Infraction$payedByUserArgs<ExtArgs>
    _count?: boolean | InfractionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["infraction"]>

  export type InfractionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numberId?: boolean
    createdAt?: boolean
    cancelled?: boolean
    cancelledAt?: boolean
    cancelledReason?: boolean
    patentId?: boolean
    street?: boolean
    payed?: boolean
    payedAt?: boolean
    isEnableToPay?: boolean
    paymentMethod?: boolean
    payedByUserId?: boolean
    payedByUser?: boolean | Infraction$payedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["infraction"]>

  export type InfractionSelectScalar = {
    id?: boolean
    numberId?: boolean
    createdAt?: boolean
    cancelled?: boolean
    cancelledAt?: boolean
    cancelledReason?: boolean
    patentId?: boolean
    street?: boolean
    payed?: boolean
    payedAt?: boolean
    isEnableToPay?: boolean
    paymentMethod?: boolean
    payedByUserId?: boolean
  }

  export type InfractionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | Infraction$imagesArgs<ExtArgs>
    payedByUser?: boolean | Infraction$payedByUserArgs<ExtArgs>
    _count?: boolean | InfractionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InfractionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payedByUser?: boolean | Infraction$payedByUserArgs<ExtArgs>
  }

  export type $InfractionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Infraction"
    objects: {
      images: Prisma.$InfractionImagePayload<ExtArgs>[]
      payedByUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      numberId: number
      createdAt: Date
      cancelled: boolean
      cancelledAt: Date | null
      cancelledReason: string | null
      patentId: string
      street: string | null
      payed: boolean
      payedAt: Date | null
      isEnableToPay: boolean | null
      paymentMethod: string | null
      payedByUserId: number | null
    }, ExtArgs["result"]["infraction"]>
    composites: {}
  }

  type InfractionGetPayload<S extends boolean | null | undefined | InfractionDefaultArgs> = $Result.GetResult<Prisma.$InfractionPayload, S>

  type InfractionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InfractionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InfractionCountAggregateInputType | true
    }

  export interface InfractionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Infraction'], meta: { name: 'Infraction' } }
    /**
     * Find zero or one Infraction that matches the filter.
     * @param {InfractionFindUniqueArgs} args - Arguments to find a Infraction
     * @example
     * // Get one Infraction
     * const infraction = await prisma.infraction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InfractionFindUniqueArgs>(args: SelectSubset<T, InfractionFindUniqueArgs<ExtArgs>>): Prisma__InfractionClient<$Result.GetResult<Prisma.$InfractionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Infraction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InfractionFindUniqueOrThrowArgs} args - Arguments to find a Infraction
     * @example
     * // Get one Infraction
     * const infraction = await prisma.infraction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InfractionFindUniqueOrThrowArgs>(args: SelectSubset<T, InfractionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InfractionClient<$Result.GetResult<Prisma.$InfractionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Infraction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfractionFindFirstArgs} args - Arguments to find a Infraction
     * @example
     * // Get one Infraction
     * const infraction = await prisma.infraction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InfractionFindFirstArgs>(args?: SelectSubset<T, InfractionFindFirstArgs<ExtArgs>>): Prisma__InfractionClient<$Result.GetResult<Prisma.$InfractionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Infraction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfractionFindFirstOrThrowArgs} args - Arguments to find a Infraction
     * @example
     * // Get one Infraction
     * const infraction = await prisma.infraction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InfractionFindFirstOrThrowArgs>(args?: SelectSubset<T, InfractionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InfractionClient<$Result.GetResult<Prisma.$InfractionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Infractions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfractionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Infractions
     * const infractions = await prisma.infraction.findMany()
     * 
     * // Get first 10 Infractions
     * const infractions = await prisma.infraction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const infractionWithIdOnly = await prisma.infraction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InfractionFindManyArgs>(args?: SelectSubset<T, InfractionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfractionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Infraction.
     * @param {InfractionCreateArgs} args - Arguments to create a Infraction.
     * @example
     * // Create one Infraction
     * const Infraction = await prisma.infraction.create({
     *   data: {
     *     // ... data to create a Infraction
     *   }
     * })
     * 
     */
    create<T extends InfractionCreateArgs>(args: SelectSubset<T, InfractionCreateArgs<ExtArgs>>): Prisma__InfractionClient<$Result.GetResult<Prisma.$InfractionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Infractions.
     * @param {InfractionCreateManyArgs} args - Arguments to create many Infractions.
     * @example
     * // Create many Infractions
     * const infraction = await prisma.infraction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InfractionCreateManyArgs>(args?: SelectSubset<T, InfractionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Infractions and returns the data saved in the database.
     * @param {InfractionCreateManyAndReturnArgs} args - Arguments to create many Infractions.
     * @example
     * // Create many Infractions
     * const infraction = await prisma.infraction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Infractions and only return the `id`
     * const infractionWithIdOnly = await prisma.infraction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InfractionCreateManyAndReturnArgs>(args?: SelectSubset<T, InfractionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfractionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Infraction.
     * @param {InfractionDeleteArgs} args - Arguments to delete one Infraction.
     * @example
     * // Delete one Infraction
     * const Infraction = await prisma.infraction.delete({
     *   where: {
     *     // ... filter to delete one Infraction
     *   }
     * })
     * 
     */
    delete<T extends InfractionDeleteArgs>(args: SelectSubset<T, InfractionDeleteArgs<ExtArgs>>): Prisma__InfractionClient<$Result.GetResult<Prisma.$InfractionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Infraction.
     * @param {InfractionUpdateArgs} args - Arguments to update one Infraction.
     * @example
     * // Update one Infraction
     * const infraction = await prisma.infraction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InfractionUpdateArgs>(args: SelectSubset<T, InfractionUpdateArgs<ExtArgs>>): Prisma__InfractionClient<$Result.GetResult<Prisma.$InfractionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Infractions.
     * @param {InfractionDeleteManyArgs} args - Arguments to filter Infractions to delete.
     * @example
     * // Delete a few Infractions
     * const { count } = await prisma.infraction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InfractionDeleteManyArgs>(args?: SelectSubset<T, InfractionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Infractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfractionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Infractions
     * const infraction = await prisma.infraction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InfractionUpdateManyArgs>(args: SelectSubset<T, InfractionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Infraction.
     * @param {InfractionUpsertArgs} args - Arguments to update or create a Infraction.
     * @example
     * // Update or create a Infraction
     * const infraction = await prisma.infraction.upsert({
     *   create: {
     *     // ... data to create a Infraction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Infraction we want to update
     *   }
     * })
     */
    upsert<T extends InfractionUpsertArgs>(args: SelectSubset<T, InfractionUpsertArgs<ExtArgs>>): Prisma__InfractionClient<$Result.GetResult<Prisma.$InfractionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Infractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfractionCountArgs} args - Arguments to filter Infractions to count.
     * @example
     * // Count the number of Infractions
     * const count = await prisma.infraction.count({
     *   where: {
     *     // ... the filter for the Infractions we want to count
     *   }
     * })
    **/
    count<T extends InfractionCountArgs>(
      args?: Subset<T, InfractionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InfractionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Infraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfractionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InfractionAggregateArgs>(args: Subset<T, InfractionAggregateArgs>): Prisma.PrismaPromise<GetInfractionAggregateType<T>>

    /**
     * Group by Infraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfractionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InfractionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InfractionGroupByArgs['orderBy'] }
        : { orderBy?: InfractionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InfractionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInfractionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Infraction model
   */
  readonly fields: InfractionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Infraction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InfractionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    images<T extends Infraction$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Infraction$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfractionImagePayload<ExtArgs>, T, "findMany"> | Null>
    payedByUser<T extends Infraction$payedByUserArgs<ExtArgs> = {}>(args?: Subset<T, Infraction$payedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Infraction model
   */ 
  interface InfractionFieldRefs {
    readonly id: FieldRef<"Infraction", 'String'>
    readonly numberId: FieldRef<"Infraction", 'Int'>
    readonly createdAt: FieldRef<"Infraction", 'DateTime'>
    readonly cancelled: FieldRef<"Infraction", 'Boolean'>
    readonly cancelledAt: FieldRef<"Infraction", 'DateTime'>
    readonly cancelledReason: FieldRef<"Infraction", 'String'>
    readonly patentId: FieldRef<"Infraction", 'String'>
    readonly street: FieldRef<"Infraction", 'String'>
    readonly payed: FieldRef<"Infraction", 'Boolean'>
    readonly payedAt: FieldRef<"Infraction", 'DateTime'>
    readonly isEnableToPay: FieldRef<"Infraction", 'Boolean'>
    readonly paymentMethod: FieldRef<"Infraction", 'String'>
    readonly payedByUserId: FieldRef<"Infraction", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Infraction findUnique
   */
  export type InfractionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Infraction
     */
    select?: InfractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionInclude<ExtArgs> | null
    /**
     * Filter, which Infraction to fetch.
     */
    where: InfractionWhereUniqueInput
  }

  /**
   * Infraction findUniqueOrThrow
   */
  export type InfractionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Infraction
     */
    select?: InfractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionInclude<ExtArgs> | null
    /**
     * Filter, which Infraction to fetch.
     */
    where: InfractionWhereUniqueInput
  }

  /**
   * Infraction findFirst
   */
  export type InfractionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Infraction
     */
    select?: InfractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionInclude<ExtArgs> | null
    /**
     * Filter, which Infraction to fetch.
     */
    where?: InfractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Infractions to fetch.
     */
    orderBy?: InfractionOrderByWithRelationInput | InfractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Infractions.
     */
    cursor?: InfractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Infractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Infractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Infractions.
     */
    distinct?: InfractionScalarFieldEnum | InfractionScalarFieldEnum[]
  }

  /**
   * Infraction findFirstOrThrow
   */
  export type InfractionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Infraction
     */
    select?: InfractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionInclude<ExtArgs> | null
    /**
     * Filter, which Infraction to fetch.
     */
    where?: InfractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Infractions to fetch.
     */
    orderBy?: InfractionOrderByWithRelationInput | InfractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Infractions.
     */
    cursor?: InfractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Infractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Infractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Infractions.
     */
    distinct?: InfractionScalarFieldEnum | InfractionScalarFieldEnum[]
  }

  /**
   * Infraction findMany
   */
  export type InfractionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Infraction
     */
    select?: InfractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionInclude<ExtArgs> | null
    /**
     * Filter, which Infractions to fetch.
     */
    where?: InfractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Infractions to fetch.
     */
    orderBy?: InfractionOrderByWithRelationInput | InfractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Infractions.
     */
    cursor?: InfractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Infractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Infractions.
     */
    skip?: number
    distinct?: InfractionScalarFieldEnum | InfractionScalarFieldEnum[]
  }

  /**
   * Infraction create
   */
  export type InfractionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Infraction
     */
    select?: InfractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionInclude<ExtArgs> | null
    /**
     * The data needed to create a Infraction.
     */
    data: XOR<InfractionCreateInput, InfractionUncheckedCreateInput>
  }

  /**
   * Infraction createMany
   */
  export type InfractionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Infractions.
     */
    data: InfractionCreateManyInput | InfractionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Infraction createManyAndReturn
   */
  export type InfractionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Infraction
     */
    select?: InfractionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Infractions.
     */
    data: InfractionCreateManyInput | InfractionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Infraction update
   */
  export type InfractionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Infraction
     */
    select?: InfractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionInclude<ExtArgs> | null
    /**
     * The data needed to update a Infraction.
     */
    data: XOR<InfractionUpdateInput, InfractionUncheckedUpdateInput>
    /**
     * Choose, which Infraction to update.
     */
    where: InfractionWhereUniqueInput
  }

  /**
   * Infraction updateMany
   */
  export type InfractionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Infractions.
     */
    data: XOR<InfractionUpdateManyMutationInput, InfractionUncheckedUpdateManyInput>
    /**
     * Filter which Infractions to update
     */
    where?: InfractionWhereInput
  }

  /**
   * Infraction upsert
   */
  export type InfractionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Infraction
     */
    select?: InfractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionInclude<ExtArgs> | null
    /**
     * The filter to search for the Infraction to update in case it exists.
     */
    where: InfractionWhereUniqueInput
    /**
     * In case the Infraction found by the `where` argument doesn't exist, create a new Infraction with this data.
     */
    create: XOR<InfractionCreateInput, InfractionUncheckedCreateInput>
    /**
     * In case the Infraction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InfractionUpdateInput, InfractionUncheckedUpdateInput>
  }

  /**
   * Infraction delete
   */
  export type InfractionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Infraction
     */
    select?: InfractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionInclude<ExtArgs> | null
    /**
     * Filter which Infraction to delete.
     */
    where: InfractionWhereUniqueInput
  }

  /**
   * Infraction deleteMany
   */
  export type InfractionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Infractions to delete
     */
    where?: InfractionWhereInput
  }

  /**
   * Infraction.images
   */
  export type Infraction$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfractionImage
     */
    select?: InfractionImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionImageInclude<ExtArgs> | null
    where?: InfractionImageWhereInput
    orderBy?: InfractionImageOrderByWithRelationInput | InfractionImageOrderByWithRelationInput[]
    cursor?: InfractionImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InfractionImageScalarFieldEnum | InfractionImageScalarFieldEnum[]
  }

  /**
   * Infraction.payedByUser
   */
  export type Infraction$payedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Infraction without action
   */
  export type InfractionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Infraction
     */
    select?: InfractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionInclude<ExtArgs> | null
  }


  /**
   * Model InfractionImage
   */

  export type AggregateInfractionImage = {
    _count: InfractionImageCountAggregateOutputType | null
    _min: InfractionImageMinAggregateOutputType | null
    _max: InfractionImageMaxAggregateOutputType | null
  }

  export type InfractionImageMinAggregateOutputType = {
    id: string | null
    url: string | null
    infractionId: string | null
    createdAt: Date | null
  }

  export type InfractionImageMaxAggregateOutputType = {
    id: string | null
    url: string | null
    infractionId: string | null
    createdAt: Date | null
  }

  export type InfractionImageCountAggregateOutputType = {
    id: number
    url: number
    infractionId: number
    createdAt: number
    _all: number
  }


  export type InfractionImageMinAggregateInputType = {
    id?: true
    url?: true
    infractionId?: true
    createdAt?: true
  }

  export type InfractionImageMaxAggregateInputType = {
    id?: true
    url?: true
    infractionId?: true
    createdAt?: true
  }

  export type InfractionImageCountAggregateInputType = {
    id?: true
    url?: true
    infractionId?: true
    createdAt?: true
    _all?: true
  }

  export type InfractionImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InfractionImage to aggregate.
     */
    where?: InfractionImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InfractionImages to fetch.
     */
    orderBy?: InfractionImageOrderByWithRelationInput | InfractionImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InfractionImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InfractionImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InfractionImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InfractionImages
    **/
    _count?: true | InfractionImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InfractionImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InfractionImageMaxAggregateInputType
  }

  export type GetInfractionImageAggregateType<T extends InfractionImageAggregateArgs> = {
        [P in keyof T & keyof AggregateInfractionImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInfractionImage[P]>
      : GetScalarType<T[P], AggregateInfractionImage[P]>
  }




  export type InfractionImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InfractionImageWhereInput
    orderBy?: InfractionImageOrderByWithAggregationInput | InfractionImageOrderByWithAggregationInput[]
    by: InfractionImageScalarFieldEnum[] | InfractionImageScalarFieldEnum
    having?: InfractionImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InfractionImageCountAggregateInputType | true
    _min?: InfractionImageMinAggregateInputType
    _max?: InfractionImageMaxAggregateInputType
  }

  export type InfractionImageGroupByOutputType = {
    id: string
    url: string
    infractionId: string
    createdAt: Date
    _count: InfractionImageCountAggregateOutputType | null
    _min: InfractionImageMinAggregateOutputType | null
    _max: InfractionImageMaxAggregateOutputType | null
  }

  type GetInfractionImageGroupByPayload<T extends InfractionImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InfractionImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InfractionImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InfractionImageGroupByOutputType[P]>
            : GetScalarType<T[P], InfractionImageGroupByOutputType[P]>
        }
      >
    >


  export type InfractionImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    infractionId?: boolean
    createdAt?: boolean
    infraction?: boolean | InfractionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["infractionImage"]>

  export type InfractionImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    infractionId?: boolean
    createdAt?: boolean
    infraction?: boolean | InfractionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["infractionImage"]>

  export type InfractionImageSelectScalar = {
    id?: boolean
    url?: boolean
    infractionId?: boolean
    createdAt?: boolean
  }

  export type InfractionImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    infraction?: boolean | InfractionDefaultArgs<ExtArgs>
  }
  export type InfractionImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    infraction?: boolean | InfractionDefaultArgs<ExtArgs>
  }

  export type $InfractionImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InfractionImage"
    objects: {
      infraction: Prisma.$InfractionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      infractionId: string
      createdAt: Date
    }, ExtArgs["result"]["infractionImage"]>
    composites: {}
  }

  type InfractionImageGetPayload<S extends boolean | null | undefined | InfractionImageDefaultArgs> = $Result.GetResult<Prisma.$InfractionImagePayload, S>

  type InfractionImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InfractionImageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InfractionImageCountAggregateInputType | true
    }

  export interface InfractionImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InfractionImage'], meta: { name: 'InfractionImage' } }
    /**
     * Find zero or one InfractionImage that matches the filter.
     * @param {InfractionImageFindUniqueArgs} args - Arguments to find a InfractionImage
     * @example
     * // Get one InfractionImage
     * const infractionImage = await prisma.infractionImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InfractionImageFindUniqueArgs>(args: SelectSubset<T, InfractionImageFindUniqueArgs<ExtArgs>>): Prisma__InfractionImageClient<$Result.GetResult<Prisma.$InfractionImagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InfractionImage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InfractionImageFindUniqueOrThrowArgs} args - Arguments to find a InfractionImage
     * @example
     * // Get one InfractionImage
     * const infractionImage = await prisma.infractionImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InfractionImageFindUniqueOrThrowArgs>(args: SelectSubset<T, InfractionImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InfractionImageClient<$Result.GetResult<Prisma.$InfractionImagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InfractionImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfractionImageFindFirstArgs} args - Arguments to find a InfractionImage
     * @example
     * // Get one InfractionImage
     * const infractionImage = await prisma.infractionImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InfractionImageFindFirstArgs>(args?: SelectSubset<T, InfractionImageFindFirstArgs<ExtArgs>>): Prisma__InfractionImageClient<$Result.GetResult<Prisma.$InfractionImagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InfractionImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfractionImageFindFirstOrThrowArgs} args - Arguments to find a InfractionImage
     * @example
     * // Get one InfractionImage
     * const infractionImage = await prisma.infractionImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InfractionImageFindFirstOrThrowArgs>(args?: SelectSubset<T, InfractionImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__InfractionImageClient<$Result.GetResult<Prisma.$InfractionImagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InfractionImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfractionImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InfractionImages
     * const infractionImages = await prisma.infractionImage.findMany()
     * 
     * // Get first 10 InfractionImages
     * const infractionImages = await prisma.infractionImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const infractionImageWithIdOnly = await prisma.infractionImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InfractionImageFindManyArgs>(args?: SelectSubset<T, InfractionImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfractionImagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InfractionImage.
     * @param {InfractionImageCreateArgs} args - Arguments to create a InfractionImage.
     * @example
     * // Create one InfractionImage
     * const InfractionImage = await prisma.infractionImage.create({
     *   data: {
     *     // ... data to create a InfractionImage
     *   }
     * })
     * 
     */
    create<T extends InfractionImageCreateArgs>(args: SelectSubset<T, InfractionImageCreateArgs<ExtArgs>>): Prisma__InfractionImageClient<$Result.GetResult<Prisma.$InfractionImagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InfractionImages.
     * @param {InfractionImageCreateManyArgs} args - Arguments to create many InfractionImages.
     * @example
     * // Create many InfractionImages
     * const infractionImage = await prisma.infractionImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InfractionImageCreateManyArgs>(args?: SelectSubset<T, InfractionImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InfractionImages and returns the data saved in the database.
     * @param {InfractionImageCreateManyAndReturnArgs} args - Arguments to create many InfractionImages.
     * @example
     * // Create many InfractionImages
     * const infractionImage = await prisma.infractionImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InfractionImages and only return the `id`
     * const infractionImageWithIdOnly = await prisma.infractionImage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InfractionImageCreateManyAndReturnArgs>(args?: SelectSubset<T, InfractionImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfractionImagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InfractionImage.
     * @param {InfractionImageDeleteArgs} args - Arguments to delete one InfractionImage.
     * @example
     * // Delete one InfractionImage
     * const InfractionImage = await prisma.infractionImage.delete({
     *   where: {
     *     // ... filter to delete one InfractionImage
     *   }
     * })
     * 
     */
    delete<T extends InfractionImageDeleteArgs>(args: SelectSubset<T, InfractionImageDeleteArgs<ExtArgs>>): Prisma__InfractionImageClient<$Result.GetResult<Prisma.$InfractionImagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InfractionImage.
     * @param {InfractionImageUpdateArgs} args - Arguments to update one InfractionImage.
     * @example
     * // Update one InfractionImage
     * const infractionImage = await prisma.infractionImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InfractionImageUpdateArgs>(args: SelectSubset<T, InfractionImageUpdateArgs<ExtArgs>>): Prisma__InfractionImageClient<$Result.GetResult<Prisma.$InfractionImagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InfractionImages.
     * @param {InfractionImageDeleteManyArgs} args - Arguments to filter InfractionImages to delete.
     * @example
     * // Delete a few InfractionImages
     * const { count } = await prisma.infractionImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InfractionImageDeleteManyArgs>(args?: SelectSubset<T, InfractionImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InfractionImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfractionImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InfractionImages
     * const infractionImage = await prisma.infractionImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InfractionImageUpdateManyArgs>(args: SelectSubset<T, InfractionImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InfractionImage.
     * @param {InfractionImageUpsertArgs} args - Arguments to update or create a InfractionImage.
     * @example
     * // Update or create a InfractionImage
     * const infractionImage = await prisma.infractionImage.upsert({
     *   create: {
     *     // ... data to create a InfractionImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InfractionImage we want to update
     *   }
     * })
     */
    upsert<T extends InfractionImageUpsertArgs>(args: SelectSubset<T, InfractionImageUpsertArgs<ExtArgs>>): Prisma__InfractionImageClient<$Result.GetResult<Prisma.$InfractionImagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InfractionImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfractionImageCountArgs} args - Arguments to filter InfractionImages to count.
     * @example
     * // Count the number of InfractionImages
     * const count = await prisma.infractionImage.count({
     *   where: {
     *     // ... the filter for the InfractionImages we want to count
     *   }
     * })
    **/
    count<T extends InfractionImageCountArgs>(
      args?: Subset<T, InfractionImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InfractionImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InfractionImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfractionImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InfractionImageAggregateArgs>(args: Subset<T, InfractionImageAggregateArgs>): Prisma.PrismaPromise<GetInfractionImageAggregateType<T>>

    /**
     * Group by InfractionImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfractionImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InfractionImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InfractionImageGroupByArgs['orderBy'] }
        : { orderBy?: InfractionImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InfractionImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInfractionImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InfractionImage model
   */
  readonly fields: InfractionImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InfractionImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InfractionImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    infraction<T extends InfractionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InfractionDefaultArgs<ExtArgs>>): Prisma__InfractionClient<$Result.GetResult<Prisma.$InfractionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InfractionImage model
   */ 
  interface InfractionImageFieldRefs {
    readonly id: FieldRef<"InfractionImage", 'String'>
    readonly url: FieldRef<"InfractionImage", 'String'>
    readonly infractionId: FieldRef<"InfractionImage", 'String'>
    readonly createdAt: FieldRef<"InfractionImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InfractionImage findUnique
   */
  export type InfractionImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfractionImage
     */
    select?: InfractionImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionImageInclude<ExtArgs> | null
    /**
     * Filter, which InfractionImage to fetch.
     */
    where: InfractionImageWhereUniqueInput
  }

  /**
   * InfractionImage findUniqueOrThrow
   */
  export type InfractionImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfractionImage
     */
    select?: InfractionImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionImageInclude<ExtArgs> | null
    /**
     * Filter, which InfractionImage to fetch.
     */
    where: InfractionImageWhereUniqueInput
  }

  /**
   * InfractionImage findFirst
   */
  export type InfractionImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfractionImage
     */
    select?: InfractionImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionImageInclude<ExtArgs> | null
    /**
     * Filter, which InfractionImage to fetch.
     */
    where?: InfractionImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InfractionImages to fetch.
     */
    orderBy?: InfractionImageOrderByWithRelationInput | InfractionImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InfractionImages.
     */
    cursor?: InfractionImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InfractionImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InfractionImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InfractionImages.
     */
    distinct?: InfractionImageScalarFieldEnum | InfractionImageScalarFieldEnum[]
  }

  /**
   * InfractionImage findFirstOrThrow
   */
  export type InfractionImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfractionImage
     */
    select?: InfractionImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionImageInclude<ExtArgs> | null
    /**
     * Filter, which InfractionImage to fetch.
     */
    where?: InfractionImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InfractionImages to fetch.
     */
    orderBy?: InfractionImageOrderByWithRelationInput | InfractionImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InfractionImages.
     */
    cursor?: InfractionImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InfractionImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InfractionImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InfractionImages.
     */
    distinct?: InfractionImageScalarFieldEnum | InfractionImageScalarFieldEnum[]
  }

  /**
   * InfractionImage findMany
   */
  export type InfractionImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfractionImage
     */
    select?: InfractionImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionImageInclude<ExtArgs> | null
    /**
     * Filter, which InfractionImages to fetch.
     */
    where?: InfractionImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InfractionImages to fetch.
     */
    orderBy?: InfractionImageOrderByWithRelationInput | InfractionImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InfractionImages.
     */
    cursor?: InfractionImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InfractionImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InfractionImages.
     */
    skip?: number
    distinct?: InfractionImageScalarFieldEnum | InfractionImageScalarFieldEnum[]
  }

  /**
   * InfractionImage create
   */
  export type InfractionImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfractionImage
     */
    select?: InfractionImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionImageInclude<ExtArgs> | null
    /**
     * The data needed to create a InfractionImage.
     */
    data: XOR<InfractionImageCreateInput, InfractionImageUncheckedCreateInput>
  }

  /**
   * InfractionImage createMany
   */
  export type InfractionImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InfractionImages.
     */
    data: InfractionImageCreateManyInput | InfractionImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InfractionImage createManyAndReturn
   */
  export type InfractionImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfractionImage
     */
    select?: InfractionImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InfractionImages.
     */
    data: InfractionImageCreateManyInput | InfractionImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InfractionImage update
   */
  export type InfractionImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfractionImage
     */
    select?: InfractionImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionImageInclude<ExtArgs> | null
    /**
     * The data needed to update a InfractionImage.
     */
    data: XOR<InfractionImageUpdateInput, InfractionImageUncheckedUpdateInput>
    /**
     * Choose, which InfractionImage to update.
     */
    where: InfractionImageWhereUniqueInput
  }

  /**
   * InfractionImage updateMany
   */
  export type InfractionImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InfractionImages.
     */
    data: XOR<InfractionImageUpdateManyMutationInput, InfractionImageUncheckedUpdateManyInput>
    /**
     * Filter which InfractionImages to update
     */
    where?: InfractionImageWhereInput
  }

  /**
   * InfractionImage upsert
   */
  export type InfractionImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfractionImage
     */
    select?: InfractionImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionImageInclude<ExtArgs> | null
    /**
     * The filter to search for the InfractionImage to update in case it exists.
     */
    where: InfractionImageWhereUniqueInput
    /**
     * In case the InfractionImage found by the `where` argument doesn't exist, create a new InfractionImage with this data.
     */
    create: XOR<InfractionImageCreateInput, InfractionImageUncheckedCreateInput>
    /**
     * In case the InfractionImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InfractionImageUpdateInput, InfractionImageUncheckedUpdateInput>
  }

  /**
   * InfractionImage delete
   */
  export type InfractionImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfractionImage
     */
    select?: InfractionImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionImageInclude<ExtArgs> | null
    /**
     * Filter which InfractionImage to delete.
     */
    where: InfractionImageWhereUniqueInput
  }

  /**
   * InfractionImage deleteMany
   */
  export type InfractionImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InfractionImages to delete
     */
    where?: InfractionImageWhereInput
  }

  /**
   * InfractionImage without action
   */
  export type InfractionImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfractionImage
     */
    select?: InfractionImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionImageInclude<ExtArgs> | null
  }


  /**
   * Model SingleParkingComprobant
   */

  export type AggregateSingleParkingComprobant = {
    _count: SingleParkingComprobantCountAggregateOutputType | null
    _avg: SingleParkingComprobantAvgAggregateOutputType | null
    _sum: SingleParkingComprobantSumAggregateOutputType | null
    _min: SingleParkingComprobantMinAggregateOutputType | null
    _max: SingleParkingComprobantMaxAggregateOutputType | null
  }

  export type SingleParkingComprobantAvgAggregateOutputType = {
    id: number | null
    dni: number | null
    hours: number | null
  }

  export type SingleParkingComprobantSumAggregateOutputType = {
    id: number | null
    dni: number | null
    hours: number | null
  }

  export type SingleParkingComprobantMinAggregateOutputType = {
    id: number | null
    patentId: string | null
    dni: number | null
    hours: number | null
    sellingPoint: string | null
    createdAt: Date | null
  }

  export type SingleParkingComprobantMaxAggregateOutputType = {
    id: number | null
    patentId: string | null
    dni: number | null
    hours: number | null
    sellingPoint: string | null
    createdAt: Date | null
  }

  export type SingleParkingComprobantCountAggregateOutputType = {
    id: number
    patentId: number
    dni: number
    hours: number
    sellingPoint: number
    createdAt: number
    _all: number
  }


  export type SingleParkingComprobantAvgAggregateInputType = {
    id?: true
    dni?: true
    hours?: true
  }

  export type SingleParkingComprobantSumAggregateInputType = {
    id?: true
    dni?: true
    hours?: true
  }

  export type SingleParkingComprobantMinAggregateInputType = {
    id?: true
    patentId?: true
    dni?: true
    hours?: true
    sellingPoint?: true
    createdAt?: true
  }

  export type SingleParkingComprobantMaxAggregateInputType = {
    id?: true
    patentId?: true
    dni?: true
    hours?: true
    sellingPoint?: true
    createdAt?: true
  }

  export type SingleParkingComprobantCountAggregateInputType = {
    id?: true
    patentId?: true
    dni?: true
    hours?: true
    sellingPoint?: true
    createdAt?: true
    _all?: true
  }

  export type SingleParkingComprobantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SingleParkingComprobant to aggregate.
     */
    where?: SingleParkingComprobantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SingleParkingComprobants to fetch.
     */
    orderBy?: SingleParkingComprobantOrderByWithRelationInput | SingleParkingComprobantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SingleParkingComprobantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SingleParkingComprobants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SingleParkingComprobants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SingleParkingComprobants
    **/
    _count?: true | SingleParkingComprobantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SingleParkingComprobantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SingleParkingComprobantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SingleParkingComprobantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SingleParkingComprobantMaxAggregateInputType
  }

  export type GetSingleParkingComprobantAggregateType<T extends SingleParkingComprobantAggregateArgs> = {
        [P in keyof T & keyof AggregateSingleParkingComprobant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSingleParkingComprobant[P]>
      : GetScalarType<T[P], AggregateSingleParkingComprobant[P]>
  }




  export type SingleParkingComprobantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SingleParkingComprobantWhereInput
    orderBy?: SingleParkingComprobantOrderByWithAggregationInput | SingleParkingComprobantOrderByWithAggregationInput[]
    by: SingleParkingComprobantScalarFieldEnum[] | SingleParkingComprobantScalarFieldEnum
    having?: SingleParkingComprobantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SingleParkingComprobantCountAggregateInputType | true
    _avg?: SingleParkingComprobantAvgAggregateInputType
    _sum?: SingleParkingComprobantSumAggregateInputType
    _min?: SingleParkingComprobantMinAggregateInputType
    _max?: SingleParkingComprobantMaxAggregateInputType
  }

  export type SingleParkingComprobantGroupByOutputType = {
    id: number
    patentId: string
    dni: number
    hours: number
    sellingPoint: string
    createdAt: Date
    _count: SingleParkingComprobantCountAggregateOutputType | null
    _avg: SingleParkingComprobantAvgAggregateOutputType | null
    _sum: SingleParkingComprobantSumAggregateOutputType | null
    _min: SingleParkingComprobantMinAggregateOutputType | null
    _max: SingleParkingComprobantMaxAggregateOutputType | null
  }

  type GetSingleParkingComprobantGroupByPayload<T extends SingleParkingComprobantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SingleParkingComprobantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SingleParkingComprobantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SingleParkingComprobantGroupByOutputType[P]>
            : GetScalarType<T[P], SingleParkingComprobantGroupByOutputType[P]>
        }
      >
    >


  export type SingleParkingComprobantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patentId?: boolean
    dni?: boolean
    hours?: boolean
    sellingPoint?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["singleParkingComprobant"]>

  export type SingleParkingComprobantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patentId?: boolean
    dni?: boolean
    hours?: boolean
    sellingPoint?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["singleParkingComprobant"]>

  export type SingleParkingComprobantSelectScalar = {
    id?: boolean
    patentId?: boolean
    dni?: boolean
    hours?: boolean
    sellingPoint?: boolean
    createdAt?: boolean
  }


  export type $SingleParkingComprobantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SingleParkingComprobant"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patentId: string
      dni: number
      hours: number
      sellingPoint: string
      createdAt: Date
    }, ExtArgs["result"]["singleParkingComprobant"]>
    composites: {}
  }

  type SingleParkingComprobantGetPayload<S extends boolean | null | undefined | SingleParkingComprobantDefaultArgs> = $Result.GetResult<Prisma.$SingleParkingComprobantPayload, S>

  type SingleParkingComprobantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SingleParkingComprobantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SingleParkingComprobantCountAggregateInputType | true
    }

  export interface SingleParkingComprobantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SingleParkingComprobant'], meta: { name: 'SingleParkingComprobant' } }
    /**
     * Find zero or one SingleParkingComprobant that matches the filter.
     * @param {SingleParkingComprobantFindUniqueArgs} args - Arguments to find a SingleParkingComprobant
     * @example
     * // Get one SingleParkingComprobant
     * const singleParkingComprobant = await prisma.singleParkingComprobant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SingleParkingComprobantFindUniqueArgs>(args: SelectSubset<T, SingleParkingComprobantFindUniqueArgs<ExtArgs>>): Prisma__SingleParkingComprobantClient<$Result.GetResult<Prisma.$SingleParkingComprobantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SingleParkingComprobant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SingleParkingComprobantFindUniqueOrThrowArgs} args - Arguments to find a SingleParkingComprobant
     * @example
     * // Get one SingleParkingComprobant
     * const singleParkingComprobant = await prisma.singleParkingComprobant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SingleParkingComprobantFindUniqueOrThrowArgs>(args: SelectSubset<T, SingleParkingComprobantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SingleParkingComprobantClient<$Result.GetResult<Prisma.$SingleParkingComprobantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SingleParkingComprobant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SingleParkingComprobantFindFirstArgs} args - Arguments to find a SingleParkingComprobant
     * @example
     * // Get one SingleParkingComprobant
     * const singleParkingComprobant = await prisma.singleParkingComprobant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SingleParkingComprobantFindFirstArgs>(args?: SelectSubset<T, SingleParkingComprobantFindFirstArgs<ExtArgs>>): Prisma__SingleParkingComprobantClient<$Result.GetResult<Prisma.$SingleParkingComprobantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SingleParkingComprobant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SingleParkingComprobantFindFirstOrThrowArgs} args - Arguments to find a SingleParkingComprobant
     * @example
     * // Get one SingleParkingComprobant
     * const singleParkingComprobant = await prisma.singleParkingComprobant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SingleParkingComprobantFindFirstOrThrowArgs>(args?: SelectSubset<T, SingleParkingComprobantFindFirstOrThrowArgs<ExtArgs>>): Prisma__SingleParkingComprobantClient<$Result.GetResult<Prisma.$SingleParkingComprobantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SingleParkingComprobants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SingleParkingComprobantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SingleParkingComprobants
     * const singleParkingComprobants = await prisma.singleParkingComprobant.findMany()
     * 
     * // Get first 10 SingleParkingComprobants
     * const singleParkingComprobants = await prisma.singleParkingComprobant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const singleParkingComprobantWithIdOnly = await prisma.singleParkingComprobant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SingleParkingComprobantFindManyArgs>(args?: SelectSubset<T, SingleParkingComprobantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SingleParkingComprobantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SingleParkingComprobant.
     * @param {SingleParkingComprobantCreateArgs} args - Arguments to create a SingleParkingComprobant.
     * @example
     * // Create one SingleParkingComprobant
     * const SingleParkingComprobant = await prisma.singleParkingComprobant.create({
     *   data: {
     *     // ... data to create a SingleParkingComprobant
     *   }
     * })
     * 
     */
    create<T extends SingleParkingComprobantCreateArgs>(args: SelectSubset<T, SingleParkingComprobantCreateArgs<ExtArgs>>): Prisma__SingleParkingComprobantClient<$Result.GetResult<Prisma.$SingleParkingComprobantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SingleParkingComprobants.
     * @param {SingleParkingComprobantCreateManyArgs} args - Arguments to create many SingleParkingComprobants.
     * @example
     * // Create many SingleParkingComprobants
     * const singleParkingComprobant = await prisma.singleParkingComprobant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SingleParkingComprobantCreateManyArgs>(args?: SelectSubset<T, SingleParkingComprobantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SingleParkingComprobants and returns the data saved in the database.
     * @param {SingleParkingComprobantCreateManyAndReturnArgs} args - Arguments to create many SingleParkingComprobants.
     * @example
     * // Create many SingleParkingComprobants
     * const singleParkingComprobant = await prisma.singleParkingComprobant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SingleParkingComprobants and only return the `id`
     * const singleParkingComprobantWithIdOnly = await prisma.singleParkingComprobant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SingleParkingComprobantCreateManyAndReturnArgs>(args?: SelectSubset<T, SingleParkingComprobantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SingleParkingComprobantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SingleParkingComprobant.
     * @param {SingleParkingComprobantDeleteArgs} args - Arguments to delete one SingleParkingComprobant.
     * @example
     * // Delete one SingleParkingComprobant
     * const SingleParkingComprobant = await prisma.singleParkingComprobant.delete({
     *   where: {
     *     // ... filter to delete one SingleParkingComprobant
     *   }
     * })
     * 
     */
    delete<T extends SingleParkingComprobantDeleteArgs>(args: SelectSubset<T, SingleParkingComprobantDeleteArgs<ExtArgs>>): Prisma__SingleParkingComprobantClient<$Result.GetResult<Prisma.$SingleParkingComprobantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SingleParkingComprobant.
     * @param {SingleParkingComprobantUpdateArgs} args - Arguments to update one SingleParkingComprobant.
     * @example
     * // Update one SingleParkingComprobant
     * const singleParkingComprobant = await prisma.singleParkingComprobant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SingleParkingComprobantUpdateArgs>(args: SelectSubset<T, SingleParkingComprobantUpdateArgs<ExtArgs>>): Prisma__SingleParkingComprobantClient<$Result.GetResult<Prisma.$SingleParkingComprobantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SingleParkingComprobants.
     * @param {SingleParkingComprobantDeleteManyArgs} args - Arguments to filter SingleParkingComprobants to delete.
     * @example
     * // Delete a few SingleParkingComprobants
     * const { count } = await prisma.singleParkingComprobant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SingleParkingComprobantDeleteManyArgs>(args?: SelectSubset<T, SingleParkingComprobantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SingleParkingComprobants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SingleParkingComprobantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SingleParkingComprobants
     * const singleParkingComprobant = await prisma.singleParkingComprobant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SingleParkingComprobantUpdateManyArgs>(args: SelectSubset<T, SingleParkingComprobantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SingleParkingComprobant.
     * @param {SingleParkingComprobantUpsertArgs} args - Arguments to update or create a SingleParkingComprobant.
     * @example
     * // Update or create a SingleParkingComprobant
     * const singleParkingComprobant = await prisma.singleParkingComprobant.upsert({
     *   create: {
     *     // ... data to create a SingleParkingComprobant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SingleParkingComprobant we want to update
     *   }
     * })
     */
    upsert<T extends SingleParkingComprobantUpsertArgs>(args: SelectSubset<T, SingleParkingComprobantUpsertArgs<ExtArgs>>): Prisma__SingleParkingComprobantClient<$Result.GetResult<Prisma.$SingleParkingComprobantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SingleParkingComprobants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SingleParkingComprobantCountArgs} args - Arguments to filter SingleParkingComprobants to count.
     * @example
     * // Count the number of SingleParkingComprobants
     * const count = await prisma.singleParkingComprobant.count({
     *   where: {
     *     // ... the filter for the SingleParkingComprobants we want to count
     *   }
     * })
    **/
    count<T extends SingleParkingComprobantCountArgs>(
      args?: Subset<T, SingleParkingComprobantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SingleParkingComprobantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SingleParkingComprobant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SingleParkingComprobantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SingleParkingComprobantAggregateArgs>(args: Subset<T, SingleParkingComprobantAggregateArgs>): Prisma.PrismaPromise<GetSingleParkingComprobantAggregateType<T>>

    /**
     * Group by SingleParkingComprobant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SingleParkingComprobantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SingleParkingComprobantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SingleParkingComprobantGroupByArgs['orderBy'] }
        : { orderBy?: SingleParkingComprobantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SingleParkingComprobantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSingleParkingComprobantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SingleParkingComprobant model
   */
  readonly fields: SingleParkingComprobantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SingleParkingComprobant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SingleParkingComprobantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SingleParkingComprobant model
   */ 
  interface SingleParkingComprobantFieldRefs {
    readonly id: FieldRef<"SingleParkingComprobant", 'Int'>
    readonly patentId: FieldRef<"SingleParkingComprobant", 'String'>
    readonly dni: FieldRef<"SingleParkingComprobant", 'Int'>
    readonly hours: FieldRef<"SingleParkingComprobant", 'Int'>
    readonly sellingPoint: FieldRef<"SingleParkingComprobant", 'String'>
    readonly createdAt: FieldRef<"SingleParkingComprobant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SingleParkingComprobant findUnique
   */
  export type SingleParkingComprobantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SingleParkingComprobant
     */
    select?: SingleParkingComprobantSelect<ExtArgs> | null
    /**
     * Filter, which SingleParkingComprobant to fetch.
     */
    where: SingleParkingComprobantWhereUniqueInput
  }

  /**
   * SingleParkingComprobant findUniqueOrThrow
   */
  export type SingleParkingComprobantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SingleParkingComprobant
     */
    select?: SingleParkingComprobantSelect<ExtArgs> | null
    /**
     * Filter, which SingleParkingComprobant to fetch.
     */
    where: SingleParkingComprobantWhereUniqueInput
  }

  /**
   * SingleParkingComprobant findFirst
   */
  export type SingleParkingComprobantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SingleParkingComprobant
     */
    select?: SingleParkingComprobantSelect<ExtArgs> | null
    /**
     * Filter, which SingleParkingComprobant to fetch.
     */
    where?: SingleParkingComprobantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SingleParkingComprobants to fetch.
     */
    orderBy?: SingleParkingComprobantOrderByWithRelationInput | SingleParkingComprobantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SingleParkingComprobants.
     */
    cursor?: SingleParkingComprobantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SingleParkingComprobants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SingleParkingComprobants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SingleParkingComprobants.
     */
    distinct?: SingleParkingComprobantScalarFieldEnum | SingleParkingComprobantScalarFieldEnum[]
  }

  /**
   * SingleParkingComprobant findFirstOrThrow
   */
  export type SingleParkingComprobantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SingleParkingComprobant
     */
    select?: SingleParkingComprobantSelect<ExtArgs> | null
    /**
     * Filter, which SingleParkingComprobant to fetch.
     */
    where?: SingleParkingComprobantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SingleParkingComprobants to fetch.
     */
    orderBy?: SingleParkingComprobantOrderByWithRelationInput | SingleParkingComprobantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SingleParkingComprobants.
     */
    cursor?: SingleParkingComprobantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SingleParkingComprobants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SingleParkingComprobants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SingleParkingComprobants.
     */
    distinct?: SingleParkingComprobantScalarFieldEnum | SingleParkingComprobantScalarFieldEnum[]
  }

  /**
   * SingleParkingComprobant findMany
   */
  export type SingleParkingComprobantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SingleParkingComprobant
     */
    select?: SingleParkingComprobantSelect<ExtArgs> | null
    /**
     * Filter, which SingleParkingComprobants to fetch.
     */
    where?: SingleParkingComprobantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SingleParkingComprobants to fetch.
     */
    orderBy?: SingleParkingComprobantOrderByWithRelationInput | SingleParkingComprobantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SingleParkingComprobants.
     */
    cursor?: SingleParkingComprobantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SingleParkingComprobants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SingleParkingComprobants.
     */
    skip?: number
    distinct?: SingleParkingComprobantScalarFieldEnum | SingleParkingComprobantScalarFieldEnum[]
  }

  /**
   * SingleParkingComprobant create
   */
  export type SingleParkingComprobantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SingleParkingComprobant
     */
    select?: SingleParkingComprobantSelect<ExtArgs> | null
    /**
     * The data needed to create a SingleParkingComprobant.
     */
    data: XOR<SingleParkingComprobantCreateInput, SingleParkingComprobantUncheckedCreateInput>
  }

  /**
   * SingleParkingComprobant createMany
   */
  export type SingleParkingComprobantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SingleParkingComprobants.
     */
    data: SingleParkingComprobantCreateManyInput | SingleParkingComprobantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SingleParkingComprobant createManyAndReturn
   */
  export type SingleParkingComprobantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SingleParkingComprobant
     */
    select?: SingleParkingComprobantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SingleParkingComprobants.
     */
    data: SingleParkingComprobantCreateManyInput | SingleParkingComprobantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SingleParkingComprobant update
   */
  export type SingleParkingComprobantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SingleParkingComprobant
     */
    select?: SingleParkingComprobantSelect<ExtArgs> | null
    /**
     * The data needed to update a SingleParkingComprobant.
     */
    data: XOR<SingleParkingComprobantUpdateInput, SingleParkingComprobantUncheckedUpdateInput>
    /**
     * Choose, which SingleParkingComprobant to update.
     */
    where: SingleParkingComprobantWhereUniqueInput
  }

  /**
   * SingleParkingComprobant updateMany
   */
  export type SingleParkingComprobantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SingleParkingComprobants.
     */
    data: XOR<SingleParkingComprobantUpdateManyMutationInput, SingleParkingComprobantUncheckedUpdateManyInput>
    /**
     * Filter which SingleParkingComprobants to update
     */
    where?: SingleParkingComprobantWhereInput
  }

  /**
   * SingleParkingComprobant upsert
   */
  export type SingleParkingComprobantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SingleParkingComprobant
     */
    select?: SingleParkingComprobantSelect<ExtArgs> | null
    /**
     * The filter to search for the SingleParkingComprobant to update in case it exists.
     */
    where: SingleParkingComprobantWhereUniqueInput
    /**
     * In case the SingleParkingComprobant found by the `where` argument doesn't exist, create a new SingleParkingComprobant with this data.
     */
    create: XOR<SingleParkingComprobantCreateInput, SingleParkingComprobantUncheckedCreateInput>
    /**
     * In case the SingleParkingComprobant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SingleParkingComprobantUpdateInput, SingleParkingComprobantUncheckedUpdateInput>
  }

  /**
   * SingleParkingComprobant delete
   */
  export type SingleParkingComprobantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SingleParkingComprobant
     */
    select?: SingleParkingComprobantSelect<ExtArgs> | null
    /**
     * Filter which SingleParkingComprobant to delete.
     */
    where: SingleParkingComprobantWhereUniqueInput
  }

  /**
   * SingleParkingComprobant deleteMany
   */
  export type SingleParkingComprobantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SingleParkingComprobants to delete
     */
    where?: SingleParkingComprobantWhereInput
  }

  /**
   * SingleParkingComprobant without action
   */
  export type SingleParkingComprobantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SingleParkingComprobant
     */
    select?: SingleParkingComprobantSelect<ExtArgs> | null
  }


  /**
   * Model SellingHoursComprobant
   */

  export type AggregateSellingHoursComprobant = {
    _count: SellingHoursComprobantCountAggregateOutputType | null
    _avg: SellingHoursComprobantAvgAggregateOutputType | null
    _sum: SellingHoursComprobantSumAggregateOutputType | null
    _min: SellingHoursComprobantMinAggregateOutputType | null
    _max: SellingHoursComprobantMaxAggregateOutputType | null
  }

  export type SellingHoursComprobantAvgAggregateOutputType = {
    id: number | null
    dni: number | null
    hours: number | null
    price: number | null
  }

  export type SellingHoursComprobantSumAggregateOutputType = {
    id: number | null
    dni: number | null
    hours: number | null
    price: number | null
  }

  export type SellingHoursComprobantMinAggregateOutputType = {
    id: number | null
    dni: number | null
    hours: number | null
    sellingPoint: string | null
    price: number | null
    createdAt: Date | null
  }

  export type SellingHoursComprobantMaxAggregateOutputType = {
    id: number | null
    dni: number | null
    hours: number | null
    sellingPoint: string | null
    price: number | null
    createdAt: Date | null
  }

  export type SellingHoursComprobantCountAggregateOutputType = {
    id: number
    dni: number
    hours: number
    sellingPoint: number
    price: number
    createdAt: number
    _all: number
  }


  export type SellingHoursComprobantAvgAggregateInputType = {
    id?: true
    dni?: true
    hours?: true
    price?: true
  }

  export type SellingHoursComprobantSumAggregateInputType = {
    id?: true
    dni?: true
    hours?: true
    price?: true
  }

  export type SellingHoursComprobantMinAggregateInputType = {
    id?: true
    dni?: true
    hours?: true
    sellingPoint?: true
    price?: true
    createdAt?: true
  }

  export type SellingHoursComprobantMaxAggregateInputType = {
    id?: true
    dni?: true
    hours?: true
    sellingPoint?: true
    price?: true
    createdAt?: true
  }

  export type SellingHoursComprobantCountAggregateInputType = {
    id?: true
    dni?: true
    hours?: true
    sellingPoint?: true
    price?: true
    createdAt?: true
    _all?: true
  }

  export type SellingHoursComprobantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellingHoursComprobant to aggregate.
     */
    where?: SellingHoursComprobantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellingHoursComprobants to fetch.
     */
    orderBy?: SellingHoursComprobantOrderByWithRelationInput | SellingHoursComprobantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SellingHoursComprobantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellingHoursComprobants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellingHoursComprobants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SellingHoursComprobants
    **/
    _count?: true | SellingHoursComprobantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SellingHoursComprobantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SellingHoursComprobantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellingHoursComprobantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellingHoursComprobantMaxAggregateInputType
  }

  export type GetSellingHoursComprobantAggregateType<T extends SellingHoursComprobantAggregateArgs> = {
        [P in keyof T & keyof AggregateSellingHoursComprobant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSellingHoursComprobant[P]>
      : GetScalarType<T[P], AggregateSellingHoursComprobant[P]>
  }




  export type SellingHoursComprobantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellingHoursComprobantWhereInput
    orderBy?: SellingHoursComprobantOrderByWithAggregationInput | SellingHoursComprobantOrderByWithAggregationInput[]
    by: SellingHoursComprobantScalarFieldEnum[] | SellingHoursComprobantScalarFieldEnum
    having?: SellingHoursComprobantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellingHoursComprobantCountAggregateInputType | true
    _avg?: SellingHoursComprobantAvgAggregateInputType
    _sum?: SellingHoursComprobantSumAggregateInputType
    _min?: SellingHoursComprobantMinAggregateInputType
    _max?: SellingHoursComprobantMaxAggregateInputType
  }

  export type SellingHoursComprobantGroupByOutputType = {
    id: number
    dni: number
    hours: number
    sellingPoint: string
    price: number
    createdAt: Date
    _count: SellingHoursComprobantCountAggregateOutputType | null
    _avg: SellingHoursComprobantAvgAggregateOutputType | null
    _sum: SellingHoursComprobantSumAggregateOutputType | null
    _min: SellingHoursComprobantMinAggregateOutputType | null
    _max: SellingHoursComprobantMaxAggregateOutputType | null
  }

  type GetSellingHoursComprobantGroupByPayload<T extends SellingHoursComprobantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SellingHoursComprobantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellingHoursComprobantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellingHoursComprobantGroupByOutputType[P]>
            : GetScalarType<T[P], SellingHoursComprobantGroupByOutputType[P]>
        }
      >
    >


  export type SellingHoursComprobantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dni?: boolean
    hours?: boolean
    sellingPoint?: boolean
    price?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sellingHoursComprobant"]>

  export type SellingHoursComprobantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dni?: boolean
    hours?: boolean
    sellingPoint?: boolean
    price?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sellingHoursComprobant"]>

  export type SellingHoursComprobantSelectScalar = {
    id?: boolean
    dni?: boolean
    hours?: boolean
    sellingPoint?: boolean
    price?: boolean
    createdAt?: boolean
  }


  export type $SellingHoursComprobantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SellingHoursComprobant"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dni: number
      hours: number
      sellingPoint: string
      price: number
      createdAt: Date
    }, ExtArgs["result"]["sellingHoursComprobant"]>
    composites: {}
  }

  type SellingHoursComprobantGetPayload<S extends boolean | null | undefined | SellingHoursComprobantDefaultArgs> = $Result.GetResult<Prisma.$SellingHoursComprobantPayload, S>

  type SellingHoursComprobantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SellingHoursComprobantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SellingHoursComprobantCountAggregateInputType | true
    }

  export interface SellingHoursComprobantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SellingHoursComprobant'], meta: { name: 'SellingHoursComprobant' } }
    /**
     * Find zero or one SellingHoursComprobant that matches the filter.
     * @param {SellingHoursComprobantFindUniqueArgs} args - Arguments to find a SellingHoursComprobant
     * @example
     * // Get one SellingHoursComprobant
     * const sellingHoursComprobant = await prisma.sellingHoursComprobant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SellingHoursComprobantFindUniqueArgs>(args: SelectSubset<T, SellingHoursComprobantFindUniqueArgs<ExtArgs>>): Prisma__SellingHoursComprobantClient<$Result.GetResult<Prisma.$SellingHoursComprobantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SellingHoursComprobant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SellingHoursComprobantFindUniqueOrThrowArgs} args - Arguments to find a SellingHoursComprobant
     * @example
     * // Get one SellingHoursComprobant
     * const sellingHoursComprobant = await prisma.sellingHoursComprobant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SellingHoursComprobantFindUniqueOrThrowArgs>(args: SelectSubset<T, SellingHoursComprobantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SellingHoursComprobantClient<$Result.GetResult<Prisma.$SellingHoursComprobantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SellingHoursComprobant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingHoursComprobantFindFirstArgs} args - Arguments to find a SellingHoursComprobant
     * @example
     * // Get one SellingHoursComprobant
     * const sellingHoursComprobant = await prisma.sellingHoursComprobant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SellingHoursComprobantFindFirstArgs>(args?: SelectSubset<T, SellingHoursComprobantFindFirstArgs<ExtArgs>>): Prisma__SellingHoursComprobantClient<$Result.GetResult<Prisma.$SellingHoursComprobantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SellingHoursComprobant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingHoursComprobantFindFirstOrThrowArgs} args - Arguments to find a SellingHoursComprobant
     * @example
     * // Get one SellingHoursComprobant
     * const sellingHoursComprobant = await prisma.sellingHoursComprobant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SellingHoursComprobantFindFirstOrThrowArgs>(args?: SelectSubset<T, SellingHoursComprobantFindFirstOrThrowArgs<ExtArgs>>): Prisma__SellingHoursComprobantClient<$Result.GetResult<Prisma.$SellingHoursComprobantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SellingHoursComprobants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingHoursComprobantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SellingHoursComprobants
     * const sellingHoursComprobants = await prisma.sellingHoursComprobant.findMany()
     * 
     * // Get first 10 SellingHoursComprobants
     * const sellingHoursComprobants = await prisma.sellingHoursComprobant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sellingHoursComprobantWithIdOnly = await prisma.sellingHoursComprobant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SellingHoursComprobantFindManyArgs>(args?: SelectSubset<T, SellingHoursComprobantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellingHoursComprobantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SellingHoursComprobant.
     * @param {SellingHoursComprobantCreateArgs} args - Arguments to create a SellingHoursComprobant.
     * @example
     * // Create one SellingHoursComprobant
     * const SellingHoursComprobant = await prisma.sellingHoursComprobant.create({
     *   data: {
     *     // ... data to create a SellingHoursComprobant
     *   }
     * })
     * 
     */
    create<T extends SellingHoursComprobantCreateArgs>(args: SelectSubset<T, SellingHoursComprobantCreateArgs<ExtArgs>>): Prisma__SellingHoursComprobantClient<$Result.GetResult<Prisma.$SellingHoursComprobantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SellingHoursComprobants.
     * @param {SellingHoursComprobantCreateManyArgs} args - Arguments to create many SellingHoursComprobants.
     * @example
     * // Create many SellingHoursComprobants
     * const sellingHoursComprobant = await prisma.sellingHoursComprobant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SellingHoursComprobantCreateManyArgs>(args?: SelectSubset<T, SellingHoursComprobantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SellingHoursComprobants and returns the data saved in the database.
     * @param {SellingHoursComprobantCreateManyAndReturnArgs} args - Arguments to create many SellingHoursComprobants.
     * @example
     * // Create many SellingHoursComprobants
     * const sellingHoursComprobant = await prisma.sellingHoursComprobant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SellingHoursComprobants and only return the `id`
     * const sellingHoursComprobantWithIdOnly = await prisma.sellingHoursComprobant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SellingHoursComprobantCreateManyAndReturnArgs>(args?: SelectSubset<T, SellingHoursComprobantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellingHoursComprobantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SellingHoursComprobant.
     * @param {SellingHoursComprobantDeleteArgs} args - Arguments to delete one SellingHoursComprobant.
     * @example
     * // Delete one SellingHoursComprobant
     * const SellingHoursComprobant = await prisma.sellingHoursComprobant.delete({
     *   where: {
     *     // ... filter to delete one SellingHoursComprobant
     *   }
     * })
     * 
     */
    delete<T extends SellingHoursComprobantDeleteArgs>(args: SelectSubset<T, SellingHoursComprobantDeleteArgs<ExtArgs>>): Prisma__SellingHoursComprobantClient<$Result.GetResult<Prisma.$SellingHoursComprobantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SellingHoursComprobant.
     * @param {SellingHoursComprobantUpdateArgs} args - Arguments to update one SellingHoursComprobant.
     * @example
     * // Update one SellingHoursComprobant
     * const sellingHoursComprobant = await prisma.sellingHoursComprobant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SellingHoursComprobantUpdateArgs>(args: SelectSubset<T, SellingHoursComprobantUpdateArgs<ExtArgs>>): Prisma__SellingHoursComprobantClient<$Result.GetResult<Prisma.$SellingHoursComprobantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SellingHoursComprobants.
     * @param {SellingHoursComprobantDeleteManyArgs} args - Arguments to filter SellingHoursComprobants to delete.
     * @example
     * // Delete a few SellingHoursComprobants
     * const { count } = await prisma.sellingHoursComprobant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SellingHoursComprobantDeleteManyArgs>(args?: SelectSubset<T, SellingHoursComprobantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellingHoursComprobants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingHoursComprobantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SellingHoursComprobants
     * const sellingHoursComprobant = await prisma.sellingHoursComprobant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SellingHoursComprobantUpdateManyArgs>(args: SelectSubset<T, SellingHoursComprobantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SellingHoursComprobant.
     * @param {SellingHoursComprobantUpsertArgs} args - Arguments to update or create a SellingHoursComprobant.
     * @example
     * // Update or create a SellingHoursComprobant
     * const sellingHoursComprobant = await prisma.sellingHoursComprobant.upsert({
     *   create: {
     *     // ... data to create a SellingHoursComprobant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SellingHoursComprobant we want to update
     *   }
     * })
     */
    upsert<T extends SellingHoursComprobantUpsertArgs>(args: SelectSubset<T, SellingHoursComprobantUpsertArgs<ExtArgs>>): Prisma__SellingHoursComprobantClient<$Result.GetResult<Prisma.$SellingHoursComprobantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SellingHoursComprobants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingHoursComprobantCountArgs} args - Arguments to filter SellingHoursComprobants to count.
     * @example
     * // Count the number of SellingHoursComprobants
     * const count = await prisma.sellingHoursComprobant.count({
     *   where: {
     *     // ... the filter for the SellingHoursComprobants we want to count
     *   }
     * })
    **/
    count<T extends SellingHoursComprobantCountArgs>(
      args?: Subset<T, SellingHoursComprobantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellingHoursComprobantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SellingHoursComprobant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingHoursComprobantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellingHoursComprobantAggregateArgs>(args: Subset<T, SellingHoursComprobantAggregateArgs>): Prisma.PrismaPromise<GetSellingHoursComprobantAggregateType<T>>

    /**
     * Group by SellingHoursComprobant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingHoursComprobantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellingHoursComprobantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellingHoursComprobantGroupByArgs['orderBy'] }
        : { orderBy?: SellingHoursComprobantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellingHoursComprobantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellingHoursComprobantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SellingHoursComprobant model
   */
  readonly fields: SellingHoursComprobantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SellingHoursComprobant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SellingHoursComprobantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SellingHoursComprobant model
   */ 
  interface SellingHoursComprobantFieldRefs {
    readonly id: FieldRef<"SellingHoursComprobant", 'Int'>
    readonly dni: FieldRef<"SellingHoursComprobant", 'Int'>
    readonly hours: FieldRef<"SellingHoursComprobant", 'Int'>
    readonly sellingPoint: FieldRef<"SellingHoursComprobant", 'String'>
    readonly price: FieldRef<"SellingHoursComprobant", 'Int'>
    readonly createdAt: FieldRef<"SellingHoursComprobant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SellingHoursComprobant findUnique
   */
  export type SellingHoursComprobantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHoursComprobant
     */
    select?: SellingHoursComprobantSelect<ExtArgs> | null
    /**
     * Filter, which SellingHoursComprobant to fetch.
     */
    where: SellingHoursComprobantWhereUniqueInput
  }

  /**
   * SellingHoursComprobant findUniqueOrThrow
   */
  export type SellingHoursComprobantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHoursComprobant
     */
    select?: SellingHoursComprobantSelect<ExtArgs> | null
    /**
     * Filter, which SellingHoursComprobant to fetch.
     */
    where: SellingHoursComprobantWhereUniqueInput
  }

  /**
   * SellingHoursComprobant findFirst
   */
  export type SellingHoursComprobantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHoursComprobant
     */
    select?: SellingHoursComprobantSelect<ExtArgs> | null
    /**
     * Filter, which SellingHoursComprobant to fetch.
     */
    where?: SellingHoursComprobantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellingHoursComprobants to fetch.
     */
    orderBy?: SellingHoursComprobantOrderByWithRelationInput | SellingHoursComprobantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellingHoursComprobants.
     */
    cursor?: SellingHoursComprobantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellingHoursComprobants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellingHoursComprobants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellingHoursComprobants.
     */
    distinct?: SellingHoursComprobantScalarFieldEnum | SellingHoursComprobantScalarFieldEnum[]
  }

  /**
   * SellingHoursComprobant findFirstOrThrow
   */
  export type SellingHoursComprobantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHoursComprobant
     */
    select?: SellingHoursComprobantSelect<ExtArgs> | null
    /**
     * Filter, which SellingHoursComprobant to fetch.
     */
    where?: SellingHoursComprobantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellingHoursComprobants to fetch.
     */
    orderBy?: SellingHoursComprobantOrderByWithRelationInput | SellingHoursComprobantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellingHoursComprobants.
     */
    cursor?: SellingHoursComprobantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellingHoursComprobants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellingHoursComprobants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellingHoursComprobants.
     */
    distinct?: SellingHoursComprobantScalarFieldEnum | SellingHoursComprobantScalarFieldEnum[]
  }

  /**
   * SellingHoursComprobant findMany
   */
  export type SellingHoursComprobantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHoursComprobant
     */
    select?: SellingHoursComprobantSelect<ExtArgs> | null
    /**
     * Filter, which SellingHoursComprobants to fetch.
     */
    where?: SellingHoursComprobantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellingHoursComprobants to fetch.
     */
    orderBy?: SellingHoursComprobantOrderByWithRelationInput | SellingHoursComprobantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SellingHoursComprobants.
     */
    cursor?: SellingHoursComprobantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellingHoursComprobants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellingHoursComprobants.
     */
    skip?: number
    distinct?: SellingHoursComprobantScalarFieldEnum | SellingHoursComprobantScalarFieldEnum[]
  }

  /**
   * SellingHoursComprobant create
   */
  export type SellingHoursComprobantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHoursComprobant
     */
    select?: SellingHoursComprobantSelect<ExtArgs> | null
    /**
     * The data needed to create a SellingHoursComprobant.
     */
    data: XOR<SellingHoursComprobantCreateInput, SellingHoursComprobantUncheckedCreateInput>
  }

  /**
   * SellingHoursComprobant createMany
   */
  export type SellingHoursComprobantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SellingHoursComprobants.
     */
    data: SellingHoursComprobantCreateManyInput | SellingHoursComprobantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SellingHoursComprobant createManyAndReturn
   */
  export type SellingHoursComprobantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHoursComprobant
     */
    select?: SellingHoursComprobantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SellingHoursComprobants.
     */
    data: SellingHoursComprobantCreateManyInput | SellingHoursComprobantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SellingHoursComprobant update
   */
  export type SellingHoursComprobantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHoursComprobant
     */
    select?: SellingHoursComprobantSelect<ExtArgs> | null
    /**
     * The data needed to update a SellingHoursComprobant.
     */
    data: XOR<SellingHoursComprobantUpdateInput, SellingHoursComprobantUncheckedUpdateInput>
    /**
     * Choose, which SellingHoursComprobant to update.
     */
    where: SellingHoursComprobantWhereUniqueInput
  }

  /**
   * SellingHoursComprobant updateMany
   */
  export type SellingHoursComprobantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SellingHoursComprobants.
     */
    data: XOR<SellingHoursComprobantUpdateManyMutationInput, SellingHoursComprobantUncheckedUpdateManyInput>
    /**
     * Filter which SellingHoursComprobants to update
     */
    where?: SellingHoursComprobantWhereInput
  }

  /**
   * SellingHoursComprobant upsert
   */
  export type SellingHoursComprobantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHoursComprobant
     */
    select?: SellingHoursComprobantSelect<ExtArgs> | null
    /**
     * The filter to search for the SellingHoursComprobant to update in case it exists.
     */
    where: SellingHoursComprobantWhereUniqueInput
    /**
     * In case the SellingHoursComprobant found by the `where` argument doesn't exist, create a new SellingHoursComprobant with this data.
     */
    create: XOR<SellingHoursComprobantCreateInput, SellingHoursComprobantUncheckedCreateInput>
    /**
     * In case the SellingHoursComprobant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SellingHoursComprobantUpdateInput, SellingHoursComprobantUncheckedUpdateInput>
  }

  /**
   * SellingHoursComprobant delete
   */
  export type SellingHoursComprobantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHoursComprobant
     */
    select?: SellingHoursComprobantSelect<ExtArgs> | null
    /**
     * Filter which SellingHoursComprobant to delete.
     */
    where: SellingHoursComprobantWhereUniqueInput
  }

  /**
   * SellingHoursComprobant deleteMany
   */
  export type SellingHoursComprobantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellingHoursComprobants to delete
     */
    where?: SellingHoursComprobantWhereInput
  }

  /**
   * SellingHoursComprobant without action
   */
  export type SellingHoursComprobantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHoursComprobant
     */
    select?: SellingHoursComprobantSelect<ExtArgs> | null
  }


  /**
   * Model Holiday
   */

  export type AggregateHoliday = {
    _count: HolidayCountAggregateOutputType | null
    _avg: HolidayAvgAggregateOutputType | null
    _sum: HolidaySumAggregateOutputType | null
    _min: HolidayMinAggregateOutputType | null
    _max: HolidayMaxAggregateOutputType | null
  }

  export type HolidayAvgAggregateOutputType = {
    id: number | null
    day: number | null
    month: number | null
  }

  export type HolidaySumAggregateOutputType = {
    id: number | null
    day: number | null
    month: number | null
  }

  export type HolidayMinAggregateOutputType = {
    id: number | null
    identifier: string | null
    name: string | null
    type: string | null
    infoUrl: string | null
    day: number | null
    month: number | null
    original: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HolidayMaxAggregateOutputType = {
    id: number | null
    identifier: string | null
    name: string | null
    type: string | null
    infoUrl: string | null
    day: number | null
    month: number | null
    original: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HolidayCountAggregateOutputType = {
    id: number
    identifier: number
    name: number
    type: number
    infoUrl: number
    day: number
    month: number
    original: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HolidayAvgAggregateInputType = {
    id?: true
    day?: true
    month?: true
  }

  export type HolidaySumAggregateInputType = {
    id?: true
    day?: true
    month?: true
  }

  export type HolidayMinAggregateInputType = {
    id?: true
    identifier?: true
    name?: true
    type?: true
    infoUrl?: true
    day?: true
    month?: true
    original?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HolidayMaxAggregateInputType = {
    id?: true
    identifier?: true
    name?: true
    type?: true
    infoUrl?: true
    day?: true
    month?: true
    original?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HolidayCountAggregateInputType = {
    id?: true
    identifier?: true
    name?: true
    type?: true
    infoUrl?: true
    day?: true
    month?: true
    original?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HolidayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Holiday to aggregate.
     */
    where?: HolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holidays to fetch.
     */
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Holidays
    **/
    _count?: true | HolidayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HolidayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HolidaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HolidayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HolidayMaxAggregateInputType
  }

  export type GetHolidayAggregateType<T extends HolidayAggregateArgs> = {
        [P in keyof T & keyof AggregateHoliday]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHoliday[P]>
      : GetScalarType<T[P], AggregateHoliday[P]>
  }




  export type HolidayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HolidayWhereInput
    orderBy?: HolidayOrderByWithAggregationInput | HolidayOrderByWithAggregationInput[]
    by: HolidayScalarFieldEnum[] | HolidayScalarFieldEnum
    having?: HolidayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HolidayCountAggregateInputType | true
    _avg?: HolidayAvgAggregateInputType
    _sum?: HolidaySumAggregateInputType
    _min?: HolidayMinAggregateInputType
    _max?: HolidayMaxAggregateInputType
  }

  export type HolidayGroupByOutputType = {
    id: number
    identifier: string
    name: string
    type: string
    infoUrl: string | null
    day: number
    month: number
    original: string | null
    createdAt: Date
    updatedAt: Date
    _count: HolidayCountAggregateOutputType | null
    _avg: HolidayAvgAggregateOutputType | null
    _sum: HolidaySumAggregateOutputType | null
    _min: HolidayMinAggregateOutputType | null
    _max: HolidayMaxAggregateOutputType | null
  }

  type GetHolidayGroupByPayload<T extends HolidayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HolidayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HolidayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HolidayGroupByOutputType[P]>
            : GetScalarType<T[P], HolidayGroupByOutputType[P]>
        }
      >
    >


  export type HolidaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    name?: boolean
    type?: boolean
    infoUrl?: boolean
    day?: boolean
    month?: boolean
    original?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["holiday"]>

  export type HolidaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    name?: boolean
    type?: boolean
    infoUrl?: boolean
    day?: boolean
    month?: boolean
    original?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["holiday"]>

  export type HolidaySelectScalar = {
    id?: boolean
    identifier?: boolean
    name?: boolean
    type?: boolean
    infoUrl?: boolean
    day?: boolean
    month?: boolean
    original?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $HolidayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Holiday"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      identifier: string
      name: string
      type: string
      infoUrl: string | null
      day: number
      month: number
      original: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["holiday"]>
    composites: {}
  }

  type HolidayGetPayload<S extends boolean | null | undefined | HolidayDefaultArgs> = $Result.GetResult<Prisma.$HolidayPayload, S>

  type HolidayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HolidayFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HolidayCountAggregateInputType | true
    }

  export interface HolidayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Holiday'], meta: { name: 'Holiday' } }
    /**
     * Find zero or one Holiday that matches the filter.
     * @param {HolidayFindUniqueArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HolidayFindUniqueArgs>(args: SelectSubset<T, HolidayFindUniqueArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Holiday that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HolidayFindUniqueOrThrowArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HolidayFindUniqueOrThrowArgs>(args: SelectSubset<T, HolidayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Holiday that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayFindFirstArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HolidayFindFirstArgs>(args?: SelectSubset<T, HolidayFindFirstArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Holiday that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayFindFirstOrThrowArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HolidayFindFirstOrThrowArgs>(args?: SelectSubset<T, HolidayFindFirstOrThrowArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Holidays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Holidays
     * const holidays = await prisma.holiday.findMany()
     * 
     * // Get first 10 Holidays
     * const holidays = await prisma.holiday.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const holidayWithIdOnly = await prisma.holiday.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HolidayFindManyArgs>(args?: SelectSubset<T, HolidayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Holiday.
     * @param {HolidayCreateArgs} args - Arguments to create a Holiday.
     * @example
     * // Create one Holiday
     * const Holiday = await prisma.holiday.create({
     *   data: {
     *     // ... data to create a Holiday
     *   }
     * })
     * 
     */
    create<T extends HolidayCreateArgs>(args: SelectSubset<T, HolidayCreateArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Holidays.
     * @param {HolidayCreateManyArgs} args - Arguments to create many Holidays.
     * @example
     * // Create many Holidays
     * const holiday = await prisma.holiday.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HolidayCreateManyArgs>(args?: SelectSubset<T, HolidayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Holidays and returns the data saved in the database.
     * @param {HolidayCreateManyAndReturnArgs} args - Arguments to create many Holidays.
     * @example
     * // Create many Holidays
     * const holiday = await prisma.holiday.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Holidays and only return the `id`
     * const holidayWithIdOnly = await prisma.holiday.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HolidayCreateManyAndReturnArgs>(args?: SelectSubset<T, HolidayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Holiday.
     * @param {HolidayDeleteArgs} args - Arguments to delete one Holiday.
     * @example
     * // Delete one Holiday
     * const Holiday = await prisma.holiday.delete({
     *   where: {
     *     // ... filter to delete one Holiday
     *   }
     * })
     * 
     */
    delete<T extends HolidayDeleteArgs>(args: SelectSubset<T, HolidayDeleteArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Holiday.
     * @param {HolidayUpdateArgs} args - Arguments to update one Holiday.
     * @example
     * // Update one Holiday
     * const holiday = await prisma.holiday.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HolidayUpdateArgs>(args: SelectSubset<T, HolidayUpdateArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Holidays.
     * @param {HolidayDeleteManyArgs} args - Arguments to filter Holidays to delete.
     * @example
     * // Delete a few Holidays
     * const { count } = await prisma.holiday.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HolidayDeleteManyArgs>(args?: SelectSubset<T, HolidayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Holidays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Holidays
     * const holiday = await prisma.holiday.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HolidayUpdateManyArgs>(args: SelectSubset<T, HolidayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Holiday.
     * @param {HolidayUpsertArgs} args - Arguments to update or create a Holiday.
     * @example
     * // Update or create a Holiday
     * const holiday = await prisma.holiday.upsert({
     *   create: {
     *     // ... data to create a Holiday
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Holiday we want to update
     *   }
     * })
     */
    upsert<T extends HolidayUpsertArgs>(args: SelectSubset<T, HolidayUpsertArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Holidays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayCountArgs} args - Arguments to filter Holidays to count.
     * @example
     * // Count the number of Holidays
     * const count = await prisma.holiday.count({
     *   where: {
     *     // ... the filter for the Holidays we want to count
     *   }
     * })
    **/
    count<T extends HolidayCountArgs>(
      args?: Subset<T, HolidayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HolidayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Holiday.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HolidayAggregateArgs>(args: Subset<T, HolidayAggregateArgs>): Prisma.PrismaPromise<GetHolidayAggregateType<T>>

    /**
     * Group by Holiday.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HolidayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HolidayGroupByArgs['orderBy'] }
        : { orderBy?: HolidayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HolidayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHolidayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Holiday model
   */
  readonly fields: HolidayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Holiday.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HolidayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Holiday model
   */ 
  interface HolidayFieldRefs {
    readonly id: FieldRef<"Holiday", 'Int'>
    readonly identifier: FieldRef<"Holiday", 'String'>
    readonly name: FieldRef<"Holiday", 'String'>
    readonly type: FieldRef<"Holiday", 'String'>
    readonly infoUrl: FieldRef<"Holiday", 'String'>
    readonly day: FieldRef<"Holiday", 'Int'>
    readonly month: FieldRef<"Holiday", 'Int'>
    readonly original: FieldRef<"Holiday", 'String'>
    readonly createdAt: FieldRef<"Holiday", 'DateTime'>
    readonly updatedAt: FieldRef<"Holiday", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Holiday findUnique
   */
  export type HolidayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Filter, which Holiday to fetch.
     */
    where: HolidayWhereUniqueInput
  }

  /**
   * Holiday findUniqueOrThrow
   */
  export type HolidayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Filter, which Holiday to fetch.
     */
    where: HolidayWhereUniqueInput
  }

  /**
   * Holiday findFirst
   */
  export type HolidayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Filter, which Holiday to fetch.
     */
    where?: HolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holidays to fetch.
     */
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Holidays.
     */
    cursor?: HolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Holidays.
     */
    distinct?: HolidayScalarFieldEnum | HolidayScalarFieldEnum[]
  }

  /**
   * Holiday findFirstOrThrow
   */
  export type HolidayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Filter, which Holiday to fetch.
     */
    where?: HolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holidays to fetch.
     */
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Holidays.
     */
    cursor?: HolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Holidays.
     */
    distinct?: HolidayScalarFieldEnum | HolidayScalarFieldEnum[]
  }

  /**
   * Holiday findMany
   */
  export type HolidayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Filter, which Holidays to fetch.
     */
    where?: HolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holidays to fetch.
     */
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Holidays.
     */
    cursor?: HolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holidays.
     */
    skip?: number
    distinct?: HolidayScalarFieldEnum | HolidayScalarFieldEnum[]
  }

  /**
   * Holiday create
   */
  export type HolidayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * The data needed to create a Holiday.
     */
    data: XOR<HolidayCreateInput, HolidayUncheckedCreateInput>
  }

  /**
   * Holiday createMany
   */
  export type HolidayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Holidays.
     */
    data: HolidayCreateManyInput | HolidayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Holiday createManyAndReturn
   */
  export type HolidayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Holidays.
     */
    data: HolidayCreateManyInput | HolidayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Holiday update
   */
  export type HolidayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * The data needed to update a Holiday.
     */
    data: XOR<HolidayUpdateInput, HolidayUncheckedUpdateInput>
    /**
     * Choose, which Holiday to update.
     */
    where: HolidayWhereUniqueInput
  }

  /**
   * Holiday updateMany
   */
  export type HolidayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Holidays.
     */
    data: XOR<HolidayUpdateManyMutationInput, HolidayUncheckedUpdateManyInput>
    /**
     * Filter which Holidays to update
     */
    where?: HolidayWhereInput
  }

  /**
   * Holiday upsert
   */
  export type HolidayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * The filter to search for the Holiday to update in case it exists.
     */
    where: HolidayWhereUniqueInput
    /**
     * In case the Holiday found by the `where` argument doesn't exist, create a new Holiday with this data.
     */
    create: XOR<HolidayCreateInput, HolidayUncheckedCreateInput>
    /**
     * In case the Holiday was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HolidayUpdateInput, HolidayUncheckedUpdateInput>
  }

  /**
   * Holiday delete
   */
  export type HolidayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Filter which Holiday to delete.
     */
    where: HolidayWhereUniqueInput
  }

  /**
   * Holiday deleteMany
   */
  export type HolidayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Holidays to delete
     */
    where?: HolidayWhereInput
  }

  /**
   * Holiday without action
   */
  export type HolidayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
  }


  /**
   * Model SellingPointHoursComprobant
   */

  export type AggregateSellingPointHoursComprobant = {
    _count: SellingPointHoursComprobantCountAggregateOutputType | null
    _avg: SellingPointHoursComprobantAvgAggregateOutputType | null
    _sum: SellingPointHoursComprobantSumAggregateOutputType | null
    _min: SellingPointHoursComprobantMinAggregateOutputType | null
    _max: SellingPointHoursComprobantMaxAggregateOutputType | null
  }

  export type SellingPointHoursComprobantAvgAggregateOutputType = {
    id: number | null
    dni: number | null
    hours: number | null
    price: number | null
  }

  export type SellingPointHoursComprobantSumAggregateOutputType = {
    id: number | null
    dni: number | null
    hours: number | null
    price: number | null
  }

  export type SellingPointHoursComprobantMinAggregateOutputType = {
    id: number | null
    dni: number | null
    hours: number | null
    sellingPoint: string | null
    sellerName: string | null
    price: number | null
    createdAt: Date | null
  }

  export type SellingPointHoursComprobantMaxAggregateOutputType = {
    id: number | null
    dni: number | null
    hours: number | null
    sellingPoint: string | null
    sellerName: string | null
    price: number | null
    createdAt: Date | null
  }

  export type SellingPointHoursComprobantCountAggregateOutputType = {
    id: number
    dni: number
    hours: number
    sellingPoint: number
    sellerName: number
    price: number
    createdAt: number
    _all: number
  }


  export type SellingPointHoursComprobantAvgAggregateInputType = {
    id?: true
    dni?: true
    hours?: true
    price?: true
  }

  export type SellingPointHoursComprobantSumAggregateInputType = {
    id?: true
    dni?: true
    hours?: true
    price?: true
  }

  export type SellingPointHoursComprobantMinAggregateInputType = {
    id?: true
    dni?: true
    hours?: true
    sellingPoint?: true
    sellerName?: true
    price?: true
    createdAt?: true
  }

  export type SellingPointHoursComprobantMaxAggregateInputType = {
    id?: true
    dni?: true
    hours?: true
    sellingPoint?: true
    sellerName?: true
    price?: true
    createdAt?: true
  }

  export type SellingPointHoursComprobantCountAggregateInputType = {
    id?: true
    dni?: true
    hours?: true
    sellingPoint?: true
    sellerName?: true
    price?: true
    createdAt?: true
    _all?: true
  }

  export type SellingPointHoursComprobantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellingPointHoursComprobant to aggregate.
     */
    where?: SellingPointHoursComprobantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellingPointHoursComprobants to fetch.
     */
    orderBy?: SellingPointHoursComprobantOrderByWithRelationInput | SellingPointHoursComprobantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SellingPointHoursComprobantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellingPointHoursComprobants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellingPointHoursComprobants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SellingPointHoursComprobants
    **/
    _count?: true | SellingPointHoursComprobantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SellingPointHoursComprobantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SellingPointHoursComprobantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellingPointHoursComprobantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellingPointHoursComprobantMaxAggregateInputType
  }

  export type GetSellingPointHoursComprobantAggregateType<T extends SellingPointHoursComprobantAggregateArgs> = {
        [P in keyof T & keyof AggregateSellingPointHoursComprobant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSellingPointHoursComprobant[P]>
      : GetScalarType<T[P], AggregateSellingPointHoursComprobant[P]>
  }




  export type SellingPointHoursComprobantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellingPointHoursComprobantWhereInput
    orderBy?: SellingPointHoursComprobantOrderByWithAggregationInput | SellingPointHoursComprobantOrderByWithAggregationInput[]
    by: SellingPointHoursComprobantScalarFieldEnum[] | SellingPointHoursComprobantScalarFieldEnum
    having?: SellingPointHoursComprobantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellingPointHoursComprobantCountAggregateInputType | true
    _avg?: SellingPointHoursComprobantAvgAggregateInputType
    _sum?: SellingPointHoursComprobantSumAggregateInputType
    _min?: SellingPointHoursComprobantMinAggregateInputType
    _max?: SellingPointHoursComprobantMaxAggregateInputType
  }

  export type SellingPointHoursComprobantGroupByOutputType = {
    id: number
    dni: number
    hours: number
    sellingPoint: string
    sellerName: string
    price: number
    createdAt: Date
    _count: SellingPointHoursComprobantCountAggregateOutputType | null
    _avg: SellingPointHoursComprobantAvgAggregateOutputType | null
    _sum: SellingPointHoursComprobantSumAggregateOutputType | null
    _min: SellingPointHoursComprobantMinAggregateOutputType | null
    _max: SellingPointHoursComprobantMaxAggregateOutputType | null
  }

  type GetSellingPointHoursComprobantGroupByPayload<T extends SellingPointHoursComprobantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SellingPointHoursComprobantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellingPointHoursComprobantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellingPointHoursComprobantGroupByOutputType[P]>
            : GetScalarType<T[P], SellingPointHoursComprobantGroupByOutputType[P]>
        }
      >
    >


  export type SellingPointHoursComprobantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dni?: boolean
    hours?: boolean
    sellingPoint?: boolean
    sellerName?: boolean
    price?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sellingPointHoursComprobant"]>

  export type SellingPointHoursComprobantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dni?: boolean
    hours?: boolean
    sellingPoint?: boolean
    sellerName?: boolean
    price?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sellingPointHoursComprobant"]>

  export type SellingPointHoursComprobantSelectScalar = {
    id?: boolean
    dni?: boolean
    hours?: boolean
    sellingPoint?: boolean
    sellerName?: boolean
    price?: boolean
    createdAt?: boolean
  }


  export type $SellingPointHoursComprobantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SellingPointHoursComprobant"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dni: number
      hours: number
      sellingPoint: string
      sellerName: string
      price: number
      createdAt: Date
    }, ExtArgs["result"]["sellingPointHoursComprobant"]>
    composites: {}
  }

  type SellingPointHoursComprobantGetPayload<S extends boolean | null | undefined | SellingPointHoursComprobantDefaultArgs> = $Result.GetResult<Prisma.$SellingPointHoursComprobantPayload, S>

  type SellingPointHoursComprobantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SellingPointHoursComprobantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SellingPointHoursComprobantCountAggregateInputType | true
    }

  export interface SellingPointHoursComprobantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SellingPointHoursComprobant'], meta: { name: 'SellingPointHoursComprobant' } }
    /**
     * Find zero or one SellingPointHoursComprobant that matches the filter.
     * @param {SellingPointHoursComprobantFindUniqueArgs} args - Arguments to find a SellingPointHoursComprobant
     * @example
     * // Get one SellingPointHoursComprobant
     * const sellingPointHoursComprobant = await prisma.sellingPointHoursComprobant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SellingPointHoursComprobantFindUniqueArgs>(args: SelectSubset<T, SellingPointHoursComprobantFindUniqueArgs<ExtArgs>>): Prisma__SellingPointHoursComprobantClient<$Result.GetResult<Prisma.$SellingPointHoursComprobantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SellingPointHoursComprobant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SellingPointHoursComprobantFindUniqueOrThrowArgs} args - Arguments to find a SellingPointHoursComprobant
     * @example
     * // Get one SellingPointHoursComprobant
     * const sellingPointHoursComprobant = await prisma.sellingPointHoursComprobant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SellingPointHoursComprobantFindUniqueOrThrowArgs>(args: SelectSubset<T, SellingPointHoursComprobantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SellingPointHoursComprobantClient<$Result.GetResult<Prisma.$SellingPointHoursComprobantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SellingPointHoursComprobant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingPointHoursComprobantFindFirstArgs} args - Arguments to find a SellingPointHoursComprobant
     * @example
     * // Get one SellingPointHoursComprobant
     * const sellingPointHoursComprobant = await prisma.sellingPointHoursComprobant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SellingPointHoursComprobantFindFirstArgs>(args?: SelectSubset<T, SellingPointHoursComprobantFindFirstArgs<ExtArgs>>): Prisma__SellingPointHoursComprobantClient<$Result.GetResult<Prisma.$SellingPointHoursComprobantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SellingPointHoursComprobant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingPointHoursComprobantFindFirstOrThrowArgs} args - Arguments to find a SellingPointHoursComprobant
     * @example
     * // Get one SellingPointHoursComprobant
     * const sellingPointHoursComprobant = await prisma.sellingPointHoursComprobant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SellingPointHoursComprobantFindFirstOrThrowArgs>(args?: SelectSubset<T, SellingPointHoursComprobantFindFirstOrThrowArgs<ExtArgs>>): Prisma__SellingPointHoursComprobantClient<$Result.GetResult<Prisma.$SellingPointHoursComprobantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SellingPointHoursComprobants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingPointHoursComprobantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SellingPointHoursComprobants
     * const sellingPointHoursComprobants = await prisma.sellingPointHoursComprobant.findMany()
     * 
     * // Get first 10 SellingPointHoursComprobants
     * const sellingPointHoursComprobants = await prisma.sellingPointHoursComprobant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sellingPointHoursComprobantWithIdOnly = await prisma.sellingPointHoursComprobant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SellingPointHoursComprobantFindManyArgs>(args?: SelectSubset<T, SellingPointHoursComprobantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellingPointHoursComprobantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SellingPointHoursComprobant.
     * @param {SellingPointHoursComprobantCreateArgs} args - Arguments to create a SellingPointHoursComprobant.
     * @example
     * // Create one SellingPointHoursComprobant
     * const SellingPointHoursComprobant = await prisma.sellingPointHoursComprobant.create({
     *   data: {
     *     // ... data to create a SellingPointHoursComprobant
     *   }
     * })
     * 
     */
    create<T extends SellingPointHoursComprobantCreateArgs>(args: SelectSubset<T, SellingPointHoursComprobantCreateArgs<ExtArgs>>): Prisma__SellingPointHoursComprobantClient<$Result.GetResult<Prisma.$SellingPointHoursComprobantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SellingPointHoursComprobants.
     * @param {SellingPointHoursComprobantCreateManyArgs} args - Arguments to create many SellingPointHoursComprobants.
     * @example
     * // Create many SellingPointHoursComprobants
     * const sellingPointHoursComprobant = await prisma.sellingPointHoursComprobant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SellingPointHoursComprobantCreateManyArgs>(args?: SelectSubset<T, SellingPointHoursComprobantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SellingPointHoursComprobants and returns the data saved in the database.
     * @param {SellingPointHoursComprobantCreateManyAndReturnArgs} args - Arguments to create many SellingPointHoursComprobants.
     * @example
     * // Create many SellingPointHoursComprobants
     * const sellingPointHoursComprobant = await prisma.sellingPointHoursComprobant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SellingPointHoursComprobants and only return the `id`
     * const sellingPointHoursComprobantWithIdOnly = await prisma.sellingPointHoursComprobant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SellingPointHoursComprobantCreateManyAndReturnArgs>(args?: SelectSubset<T, SellingPointHoursComprobantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellingPointHoursComprobantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SellingPointHoursComprobant.
     * @param {SellingPointHoursComprobantDeleteArgs} args - Arguments to delete one SellingPointHoursComprobant.
     * @example
     * // Delete one SellingPointHoursComprobant
     * const SellingPointHoursComprobant = await prisma.sellingPointHoursComprobant.delete({
     *   where: {
     *     // ... filter to delete one SellingPointHoursComprobant
     *   }
     * })
     * 
     */
    delete<T extends SellingPointHoursComprobantDeleteArgs>(args: SelectSubset<T, SellingPointHoursComprobantDeleteArgs<ExtArgs>>): Prisma__SellingPointHoursComprobantClient<$Result.GetResult<Prisma.$SellingPointHoursComprobantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SellingPointHoursComprobant.
     * @param {SellingPointHoursComprobantUpdateArgs} args - Arguments to update one SellingPointHoursComprobant.
     * @example
     * // Update one SellingPointHoursComprobant
     * const sellingPointHoursComprobant = await prisma.sellingPointHoursComprobant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SellingPointHoursComprobantUpdateArgs>(args: SelectSubset<T, SellingPointHoursComprobantUpdateArgs<ExtArgs>>): Prisma__SellingPointHoursComprobantClient<$Result.GetResult<Prisma.$SellingPointHoursComprobantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SellingPointHoursComprobants.
     * @param {SellingPointHoursComprobantDeleteManyArgs} args - Arguments to filter SellingPointHoursComprobants to delete.
     * @example
     * // Delete a few SellingPointHoursComprobants
     * const { count } = await prisma.sellingPointHoursComprobant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SellingPointHoursComprobantDeleteManyArgs>(args?: SelectSubset<T, SellingPointHoursComprobantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellingPointHoursComprobants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingPointHoursComprobantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SellingPointHoursComprobants
     * const sellingPointHoursComprobant = await prisma.sellingPointHoursComprobant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SellingPointHoursComprobantUpdateManyArgs>(args: SelectSubset<T, SellingPointHoursComprobantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SellingPointHoursComprobant.
     * @param {SellingPointHoursComprobantUpsertArgs} args - Arguments to update or create a SellingPointHoursComprobant.
     * @example
     * // Update or create a SellingPointHoursComprobant
     * const sellingPointHoursComprobant = await prisma.sellingPointHoursComprobant.upsert({
     *   create: {
     *     // ... data to create a SellingPointHoursComprobant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SellingPointHoursComprobant we want to update
     *   }
     * })
     */
    upsert<T extends SellingPointHoursComprobantUpsertArgs>(args: SelectSubset<T, SellingPointHoursComprobantUpsertArgs<ExtArgs>>): Prisma__SellingPointHoursComprobantClient<$Result.GetResult<Prisma.$SellingPointHoursComprobantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SellingPointHoursComprobants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingPointHoursComprobantCountArgs} args - Arguments to filter SellingPointHoursComprobants to count.
     * @example
     * // Count the number of SellingPointHoursComprobants
     * const count = await prisma.sellingPointHoursComprobant.count({
     *   where: {
     *     // ... the filter for the SellingPointHoursComprobants we want to count
     *   }
     * })
    **/
    count<T extends SellingPointHoursComprobantCountArgs>(
      args?: Subset<T, SellingPointHoursComprobantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellingPointHoursComprobantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SellingPointHoursComprobant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingPointHoursComprobantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellingPointHoursComprobantAggregateArgs>(args: Subset<T, SellingPointHoursComprobantAggregateArgs>): Prisma.PrismaPromise<GetSellingPointHoursComprobantAggregateType<T>>

    /**
     * Group by SellingPointHoursComprobant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingPointHoursComprobantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellingPointHoursComprobantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellingPointHoursComprobantGroupByArgs['orderBy'] }
        : { orderBy?: SellingPointHoursComprobantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellingPointHoursComprobantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellingPointHoursComprobantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SellingPointHoursComprobant model
   */
  readonly fields: SellingPointHoursComprobantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SellingPointHoursComprobant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SellingPointHoursComprobantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SellingPointHoursComprobant model
   */ 
  interface SellingPointHoursComprobantFieldRefs {
    readonly id: FieldRef<"SellingPointHoursComprobant", 'Int'>
    readonly dni: FieldRef<"SellingPointHoursComprobant", 'Int'>
    readonly hours: FieldRef<"SellingPointHoursComprobant", 'Int'>
    readonly sellingPoint: FieldRef<"SellingPointHoursComprobant", 'String'>
    readonly sellerName: FieldRef<"SellingPointHoursComprobant", 'String'>
    readonly price: FieldRef<"SellingPointHoursComprobant", 'Int'>
    readonly createdAt: FieldRef<"SellingPointHoursComprobant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SellingPointHoursComprobant findUnique
   */
  export type SellingPointHoursComprobantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingPointHoursComprobant
     */
    select?: SellingPointHoursComprobantSelect<ExtArgs> | null
    /**
     * Filter, which SellingPointHoursComprobant to fetch.
     */
    where: SellingPointHoursComprobantWhereUniqueInput
  }

  /**
   * SellingPointHoursComprobant findUniqueOrThrow
   */
  export type SellingPointHoursComprobantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingPointHoursComprobant
     */
    select?: SellingPointHoursComprobantSelect<ExtArgs> | null
    /**
     * Filter, which SellingPointHoursComprobant to fetch.
     */
    where: SellingPointHoursComprobantWhereUniqueInput
  }

  /**
   * SellingPointHoursComprobant findFirst
   */
  export type SellingPointHoursComprobantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingPointHoursComprobant
     */
    select?: SellingPointHoursComprobantSelect<ExtArgs> | null
    /**
     * Filter, which SellingPointHoursComprobant to fetch.
     */
    where?: SellingPointHoursComprobantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellingPointHoursComprobants to fetch.
     */
    orderBy?: SellingPointHoursComprobantOrderByWithRelationInput | SellingPointHoursComprobantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellingPointHoursComprobants.
     */
    cursor?: SellingPointHoursComprobantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellingPointHoursComprobants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellingPointHoursComprobants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellingPointHoursComprobants.
     */
    distinct?: SellingPointHoursComprobantScalarFieldEnum | SellingPointHoursComprobantScalarFieldEnum[]
  }

  /**
   * SellingPointHoursComprobant findFirstOrThrow
   */
  export type SellingPointHoursComprobantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingPointHoursComprobant
     */
    select?: SellingPointHoursComprobantSelect<ExtArgs> | null
    /**
     * Filter, which SellingPointHoursComprobant to fetch.
     */
    where?: SellingPointHoursComprobantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellingPointHoursComprobants to fetch.
     */
    orderBy?: SellingPointHoursComprobantOrderByWithRelationInput | SellingPointHoursComprobantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellingPointHoursComprobants.
     */
    cursor?: SellingPointHoursComprobantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellingPointHoursComprobants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellingPointHoursComprobants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellingPointHoursComprobants.
     */
    distinct?: SellingPointHoursComprobantScalarFieldEnum | SellingPointHoursComprobantScalarFieldEnum[]
  }

  /**
   * SellingPointHoursComprobant findMany
   */
  export type SellingPointHoursComprobantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingPointHoursComprobant
     */
    select?: SellingPointHoursComprobantSelect<ExtArgs> | null
    /**
     * Filter, which SellingPointHoursComprobants to fetch.
     */
    where?: SellingPointHoursComprobantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellingPointHoursComprobants to fetch.
     */
    orderBy?: SellingPointHoursComprobantOrderByWithRelationInput | SellingPointHoursComprobantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SellingPointHoursComprobants.
     */
    cursor?: SellingPointHoursComprobantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellingPointHoursComprobants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellingPointHoursComprobants.
     */
    skip?: number
    distinct?: SellingPointHoursComprobantScalarFieldEnum | SellingPointHoursComprobantScalarFieldEnum[]
  }

  /**
   * SellingPointHoursComprobant create
   */
  export type SellingPointHoursComprobantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingPointHoursComprobant
     */
    select?: SellingPointHoursComprobantSelect<ExtArgs> | null
    /**
     * The data needed to create a SellingPointHoursComprobant.
     */
    data: XOR<SellingPointHoursComprobantCreateInput, SellingPointHoursComprobantUncheckedCreateInput>
  }

  /**
   * SellingPointHoursComprobant createMany
   */
  export type SellingPointHoursComprobantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SellingPointHoursComprobants.
     */
    data: SellingPointHoursComprobantCreateManyInput | SellingPointHoursComprobantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SellingPointHoursComprobant createManyAndReturn
   */
  export type SellingPointHoursComprobantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingPointHoursComprobant
     */
    select?: SellingPointHoursComprobantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SellingPointHoursComprobants.
     */
    data: SellingPointHoursComprobantCreateManyInput | SellingPointHoursComprobantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SellingPointHoursComprobant update
   */
  export type SellingPointHoursComprobantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingPointHoursComprobant
     */
    select?: SellingPointHoursComprobantSelect<ExtArgs> | null
    /**
     * The data needed to update a SellingPointHoursComprobant.
     */
    data: XOR<SellingPointHoursComprobantUpdateInput, SellingPointHoursComprobantUncheckedUpdateInput>
    /**
     * Choose, which SellingPointHoursComprobant to update.
     */
    where: SellingPointHoursComprobantWhereUniqueInput
  }

  /**
   * SellingPointHoursComprobant updateMany
   */
  export type SellingPointHoursComprobantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SellingPointHoursComprobants.
     */
    data: XOR<SellingPointHoursComprobantUpdateManyMutationInput, SellingPointHoursComprobantUncheckedUpdateManyInput>
    /**
     * Filter which SellingPointHoursComprobants to update
     */
    where?: SellingPointHoursComprobantWhereInput
  }

  /**
   * SellingPointHoursComprobant upsert
   */
  export type SellingPointHoursComprobantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingPointHoursComprobant
     */
    select?: SellingPointHoursComprobantSelect<ExtArgs> | null
    /**
     * The filter to search for the SellingPointHoursComprobant to update in case it exists.
     */
    where: SellingPointHoursComprobantWhereUniqueInput
    /**
     * In case the SellingPointHoursComprobant found by the `where` argument doesn't exist, create a new SellingPointHoursComprobant with this data.
     */
    create: XOR<SellingPointHoursComprobantCreateInput, SellingPointHoursComprobantUncheckedCreateInput>
    /**
     * In case the SellingPointHoursComprobant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SellingPointHoursComprobantUpdateInput, SellingPointHoursComprobantUncheckedUpdateInput>
  }

  /**
   * SellingPointHoursComprobant delete
   */
  export type SellingPointHoursComprobantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingPointHoursComprobant
     */
    select?: SellingPointHoursComprobantSelect<ExtArgs> | null
    /**
     * Filter which SellingPointHoursComprobant to delete.
     */
    where: SellingPointHoursComprobantWhereUniqueInput
  }

  /**
   * SellingPointHoursComprobant deleteMany
   */
  export type SellingPointHoursComprobantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellingPointHoursComprobants to delete
     */
    where?: SellingPointHoursComprobantWhereInput
  }

  /**
   * SellingPointHoursComprobant without action
   */
  export type SellingPointHoursComprobantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingPointHoursComprobant
     */
    select?: SellingPointHoursComprobantSelect<ExtArgs> | null
  }


  /**
   * Model SellingMonthlyComprobant
   */

  export type AggregateSellingMonthlyComprobant = {
    _count: SellingMonthlyComprobantCountAggregateOutputType | null
    _avg: SellingMonthlyComprobantAvgAggregateOutputType | null
    _sum: SellingMonthlyComprobantSumAggregateOutputType | null
    _min: SellingMonthlyComprobantMinAggregateOutputType | null
    _max: SellingMonthlyComprobantMaxAggregateOutputType | null
  }

  export type SellingMonthlyComprobantAvgAggregateOutputType = {
    id: number | null
    dni: number | null
    totalPrice: number | null
    soldBy: number | null
  }

  export type SellingMonthlyComprobantSumAggregateOutputType = {
    id: number | null
    dni: number | null
    totalPrice: number | null
    soldBy: number | null
  }

  export type SellingMonthlyComprobantMinAggregateOutputType = {
    id: number | null
    dni: number | null
    patentId: string | null
    createdAt: Date | null
    finishedAt: Date | null
    totalPrice: number | null
    soldBy: number | null
  }

  export type SellingMonthlyComprobantMaxAggregateOutputType = {
    id: number | null
    dni: number | null
    patentId: string | null
    createdAt: Date | null
    finishedAt: Date | null
    totalPrice: number | null
    soldBy: number | null
  }

  export type SellingMonthlyComprobantCountAggregateOutputType = {
    id: number
    dni: number
    patentId: number
    createdAt: number
    finishedAt: number
    totalPrice: number
    soldBy: number
    _all: number
  }


  export type SellingMonthlyComprobantAvgAggregateInputType = {
    id?: true
    dni?: true
    totalPrice?: true
    soldBy?: true
  }

  export type SellingMonthlyComprobantSumAggregateInputType = {
    id?: true
    dni?: true
    totalPrice?: true
    soldBy?: true
  }

  export type SellingMonthlyComprobantMinAggregateInputType = {
    id?: true
    dni?: true
    patentId?: true
    createdAt?: true
    finishedAt?: true
    totalPrice?: true
    soldBy?: true
  }

  export type SellingMonthlyComprobantMaxAggregateInputType = {
    id?: true
    dni?: true
    patentId?: true
    createdAt?: true
    finishedAt?: true
    totalPrice?: true
    soldBy?: true
  }

  export type SellingMonthlyComprobantCountAggregateInputType = {
    id?: true
    dni?: true
    patentId?: true
    createdAt?: true
    finishedAt?: true
    totalPrice?: true
    soldBy?: true
    _all?: true
  }

  export type SellingMonthlyComprobantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellingMonthlyComprobant to aggregate.
     */
    where?: SellingMonthlyComprobantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellingMonthlyComprobants to fetch.
     */
    orderBy?: SellingMonthlyComprobantOrderByWithRelationInput | SellingMonthlyComprobantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SellingMonthlyComprobantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellingMonthlyComprobants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellingMonthlyComprobants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SellingMonthlyComprobants
    **/
    _count?: true | SellingMonthlyComprobantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SellingMonthlyComprobantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SellingMonthlyComprobantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellingMonthlyComprobantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellingMonthlyComprobantMaxAggregateInputType
  }

  export type GetSellingMonthlyComprobantAggregateType<T extends SellingMonthlyComprobantAggregateArgs> = {
        [P in keyof T & keyof AggregateSellingMonthlyComprobant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSellingMonthlyComprobant[P]>
      : GetScalarType<T[P], AggregateSellingMonthlyComprobant[P]>
  }




  export type SellingMonthlyComprobantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellingMonthlyComprobantWhereInput
    orderBy?: SellingMonthlyComprobantOrderByWithAggregationInput | SellingMonthlyComprobantOrderByWithAggregationInput[]
    by: SellingMonthlyComprobantScalarFieldEnum[] | SellingMonthlyComprobantScalarFieldEnum
    having?: SellingMonthlyComprobantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellingMonthlyComprobantCountAggregateInputType | true
    _avg?: SellingMonthlyComprobantAvgAggregateInputType
    _sum?: SellingMonthlyComprobantSumAggregateInputType
    _min?: SellingMonthlyComprobantMinAggregateInputType
    _max?: SellingMonthlyComprobantMaxAggregateInputType
  }

  export type SellingMonthlyComprobantGroupByOutputType = {
    id: number
    dni: number
    patentId: string
    createdAt: Date
    finishedAt: Date | null
    totalPrice: number
    soldBy: number
    _count: SellingMonthlyComprobantCountAggregateOutputType | null
    _avg: SellingMonthlyComprobantAvgAggregateOutputType | null
    _sum: SellingMonthlyComprobantSumAggregateOutputType | null
    _min: SellingMonthlyComprobantMinAggregateOutputType | null
    _max: SellingMonthlyComprobantMaxAggregateOutputType | null
  }

  type GetSellingMonthlyComprobantGroupByPayload<T extends SellingMonthlyComprobantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SellingMonthlyComprobantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellingMonthlyComprobantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellingMonthlyComprobantGroupByOutputType[P]>
            : GetScalarType<T[P], SellingMonthlyComprobantGroupByOutputType[P]>
        }
      >
    >


  export type SellingMonthlyComprobantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dni?: boolean
    patentId?: boolean
    createdAt?: boolean
    finishedAt?: boolean
    totalPrice?: boolean
    soldBy?: boolean
  }, ExtArgs["result"]["sellingMonthlyComprobant"]>

  export type SellingMonthlyComprobantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dni?: boolean
    patentId?: boolean
    createdAt?: boolean
    finishedAt?: boolean
    totalPrice?: boolean
    soldBy?: boolean
  }, ExtArgs["result"]["sellingMonthlyComprobant"]>

  export type SellingMonthlyComprobantSelectScalar = {
    id?: boolean
    dni?: boolean
    patentId?: boolean
    createdAt?: boolean
    finishedAt?: boolean
    totalPrice?: boolean
    soldBy?: boolean
  }


  export type $SellingMonthlyComprobantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SellingMonthlyComprobant"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dni: number
      patentId: string
      createdAt: Date
      finishedAt: Date | null
      totalPrice: number
      soldBy: number
    }, ExtArgs["result"]["sellingMonthlyComprobant"]>
    composites: {}
  }

  type SellingMonthlyComprobantGetPayload<S extends boolean | null | undefined | SellingMonthlyComprobantDefaultArgs> = $Result.GetResult<Prisma.$SellingMonthlyComprobantPayload, S>

  type SellingMonthlyComprobantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SellingMonthlyComprobantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SellingMonthlyComprobantCountAggregateInputType | true
    }

  export interface SellingMonthlyComprobantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SellingMonthlyComprobant'], meta: { name: 'SellingMonthlyComprobant' } }
    /**
     * Find zero or one SellingMonthlyComprobant that matches the filter.
     * @param {SellingMonthlyComprobantFindUniqueArgs} args - Arguments to find a SellingMonthlyComprobant
     * @example
     * // Get one SellingMonthlyComprobant
     * const sellingMonthlyComprobant = await prisma.sellingMonthlyComprobant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SellingMonthlyComprobantFindUniqueArgs>(args: SelectSubset<T, SellingMonthlyComprobantFindUniqueArgs<ExtArgs>>): Prisma__SellingMonthlyComprobantClient<$Result.GetResult<Prisma.$SellingMonthlyComprobantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SellingMonthlyComprobant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SellingMonthlyComprobantFindUniqueOrThrowArgs} args - Arguments to find a SellingMonthlyComprobant
     * @example
     * // Get one SellingMonthlyComprobant
     * const sellingMonthlyComprobant = await prisma.sellingMonthlyComprobant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SellingMonthlyComprobantFindUniqueOrThrowArgs>(args: SelectSubset<T, SellingMonthlyComprobantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SellingMonthlyComprobantClient<$Result.GetResult<Prisma.$SellingMonthlyComprobantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SellingMonthlyComprobant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingMonthlyComprobantFindFirstArgs} args - Arguments to find a SellingMonthlyComprobant
     * @example
     * // Get one SellingMonthlyComprobant
     * const sellingMonthlyComprobant = await prisma.sellingMonthlyComprobant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SellingMonthlyComprobantFindFirstArgs>(args?: SelectSubset<T, SellingMonthlyComprobantFindFirstArgs<ExtArgs>>): Prisma__SellingMonthlyComprobantClient<$Result.GetResult<Prisma.$SellingMonthlyComprobantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SellingMonthlyComprobant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingMonthlyComprobantFindFirstOrThrowArgs} args - Arguments to find a SellingMonthlyComprobant
     * @example
     * // Get one SellingMonthlyComprobant
     * const sellingMonthlyComprobant = await prisma.sellingMonthlyComprobant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SellingMonthlyComprobantFindFirstOrThrowArgs>(args?: SelectSubset<T, SellingMonthlyComprobantFindFirstOrThrowArgs<ExtArgs>>): Prisma__SellingMonthlyComprobantClient<$Result.GetResult<Prisma.$SellingMonthlyComprobantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SellingMonthlyComprobants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingMonthlyComprobantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SellingMonthlyComprobants
     * const sellingMonthlyComprobants = await prisma.sellingMonthlyComprobant.findMany()
     * 
     * // Get first 10 SellingMonthlyComprobants
     * const sellingMonthlyComprobants = await prisma.sellingMonthlyComprobant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sellingMonthlyComprobantWithIdOnly = await prisma.sellingMonthlyComprobant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SellingMonthlyComprobantFindManyArgs>(args?: SelectSubset<T, SellingMonthlyComprobantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellingMonthlyComprobantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SellingMonthlyComprobant.
     * @param {SellingMonthlyComprobantCreateArgs} args - Arguments to create a SellingMonthlyComprobant.
     * @example
     * // Create one SellingMonthlyComprobant
     * const SellingMonthlyComprobant = await prisma.sellingMonthlyComprobant.create({
     *   data: {
     *     // ... data to create a SellingMonthlyComprobant
     *   }
     * })
     * 
     */
    create<T extends SellingMonthlyComprobantCreateArgs>(args: SelectSubset<T, SellingMonthlyComprobantCreateArgs<ExtArgs>>): Prisma__SellingMonthlyComprobantClient<$Result.GetResult<Prisma.$SellingMonthlyComprobantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SellingMonthlyComprobants.
     * @param {SellingMonthlyComprobantCreateManyArgs} args - Arguments to create many SellingMonthlyComprobants.
     * @example
     * // Create many SellingMonthlyComprobants
     * const sellingMonthlyComprobant = await prisma.sellingMonthlyComprobant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SellingMonthlyComprobantCreateManyArgs>(args?: SelectSubset<T, SellingMonthlyComprobantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SellingMonthlyComprobants and returns the data saved in the database.
     * @param {SellingMonthlyComprobantCreateManyAndReturnArgs} args - Arguments to create many SellingMonthlyComprobants.
     * @example
     * // Create many SellingMonthlyComprobants
     * const sellingMonthlyComprobant = await prisma.sellingMonthlyComprobant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SellingMonthlyComprobants and only return the `id`
     * const sellingMonthlyComprobantWithIdOnly = await prisma.sellingMonthlyComprobant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SellingMonthlyComprobantCreateManyAndReturnArgs>(args?: SelectSubset<T, SellingMonthlyComprobantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellingMonthlyComprobantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SellingMonthlyComprobant.
     * @param {SellingMonthlyComprobantDeleteArgs} args - Arguments to delete one SellingMonthlyComprobant.
     * @example
     * // Delete one SellingMonthlyComprobant
     * const SellingMonthlyComprobant = await prisma.sellingMonthlyComprobant.delete({
     *   where: {
     *     // ... filter to delete one SellingMonthlyComprobant
     *   }
     * })
     * 
     */
    delete<T extends SellingMonthlyComprobantDeleteArgs>(args: SelectSubset<T, SellingMonthlyComprobantDeleteArgs<ExtArgs>>): Prisma__SellingMonthlyComprobantClient<$Result.GetResult<Prisma.$SellingMonthlyComprobantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SellingMonthlyComprobant.
     * @param {SellingMonthlyComprobantUpdateArgs} args - Arguments to update one SellingMonthlyComprobant.
     * @example
     * // Update one SellingMonthlyComprobant
     * const sellingMonthlyComprobant = await prisma.sellingMonthlyComprobant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SellingMonthlyComprobantUpdateArgs>(args: SelectSubset<T, SellingMonthlyComprobantUpdateArgs<ExtArgs>>): Prisma__SellingMonthlyComprobantClient<$Result.GetResult<Prisma.$SellingMonthlyComprobantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SellingMonthlyComprobants.
     * @param {SellingMonthlyComprobantDeleteManyArgs} args - Arguments to filter SellingMonthlyComprobants to delete.
     * @example
     * // Delete a few SellingMonthlyComprobants
     * const { count } = await prisma.sellingMonthlyComprobant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SellingMonthlyComprobantDeleteManyArgs>(args?: SelectSubset<T, SellingMonthlyComprobantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellingMonthlyComprobants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingMonthlyComprobantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SellingMonthlyComprobants
     * const sellingMonthlyComprobant = await prisma.sellingMonthlyComprobant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SellingMonthlyComprobantUpdateManyArgs>(args: SelectSubset<T, SellingMonthlyComprobantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SellingMonthlyComprobant.
     * @param {SellingMonthlyComprobantUpsertArgs} args - Arguments to update or create a SellingMonthlyComprobant.
     * @example
     * // Update or create a SellingMonthlyComprobant
     * const sellingMonthlyComprobant = await prisma.sellingMonthlyComprobant.upsert({
     *   create: {
     *     // ... data to create a SellingMonthlyComprobant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SellingMonthlyComprobant we want to update
     *   }
     * })
     */
    upsert<T extends SellingMonthlyComprobantUpsertArgs>(args: SelectSubset<T, SellingMonthlyComprobantUpsertArgs<ExtArgs>>): Prisma__SellingMonthlyComprobantClient<$Result.GetResult<Prisma.$SellingMonthlyComprobantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SellingMonthlyComprobants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingMonthlyComprobantCountArgs} args - Arguments to filter SellingMonthlyComprobants to count.
     * @example
     * // Count the number of SellingMonthlyComprobants
     * const count = await prisma.sellingMonthlyComprobant.count({
     *   where: {
     *     // ... the filter for the SellingMonthlyComprobants we want to count
     *   }
     * })
    **/
    count<T extends SellingMonthlyComprobantCountArgs>(
      args?: Subset<T, SellingMonthlyComprobantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellingMonthlyComprobantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SellingMonthlyComprobant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingMonthlyComprobantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellingMonthlyComprobantAggregateArgs>(args: Subset<T, SellingMonthlyComprobantAggregateArgs>): Prisma.PrismaPromise<GetSellingMonthlyComprobantAggregateType<T>>

    /**
     * Group by SellingMonthlyComprobant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingMonthlyComprobantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellingMonthlyComprobantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellingMonthlyComprobantGroupByArgs['orderBy'] }
        : { orderBy?: SellingMonthlyComprobantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellingMonthlyComprobantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellingMonthlyComprobantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SellingMonthlyComprobant model
   */
  readonly fields: SellingMonthlyComprobantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SellingMonthlyComprobant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SellingMonthlyComprobantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SellingMonthlyComprobant model
   */ 
  interface SellingMonthlyComprobantFieldRefs {
    readonly id: FieldRef<"SellingMonthlyComprobant", 'Int'>
    readonly dni: FieldRef<"SellingMonthlyComprobant", 'Int'>
    readonly patentId: FieldRef<"SellingMonthlyComprobant", 'String'>
    readonly createdAt: FieldRef<"SellingMonthlyComprobant", 'DateTime'>
    readonly finishedAt: FieldRef<"SellingMonthlyComprobant", 'DateTime'>
    readonly totalPrice: FieldRef<"SellingMonthlyComprobant", 'Int'>
    readonly soldBy: FieldRef<"SellingMonthlyComprobant", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SellingMonthlyComprobant findUnique
   */
  export type SellingMonthlyComprobantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingMonthlyComprobant
     */
    select?: SellingMonthlyComprobantSelect<ExtArgs> | null
    /**
     * Filter, which SellingMonthlyComprobant to fetch.
     */
    where: SellingMonthlyComprobantWhereUniqueInput
  }

  /**
   * SellingMonthlyComprobant findUniqueOrThrow
   */
  export type SellingMonthlyComprobantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingMonthlyComprobant
     */
    select?: SellingMonthlyComprobantSelect<ExtArgs> | null
    /**
     * Filter, which SellingMonthlyComprobant to fetch.
     */
    where: SellingMonthlyComprobantWhereUniqueInput
  }

  /**
   * SellingMonthlyComprobant findFirst
   */
  export type SellingMonthlyComprobantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingMonthlyComprobant
     */
    select?: SellingMonthlyComprobantSelect<ExtArgs> | null
    /**
     * Filter, which SellingMonthlyComprobant to fetch.
     */
    where?: SellingMonthlyComprobantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellingMonthlyComprobants to fetch.
     */
    orderBy?: SellingMonthlyComprobantOrderByWithRelationInput | SellingMonthlyComprobantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellingMonthlyComprobants.
     */
    cursor?: SellingMonthlyComprobantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellingMonthlyComprobants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellingMonthlyComprobants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellingMonthlyComprobants.
     */
    distinct?: SellingMonthlyComprobantScalarFieldEnum | SellingMonthlyComprobantScalarFieldEnum[]
  }

  /**
   * SellingMonthlyComprobant findFirstOrThrow
   */
  export type SellingMonthlyComprobantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingMonthlyComprobant
     */
    select?: SellingMonthlyComprobantSelect<ExtArgs> | null
    /**
     * Filter, which SellingMonthlyComprobant to fetch.
     */
    where?: SellingMonthlyComprobantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellingMonthlyComprobants to fetch.
     */
    orderBy?: SellingMonthlyComprobantOrderByWithRelationInput | SellingMonthlyComprobantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellingMonthlyComprobants.
     */
    cursor?: SellingMonthlyComprobantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellingMonthlyComprobants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellingMonthlyComprobants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellingMonthlyComprobants.
     */
    distinct?: SellingMonthlyComprobantScalarFieldEnum | SellingMonthlyComprobantScalarFieldEnum[]
  }

  /**
   * SellingMonthlyComprobant findMany
   */
  export type SellingMonthlyComprobantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingMonthlyComprobant
     */
    select?: SellingMonthlyComprobantSelect<ExtArgs> | null
    /**
     * Filter, which SellingMonthlyComprobants to fetch.
     */
    where?: SellingMonthlyComprobantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellingMonthlyComprobants to fetch.
     */
    orderBy?: SellingMonthlyComprobantOrderByWithRelationInput | SellingMonthlyComprobantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SellingMonthlyComprobants.
     */
    cursor?: SellingMonthlyComprobantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellingMonthlyComprobants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellingMonthlyComprobants.
     */
    skip?: number
    distinct?: SellingMonthlyComprobantScalarFieldEnum | SellingMonthlyComprobantScalarFieldEnum[]
  }

  /**
   * SellingMonthlyComprobant create
   */
  export type SellingMonthlyComprobantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingMonthlyComprobant
     */
    select?: SellingMonthlyComprobantSelect<ExtArgs> | null
    /**
     * The data needed to create a SellingMonthlyComprobant.
     */
    data: XOR<SellingMonthlyComprobantCreateInput, SellingMonthlyComprobantUncheckedCreateInput>
  }

  /**
   * SellingMonthlyComprobant createMany
   */
  export type SellingMonthlyComprobantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SellingMonthlyComprobants.
     */
    data: SellingMonthlyComprobantCreateManyInput | SellingMonthlyComprobantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SellingMonthlyComprobant createManyAndReturn
   */
  export type SellingMonthlyComprobantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingMonthlyComprobant
     */
    select?: SellingMonthlyComprobantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SellingMonthlyComprobants.
     */
    data: SellingMonthlyComprobantCreateManyInput | SellingMonthlyComprobantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SellingMonthlyComprobant update
   */
  export type SellingMonthlyComprobantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingMonthlyComprobant
     */
    select?: SellingMonthlyComprobantSelect<ExtArgs> | null
    /**
     * The data needed to update a SellingMonthlyComprobant.
     */
    data: XOR<SellingMonthlyComprobantUpdateInput, SellingMonthlyComprobantUncheckedUpdateInput>
    /**
     * Choose, which SellingMonthlyComprobant to update.
     */
    where: SellingMonthlyComprobantWhereUniqueInput
  }

  /**
   * SellingMonthlyComprobant updateMany
   */
  export type SellingMonthlyComprobantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SellingMonthlyComprobants.
     */
    data: XOR<SellingMonthlyComprobantUpdateManyMutationInput, SellingMonthlyComprobantUncheckedUpdateManyInput>
    /**
     * Filter which SellingMonthlyComprobants to update
     */
    where?: SellingMonthlyComprobantWhereInput
  }

  /**
   * SellingMonthlyComprobant upsert
   */
  export type SellingMonthlyComprobantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingMonthlyComprobant
     */
    select?: SellingMonthlyComprobantSelect<ExtArgs> | null
    /**
     * The filter to search for the SellingMonthlyComprobant to update in case it exists.
     */
    where: SellingMonthlyComprobantWhereUniqueInput
    /**
     * In case the SellingMonthlyComprobant found by the `where` argument doesn't exist, create a new SellingMonthlyComprobant with this data.
     */
    create: XOR<SellingMonthlyComprobantCreateInput, SellingMonthlyComprobantUncheckedCreateInput>
    /**
     * In case the SellingMonthlyComprobant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SellingMonthlyComprobantUpdateInput, SellingMonthlyComprobantUncheckedUpdateInput>
  }

  /**
   * SellingMonthlyComprobant delete
   */
  export type SellingMonthlyComprobantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingMonthlyComprobant
     */
    select?: SellingMonthlyComprobantSelect<ExtArgs> | null
    /**
     * Filter which SellingMonthlyComprobant to delete.
     */
    where: SellingMonthlyComprobantWhereUniqueInput
  }

  /**
   * SellingMonthlyComprobant deleteMany
   */
  export type SellingMonthlyComprobantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellingMonthlyComprobants to delete
     */
    where?: SellingMonthlyComprobantWhereInput
  }

  /**
   * SellingMonthlyComprobant without action
   */
  export type SellingMonthlyComprobantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingMonthlyComprobant
     */
    select?: SellingMonthlyComprobantSelect<ExtArgs> | null
  }


  /**
   * Model Movie
   */

  export type AggregateMovie = {
    _count: MovieCountAggregateOutputType | null
    _avg: MovieAvgAggregateOutputType | null
    _sum: MovieSumAggregateOutputType | null
    _min: MovieMinAggregateOutputType | null
    _max: MovieMaxAggregateOutputType | null
  }

  export type MovieAvgAggregateOutputType = {
    durationMinutes: number | null
  }

  export type MovieSumAggregateOutputType = {
    durationMinutes: number | null
  }

  export type MovieMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    durationMinutes: number | null
    language: string | null
    format: $Enums.Format | null
    posterUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MovieMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    durationMinutes: number | null
    language: string | null
    format: $Enums.Format | null
    posterUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MovieCountAggregateOutputType = {
    id: number
    title: number
    description: number
    durationMinutes: number
    language: number
    format: number
    posterUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MovieAvgAggregateInputType = {
    durationMinutes?: true
  }

  export type MovieSumAggregateInputType = {
    durationMinutes?: true
  }

  export type MovieMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    durationMinutes?: true
    language?: true
    format?: true
    posterUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MovieMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    durationMinutes?: true
    language?: true
    format?: true
    posterUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MovieCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    durationMinutes?: true
    language?: true
    format?: true
    posterUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MovieAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Movie to aggregate.
     */
    where?: MovieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movies to fetch.
     */
    orderBy?: MovieOrderByWithRelationInput | MovieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MovieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Movies
    **/
    _count?: true | MovieCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MovieAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MovieSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MovieMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MovieMaxAggregateInputType
  }

  export type GetMovieAggregateType<T extends MovieAggregateArgs> = {
        [P in keyof T & keyof AggregateMovie]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovie[P]>
      : GetScalarType<T[P], AggregateMovie[P]>
  }




  export type MovieGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieWhereInput
    orderBy?: MovieOrderByWithAggregationInput | MovieOrderByWithAggregationInput[]
    by: MovieScalarFieldEnum[] | MovieScalarFieldEnum
    having?: MovieScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MovieCountAggregateInputType | true
    _avg?: MovieAvgAggregateInputType
    _sum?: MovieSumAggregateInputType
    _min?: MovieMinAggregateInputType
    _max?: MovieMaxAggregateInputType
  }

  export type MovieGroupByOutputType = {
    id: string
    title: string
    description: string
    durationMinutes: number
    language: string
    format: $Enums.Format
    posterUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: MovieCountAggregateOutputType | null
    _avg: MovieAvgAggregateOutputType | null
    _sum: MovieSumAggregateOutputType | null
    _min: MovieMinAggregateOutputType | null
    _max: MovieMaxAggregateOutputType | null
  }

  type GetMovieGroupByPayload<T extends MovieGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MovieGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MovieGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MovieGroupByOutputType[P]>
            : GetScalarType<T[P], MovieGroupByOutputType[P]>
        }
      >
    >


  export type MovieSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    durationMinutes?: boolean
    language?: boolean
    format?: boolean
    posterUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    showings?: boolean | Movie$showingsArgs<ExtArgs>
    _count?: boolean | MovieCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movie"]>

  export type MovieSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    durationMinutes?: boolean
    language?: boolean
    format?: boolean
    posterUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["movie"]>

  export type MovieSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    durationMinutes?: boolean
    language?: boolean
    format?: boolean
    posterUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MovieInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    showings?: boolean | Movie$showingsArgs<ExtArgs>
    _count?: boolean | MovieCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MovieIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MoviePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Movie"
    objects: {
      showings: Prisma.$ShowingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      durationMinutes: number
      language: string
      format: $Enums.Format
      posterUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["movie"]>
    composites: {}
  }

  type MovieGetPayload<S extends boolean | null | undefined | MovieDefaultArgs> = $Result.GetResult<Prisma.$MoviePayload, S>

  type MovieCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MovieFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MovieCountAggregateInputType | true
    }

  export interface MovieDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Movie'], meta: { name: 'Movie' } }
    /**
     * Find zero or one Movie that matches the filter.
     * @param {MovieFindUniqueArgs} args - Arguments to find a Movie
     * @example
     * // Get one Movie
     * const movie = await prisma.movie.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MovieFindUniqueArgs>(args: SelectSubset<T, MovieFindUniqueArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Movie that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MovieFindUniqueOrThrowArgs} args - Arguments to find a Movie
     * @example
     * // Get one Movie
     * const movie = await prisma.movie.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MovieFindUniqueOrThrowArgs>(args: SelectSubset<T, MovieFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Movie that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieFindFirstArgs} args - Arguments to find a Movie
     * @example
     * // Get one Movie
     * const movie = await prisma.movie.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MovieFindFirstArgs>(args?: SelectSubset<T, MovieFindFirstArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Movie that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieFindFirstOrThrowArgs} args - Arguments to find a Movie
     * @example
     * // Get one Movie
     * const movie = await prisma.movie.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MovieFindFirstOrThrowArgs>(args?: SelectSubset<T, MovieFindFirstOrThrowArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Movies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Movies
     * const movies = await prisma.movie.findMany()
     * 
     * // Get first 10 Movies
     * const movies = await prisma.movie.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const movieWithIdOnly = await prisma.movie.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MovieFindManyArgs>(args?: SelectSubset<T, MovieFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Movie.
     * @param {MovieCreateArgs} args - Arguments to create a Movie.
     * @example
     * // Create one Movie
     * const Movie = await prisma.movie.create({
     *   data: {
     *     // ... data to create a Movie
     *   }
     * })
     * 
     */
    create<T extends MovieCreateArgs>(args: SelectSubset<T, MovieCreateArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Movies.
     * @param {MovieCreateManyArgs} args - Arguments to create many Movies.
     * @example
     * // Create many Movies
     * const movie = await prisma.movie.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MovieCreateManyArgs>(args?: SelectSubset<T, MovieCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Movies and returns the data saved in the database.
     * @param {MovieCreateManyAndReturnArgs} args - Arguments to create many Movies.
     * @example
     * // Create many Movies
     * const movie = await prisma.movie.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Movies and only return the `id`
     * const movieWithIdOnly = await prisma.movie.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MovieCreateManyAndReturnArgs>(args?: SelectSubset<T, MovieCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Movie.
     * @param {MovieDeleteArgs} args - Arguments to delete one Movie.
     * @example
     * // Delete one Movie
     * const Movie = await prisma.movie.delete({
     *   where: {
     *     // ... filter to delete one Movie
     *   }
     * })
     * 
     */
    delete<T extends MovieDeleteArgs>(args: SelectSubset<T, MovieDeleteArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Movie.
     * @param {MovieUpdateArgs} args - Arguments to update one Movie.
     * @example
     * // Update one Movie
     * const movie = await prisma.movie.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MovieUpdateArgs>(args: SelectSubset<T, MovieUpdateArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Movies.
     * @param {MovieDeleteManyArgs} args - Arguments to filter Movies to delete.
     * @example
     * // Delete a few Movies
     * const { count } = await prisma.movie.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MovieDeleteManyArgs>(args?: SelectSubset<T, MovieDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Movies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Movies
     * const movie = await prisma.movie.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MovieUpdateManyArgs>(args: SelectSubset<T, MovieUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Movie.
     * @param {MovieUpsertArgs} args - Arguments to update or create a Movie.
     * @example
     * // Update or create a Movie
     * const movie = await prisma.movie.upsert({
     *   create: {
     *     // ... data to create a Movie
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Movie we want to update
     *   }
     * })
     */
    upsert<T extends MovieUpsertArgs>(args: SelectSubset<T, MovieUpsertArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Movies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieCountArgs} args - Arguments to filter Movies to count.
     * @example
     * // Count the number of Movies
     * const count = await prisma.movie.count({
     *   where: {
     *     // ... the filter for the Movies we want to count
     *   }
     * })
    **/
    count<T extends MovieCountArgs>(
      args?: Subset<T, MovieCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MovieCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Movie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MovieAggregateArgs>(args: Subset<T, MovieAggregateArgs>): Prisma.PrismaPromise<GetMovieAggregateType<T>>

    /**
     * Group by Movie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MovieGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MovieGroupByArgs['orderBy'] }
        : { orderBy?: MovieGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MovieGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovieGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Movie model
   */
  readonly fields: MovieFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Movie.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MovieClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    showings<T extends Movie$showingsArgs<ExtArgs> = {}>(args?: Subset<T, Movie$showingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Movie model
   */ 
  interface MovieFieldRefs {
    readonly id: FieldRef<"Movie", 'String'>
    readonly title: FieldRef<"Movie", 'String'>
    readonly description: FieldRef<"Movie", 'String'>
    readonly durationMinutes: FieldRef<"Movie", 'Int'>
    readonly language: FieldRef<"Movie", 'String'>
    readonly format: FieldRef<"Movie", 'Format'>
    readonly posterUrl: FieldRef<"Movie", 'String'>
    readonly createdAt: FieldRef<"Movie", 'DateTime'>
    readonly updatedAt: FieldRef<"Movie", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Movie findUnique
   */
  export type MovieFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movie to fetch.
     */
    where: MovieWhereUniqueInput
  }

  /**
   * Movie findUniqueOrThrow
   */
  export type MovieFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movie to fetch.
     */
    where: MovieWhereUniqueInput
  }

  /**
   * Movie findFirst
   */
  export type MovieFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movie to fetch.
     */
    where?: MovieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movies to fetch.
     */
    orderBy?: MovieOrderByWithRelationInput | MovieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Movies.
     */
    cursor?: MovieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Movies.
     */
    distinct?: MovieScalarFieldEnum | MovieScalarFieldEnum[]
  }

  /**
   * Movie findFirstOrThrow
   */
  export type MovieFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movie to fetch.
     */
    where?: MovieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movies to fetch.
     */
    orderBy?: MovieOrderByWithRelationInput | MovieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Movies.
     */
    cursor?: MovieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Movies.
     */
    distinct?: MovieScalarFieldEnum | MovieScalarFieldEnum[]
  }

  /**
   * Movie findMany
   */
  export type MovieFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movies to fetch.
     */
    where?: MovieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movies to fetch.
     */
    orderBy?: MovieOrderByWithRelationInput | MovieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Movies.
     */
    cursor?: MovieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movies.
     */
    skip?: number
    distinct?: MovieScalarFieldEnum | MovieScalarFieldEnum[]
  }

  /**
   * Movie create
   */
  export type MovieCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * The data needed to create a Movie.
     */
    data: XOR<MovieCreateInput, MovieUncheckedCreateInput>
  }

  /**
   * Movie createMany
   */
  export type MovieCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Movies.
     */
    data: MovieCreateManyInput | MovieCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Movie createManyAndReturn
   */
  export type MovieCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Movies.
     */
    data: MovieCreateManyInput | MovieCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Movie update
   */
  export type MovieUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * The data needed to update a Movie.
     */
    data: XOR<MovieUpdateInput, MovieUncheckedUpdateInput>
    /**
     * Choose, which Movie to update.
     */
    where: MovieWhereUniqueInput
  }

  /**
   * Movie updateMany
   */
  export type MovieUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Movies.
     */
    data: XOR<MovieUpdateManyMutationInput, MovieUncheckedUpdateManyInput>
    /**
     * Filter which Movies to update
     */
    where?: MovieWhereInput
  }

  /**
   * Movie upsert
   */
  export type MovieUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * The filter to search for the Movie to update in case it exists.
     */
    where: MovieWhereUniqueInput
    /**
     * In case the Movie found by the `where` argument doesn't exist, create a new Movie with this data.
     */
    create: XOR<MovieCreateInput, MovieUncheckedCreateInput>
    /**
     * In case the Movie was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MovieUpdateInput, MovieUncheckedUpdateInput>
  }

  /**
   * Movie delete
   */
  export type MovieDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter which Movie to delete.
     */
    where: MovieWhereUniqueInput
  }

  /**
   * Movie deleteMany
   */
  export type MovieDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Movies to delete
     */
    where?: MovieWhereInput
  }

  /**
   * Movie.showings
   */
  export type Movie$showingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showing
     */
    select?: ShowingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowingInclude<ExtArgs> | null
    where?: ShowingWhereInput
    orderBy?: ShowingOrderByWithRelationInput | ShowingOrderByWithRelationInput[]
    cursor?: ShowingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShowingScalarFieldEnum | ShowingScalarFieldEnum[]
  }

  /**
   * Movie without action
   */
  export type MovieDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
  }


  /**
   * Model Showing
   */

  export type AggregateShowing = {
    _count: ShowingCountAggregateOutputType | null
    _avg: ShowingAvgAggregateOutputType | null
    _sum: ShowingSumAggregateOutputType | null
    _min: ShowingMinAggregateOutputType | null
    _max: ShowingMaxAggregateOutputType | null
  }

  export type ShowingAvgAggregateOutputType = {
    priceCents: number | null
    rows: number | null
    seatsPerRow: number | null
    totalSeats: number | null
  }

  export type ShowingSumAggregateOutputType = {
    priceCents: number | null
    rows: number | null
    seatsPerRow: number | null
    totalSeats: number | null
  }

  export type ShowingMinAggregateOutputType = {
    id: string | null
    movieId: string | null
    startTime: Date | null
    priceCents: number | null
    rows: number | null
    seatsPerRow: number | null
    totalSeats: number | null
    status: $Enums.ShowingStatus | null
    cancelledAt: Date | null
    createdAt: Date | null
  }

  export type ShowingMaxAggregateOutputType = {
    id: string | null
    movieId: string | null
    startTime: Date | null
    priceCents: number | null
    rows: number | null
    seatsPerRow: number | null
    totalSeats: number | null
    status: $Enums.ShowingStatus | null
    cancelledAt: Date | null
    createdAt: Date | null
  }

  export type ShowingCountAggregateOutputType = {
    id: number
    movieId: number
    startTime: number
    priceCents: number
    rows: number
    seatsPerRow: number
    totalSeats: number
    status: number
    cancelledAt: number
    createdAt: number
    _all: number
  }


  export type ShowingAvgAggregateInputType = {
    priceCents?: true
    rows?: true
    seatsPerRow?: true
    totalSeats?: true
  }

  export type ShowingSumAggregateInputType = {
    priceCents?: true
    rows?: true
    seatsPerRow?: true
    totalSeats?: true
  }

  export type ShowingMinAggregateInputType = {
    id?: true
    movieId?: true
    startTime?: true
    priceCents?: true
    rows?: true
    seatsPerRow?: true
    totalSeats?: true
    status?: true
    cancelledAt?: true
    createdAt?: true
  }

  export type ShowingMaxAggregateInputType = {
    id?: true
    movieId?: true
    startTime?: true
    priceCents?: true
    rows?: true
    seatsPerRow?: true
    totalSeats?: true
    status?: true
    cancelledAt?: true
    createdAt?: true
  }

  export type ShowingCountAggregateInputType = {
    id?: true
    movieId?: true
    startTime?: true
    priceCents?: true
    rows?: true
    seatsPerRow?: true
    totalSeats?: true
    status?: true
    cancelledAt?: true
    createdAt?: true
    _all?: true
  }

  export type ShowingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Showing to aggregate.
     */
    where?: ShowingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Showings to fetch.
     */
    orderBy?: ShowingOrderByWithRelationInput | ShowingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShowingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Showings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Showings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Showings
    **/
    _count?: true | ShowingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShowingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShowingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShowingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShowingMaxAggregateInputType
  }

  export type GetShowingAggregateType<T extends ShowingAggregateArgs> = {
        [P in keyof T & keyof AggregateShowing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShowing[P]>
      : GetScalarType<T[P], AggregateShowing[P]>
  }




  export type ShowingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShowingWhereInput
    orderBy?: ShowingOrderByWithAggregationInput | ShowingOrderByWithAggregationInput[]
    by: ShowingScalarFieldEnum[] | ShowingScalarFieldEnum
    having?: ShowingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShowingCountAggregateInputType | true
    _avg?: ShowingAvgAggregateInputType
    _sum?: ShowingSumAggregateInputType
    _min?: ShowingMinAggregateInputType
    _max?: ShowingMaxAggregateInputType
  }

  export type ShowingGroupByOutputType = {
    id: string
    movieId: string
    startTime: Date
    priceCents: number
    rows: number
    seatsPerRow: number
    totalSeats: number
    status: $Enums.ShowingStatus
    cancelledAt: Date | null
    createdAt: Date
    _count: ShowingCountAggregateOutputType | null
    _avg: ShowingAvgAggregateOutputType | null
    _sum: ShowingSumAggregateOutputType | null
    _min: ShowingMinAggregateOutputType | null
    _max: ShowingMaxAggregateOutputType | null
  }

  type GetShowingGroupByPayload<T extends ShowingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShowingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShowingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShowingGroupByOutputType[P]>
            : GetScalarType<T[P], ShowingGroupByOutputType[P]>
        }
      >
    >


  export type ShowingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    movieId?: boolean
    startTime?: boolean
    priceCents?: boolean
    rows?: boolean
    seatsPerRow?: boolean
    totalSeats?: boolean
    status?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    seats?: boolean | Showing$seatsArgs<ExtArgs>
    seatHolds?: boolean | Showing$seatHoldsArgs<ExtArgs>
    credits?: boolean | Showing$creditsArgs<ExtArgs>
    _count?: boolean | ShowingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["showing"]>

  export type ShowingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    movieId?: boolean
    startTime?: boolean
    priceCents?: boolean
    rows?: boolean
    seatsPerRow?: boolean
    totalSeats?: boolean
    status?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["showing"]>

  export type ShowingSelectScalar = {
    id?: boolean
    movieId?: boolean
    startTime?: boolean
    priceCents?: boolean
    rows?: boolean
    seatsPerRow?: boolean
    totalSeats?: boolean
    status?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
  }

  export type ShowingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    seats?: boolean | Showing$seatsArgs<ExtArgs>
    seatHolds?: boolean | Showing$seatHoldsArgs<ExtArgs>
    credits?: boolean | Showing$creditsArgs<ExtArgs>
    _count?: boolean | ShowingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShowingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }

  export type $ShowingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Showing"
    objects: {
      movie: Prisma.$MoviePayload<ExtArgs>
      seats: Prisma.$SeatPayload<ExtArgs>[]
      seatHolds: Prisma.$SeatHoldPayload<ExtArgs>[]
      credits: Prisma.$CinemaCreditPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      movieId: string
      startTime: Date
      priceCents: number
      rows: number
      seatsPerRow: number
      totalSeats: number
      status: $Enums.ShowingStatus
      cancelledAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["showing"]>
    composites: {}
  }

  type ShowingGetPayload<S extends boolean | null | undefined | ShowingDefaultArgs> = $Result.GetResult<Prisma.$ShowingPayload, S>

  type ShowingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShowingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShowingCountAggregateInputType | true
    }

  export interface ShowingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Showing'], meta: { name: 'Showing' } }
    /**
     * Find zero or one Showing that matches the filter.
     * @param {ShowingFindUniqueArgs} args - Arguments to find a Showing
     * @example
     * // Get one Showing
     * const showing = await prisma.showing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShowingFindUniqueArgs>(args: SelectSubset<T, ShowingFindUniqueArgs<ExtArgs>>): Prisma__ShowingClient<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Showing that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShowingFindUniqueOrThrowArgs} args - Arguments to find a Showing
     * @example
     * // Get one Showing
     * const showing = await prisma.showing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShowingFindUniqueOrThrowArgs>(args: SelectSubset<T, ShowingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShowingClient<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Showing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowingFindFirstArgs} args - Arguments to find a Showing
     * @example
     * // Get one Showing
     * const showing = await prisma.showing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShowingFindFirstArgs>(args?: SelectSubset<T, ShowingFindFirstArgs<ExtArgs>>): Prisma__ShowingClient<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Showing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowingFindFirstOrThrowArgs} args - Arguments to find a Showing
     * @example
     * // Get one Showing
     * const showing = await prisma.showing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShowingFindFirstOrThrowArgs>(args?: SelectSubset<T, ShowingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShowingClient<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Showings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Showings
     * const showings = await prisma.showing.findMany()
     * 
     * // Get first 10 Showings
     * const showings = await prisma.showing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const showingWithIdOnly = await prisma.showing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShowingFindManyArgs>(args?: SelectSubset<T, ShowingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Showing.
     * @param {ShowingCreateArgs} args - Arguments to create a Showing.
     * @example
     * // Create one Showing
     * const Showing = await prisma.showing.create({
     *   data: {
     *     // ... data to create a Showing
     *   }
     * })
     * 
     */
    create<T extends ShowingCreateArgs>(args: SelectSubset<T, ShowingCreateArgs<ExtArgs>>): Prisma__ShowingClient<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Showings.
     * @param {ShowingCreateManyArgs} args - Arguments to create many Showings.
     * @example
     * // Create many Showings
     * const showing = await prisma.showing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShowingCreateManyArgs>(args?: SelectSubset<T, ShowingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Showings and returns the data saved in the database.
     * @param {ShowingCreateManyAndReturnArgs} args - Arguments to create many Showings.
     * @example
     * // Create many Showings
     * const showing = await prisma.showing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Showings and only return the `id`
     * const showingWithIdOnly = await prisma.showing.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShowingCreateManyAndReturnArgs>(args?: SelectSubset<T, ShowingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Showing.
     * @param {ShowingDeleteArgs} args - Arguments to delete one Showing.
     * @example
     * // Delete one Showing
     * const Showing = await prisma.showing.delete({
     *   where: {
     *     // ... filter to delete one Showing
     *   }
     * })
     * 
     */
    delete<T extends ShowingDeleteArgs>(args: SelectSubset<T, ShowingDeleteArgs<ExtArgs>>): Prisma__ShowingClient<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Showing.
     * @param {ShowingUpdateArgs} args - Arguments to update one Showing.
     * @example
     * // Update one Showing
     * const showing = await prisma.showing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShowingUpdateArgs>(args: SelectSubset<T, ShowingUpdateArgs<ExtArgs>>): Prisma__ShowingClient<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Showings.
     * @param {ShowingDeleteManyArgs} args - Arguments to filter Showings to delete.
     * @example
     * // Delete a few Showings
     * const { count } = await prisma.showing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShowingDeleteManyArgs>(args?: SelectSubset<T, ShowingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Showings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Showings
     * const showing = await prisma.showing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShowingUpdateManyArgs>(args: SelectSubset<T, ShowingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Showing.
     * @param {ShowingUpsertArgs} args - Arguments to update or create a Showing.
     * @example
     * // Update or create a Showing
     * const showing = await prisma.showing.upsert({
     *   create: {
     *     // ... data to create a Showing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Showing we want to update
     *   }
     * })
     */
    upsert<T extends ShowingUpsertArgs>(args: SelectSubset<T, ShowingUpsertArgs<ExtArgs>>): Prisma__ShowingClient<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Showings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowingCountArgs} args - Arguments to filter Showings to count.
     * @example
     * // Count the number of Showings
     * const count = await prisma.showing.count({
     *   where: {
     *     // ... the filter for the Showings we want to count
     *   }
     * })
    **/
    count<T extends ShowingCountArgs>(
      args?: Subset<T, ShowingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShowingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Showing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShowingAggregateArgs>(args: Subset<T, ShowingAggregateArgs>): Prisma.PrismaPromise<GetShowingAggregateType<T>>

    /**
     * Group by Showing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShowingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShowingGroupByArgs['orderBy'] }
        : { orderBy?: ShowingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShowingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShowingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Showing model
   */
  readonly fields: ShowingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Showing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShowingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    movie<T extends MovieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MovieDefaultArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    seats<T extends Showing$seatsArgs<ExtArgs> = {}>(args?: Subset<T, Showing$seatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findMany"> | Null>
    seatHolds<T extends Showing$seatHoldsArgs<ExtArgs> = {}>(args?: Subset<T, Showing$seatHoldsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatHoldPayload<ExtArgs>, T, "findMany"> | Null>
    credits<T extends Showing$creditsArgs<ExtArgs> = {}>(args?: Subset<T, Showing$creditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CinemaCreditPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Showing model
   */ 
  interface ShowingFieldRefs {
    readonly id: FieldRef<"Showing", 'String'>
    readonly movieId: FieldRef<"Showing", 'String'>
    readonly startTime: FieldRef<"Showing", 'DateTime'>
    readonly priceCents: FieldRef<"Showing", 'Int'>
    readonly rows: FieldRef<"Showing", 'Int'>
    readonly seatsPerRow: FieldRef<"Showing", 'Int'>
    readonly totalSeats: FieldRef<"Showing", 'Int'>
    readonly status: FieldRef<"Showing", 'ShowingStatus'>
    readonly cancelledAt: FieldRef<"Showing", 'DateTime'>
    readonly createdAt: FieldRef<"Showing", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Showing findUnique
   */
  export type ShowingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showing
     */
    select?: ShowingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowingInclude<ExtArgs> | null
    /**
     * Filter, which Showing to fetch.
     */
    where: ShowingWhereUniqueInput
  }

  /**
   * Showing findUniqueOrThrow
   */
  export type ShowingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showing
     */
    select?: ShowingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowingInclude<ExtArgs> | null
    /**
     * Filter, which Showing to fetch.
     */
    where: ShowingWhereUniqueInput
  }

  /**
   * Showing findFirst
   */
  export type ShowingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showing
     */
    select?: ShowingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowingInclude<ExtArgs> | null
    /**
     * Filter, which Showing to fetch.
     */
    where?: ShowingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Showings to fetch.
     */
    orderBy?: ShowingOrderByWithRelationInput | ShowingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Showings.
     */
    cursor?: ShowingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Showings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Showings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Showings.
     */
    distinct?: ShowingScalarFieldEnum | ShowingScalarFieldEnum[]
  }

  /**
   * Showing findFirstOrThrow
   */
  export type ShowingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showing
     */
    select?: ShowingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowingInclude<ExtArgs> | null
    /**
     * Filter, which Showing to fetch.
     */
    where?: ShowingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Showings to fetch.
     */
    orderBy?: ShowingOrderByWithRelationInput | ShowingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Showings.
     */
    cursor?: ShowingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Showings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Showings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Showings.
     */
    distinct?: ShowingScalarFieldEnum | ShowingScalarFieldEnum[]
  }

  /**
   * Showing findMany
   */
  export type ShowingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showing
     */
    select?: ShowingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowingInclude<ExtArgs> | null
    /**
     * Filter, which Showings to fetch.
     */
    where?: ShowingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Showings to fetch.
     */
    orderBy?: ShowingOrderByWithRelationInput | ShowingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Showings.
     */
    cursor?: ShowingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Showings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Showings.
     */
    skip?: number
    distinct?: ShowingScalarFieldEnum | ShowingScalarFieldEnum[]
  }

  /**
   * Showing create
   */
  export type ShowingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showing
     */
    select?: ShowingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowingInclude<ExtArgs> | null
    /**
     * The data needed to create a Showing.
     */
    data: XOR<ShowingCreateInput, ShowingUncheckedCreateInput>
  }

  /**
   * Showing createMany
   */
  export type ShowingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Showings.
     */
    data: ShowingCreateManyInput | ShowingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Showing createManyAndReturn
   */
  export type ShowingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showing
     */
    select?: ShowingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Showings.
     */
    data: ShowingCreateManyInput | ShowingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Showing update
   */
  export type ShowingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showing
     */
    select?: ShowingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowingInclude<ExtArgs> | null
    /**
     * The data needed to update a Showing.
     */
    data: XOR<ShowingUpdateInput, ShowingUncheckedUpdateInput>
    /**
     * Choose, which Showing to update.
     */
    where: ShowingWhereUniqueInput
  }

  /**
   * Showing updateMany
   */
  export type ShowingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Showings.
     */
    data: XOR<ShowingUpdateManyMutationInput, ShowingUncheckedUpdateManyInput>
    /**
     * Filter which Showings to update
     */
    where?: ShowingWhereInput
  }

  /**
   * Showing upsert
   */
  export type ShowingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showing
     */
    select?: ShowingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowingInclude<ExtArgs> | null
    /**
     * The filter to search for the Showing to update in case it exists.
     */
    where: ShowingWhereUniqueInput
    /**
     * In case the Showing found by the `where` argument doesn't exist, create a new Showing with this data.
     */
    create: XOR<ShowingCreateInput, ShowingUncheckedCreateInput>
    /**
     * In case the Showing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShowingUpdateInput, ShowingUncheckedUpdateInput>
  }

  /**
   * Showing delete
   */
  export type ShowingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showing
     */
    select?: ShowingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowingInclude<ExtArgs> | null
    /**
     * Filter which Showing to delete.
     */
    where: ShowingWhereUniqueInput
  }

  /**
   * Showing deleteMany
   */
  export type ShowingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Showings to delete
     */
    where?: ShowingWhereInput
  }

  /**
   * Showing.seats
   */
  export type Showing$seatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    where?: SeatWhereInput
    orderBy?: SeatOrderByWithRelationInput | SeatOrderByWithRelationInput[]
    cursor?: SeatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeatScalarFieldEnum | SeatScalarFieldEnum[]
  }

  /**
   * Showing.seatHolds
   */
  export type Showing$seatHoldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatHold
     */
    select?: SeatHoldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatHoldInclude<ExtArgs> | null
    where?: SeatHoldWhereInput
    orderBy?: SeatHoldOrderByWithRelationInput | SeatHoldOrderByWithRelationInput[]
    cursor?: SeatHoldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeatHoldScalarFieldEnum | SeatHoldScalarFieldEnum[]
  }

  /**
   * Showing.credits
   */
  export type Showing$creditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaCredit
     */
    select?: CinemaCreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaCreditInclude<ExtArgs> | null
    where?: CinemaCreditWhereInput
    orderBy?: CinemaCreditOrderByWithRelationInput | CinemaCreditOrderByWithRelationInput[]
    cursor?: CinemaCreditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CinemaCreditScalarFieldEnum | CinemaCreditScalarFieldEnum[]
  }

  /**
   * Showing without action
   */
  export type ShowingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showing
     */
    select?: ShowingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowingInclude<ExtArgs> | null
  }


  /**
   * Model Seat
   */

  export type AggregateSeat = {
    _count: SeatCountAggregateOutputType | null
    _avg: SeatAvgAggregateOutputType | null
    _sum: SeatSumAggregateOutputType | null
    _min: SeatMinAggregateOutputType | null
    _max: SeatMaxAggregateOutputType | null
  }

  export type SeatAvgAggregateOutputType = {
    number: number | null
  }

  export type SeatSumAggregateOutputType = {
    number: number | null
  }

  export type SeatMinAggregateOutputType = {
    id: string | null
    showingId: string | null
    rowLabel: string | null
    number: number | null
    status: $Enums.SeatStatus | null
    createdAt: Date | null
  }

  export type SeatMaxAggregateOutputType = {
    id: string | null
    showingId: string | null
    rowLabel: string | null
    number: number | null
    status: $Enums.SeatStatus | null
    createdAt: Date | null
  }

  export type SeatCountAggregateOutputType = {
    id: number
    showingId: number
    rowLabel: number
    number: number
    status: number
    createdAt: number
    _all: number
  }


  export type SeatAvgAggregateInputType = {
    number?: true
  }

  export type SeatSumAggregateInputType = {
    number?: true
  }

  export type SeatMinAggregateInputType = {
    id?: true
    showingId?: true
    rowLabel?: true
    number?: true
    status?: true
    createdAt?: true
  }

  export type SeatMaxAggregateInputType = {
    id?: true
    showingId?: true
    rowLabel?: true
    number?: true
    status?: true
    createdAt?: true
  }

  export type SeatCountAggregateInputType = {
    id?: true
    showingId?: true
    rowLabel?: true
    number?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type SeatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seat to aggregate.
     */
    where?: SeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seats to fetch.
     */
    orderBy?: SeatOrderByWithRelationInput | SeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Seats
    **/
    _count?: true | SeatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeatMaxAggregateInputType
  }

  export type GetSeatAggregateType<T extends SeatAggregateArgs> = {
        [P in keyof T & keyof AggregateSeat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeat[P]>
      : GetScalarType<T[P], AggregateSeat[P]>
  }




  export type SeatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeatWhereInput
    orderBy?: SeatOrderByWithAggregationInput | SeatOrderByWithAggregationInput[]
    by: SeatScalarFieldEnum[] | SeatScalarFieldEnum
    having?: SeatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeatCountAggregateInputType | true
    _avg?: SeatAvgAggregateInputType
    _sum?: SeatSumAggregateInputType
    _min?: SeatMinAggregateInputType
    _max?: SeatMaxAggregateInputType
  }

  export type SeatGroupByOutputType = {
    id: string
    showingId: string
    rowLabel: string
    number: number
    status: $Enums.SeatStatus
    createdAt: Date
    _count: SeatCountAggregateOutputType | null
    _avg: SeatAvgAggregateOutputType | null
    _sum: SeatSumAggregateOutputType | null
    _min: SeatMinAggregateOutputType | null
    _max: SeatMaxAggregateOutputType | null
  }

  type GetSeatGroupByPayload<T extends SeatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeatGroupByOutputType[P]>
            : GetScalarType<T[P], SeatGroupByOutputType[P]>
        }
      >
    >


  export type SeatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    showingId?: boolean
    rowLabel?: boolean
    number?: boolean
    status?: boolean
    createdAt?: boolean
    showing?: boolean | ShowingDefaultArgs<ExtArgs>
    tickets?: boolean | Seat$ticketsArgs<ExtArgs>
    hold?: boolean | Seat$holdArgs<ExtArgs>
    _count?: boolean | SeatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seat"]>

  export type SeatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    showingId?: boolean
    rowLabel?: boolean
    number?: boolean
    status?: boolean
    createdAt?: boolean
    showing?: boolean | ShowingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seat"]>

  export type SeatSelectScalar = {
    id?: boolean
    showingId?: boolean
    rowLabel?: boolean
    number?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type SeatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    showing?: boolean | ShowingDefaultArgs<ExtArgs>
    tickets?: boolean | Seat$ticketsArgs<ExtArgs>
    hold?: boolean | Seat$holdArgs<ExtArgs>
    _count?: boolean | SeatCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SeatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    showing?: boolean | ShowingDefaultArgs<ExtArgs>
  }

  export type $SeatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Seat"
    objects: {
      showing: Prisma.$ShowingPayload<ExtArgs>
      tickets: Prisma.$TicketPayload<ExtArgs>[]
      hold: Prisma.$SeatHoldPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      showingId: string
      rowLabel: string
      number: number
      status: $Enums.SeatStatus
      createdAt: Date
    }, ExtArgs["result"]["seat"]>
    composites: {}
  }

  type SeatGetPayload<S extends boolean | null | undefined | SeatDefaultArgs> = $Result.GetResult<Prisma.$SeatPayload, S>

  type SeatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SeatFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SeatCountAggregateInputType | true
    }

  export interface SeatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Seat'], meta: { name: 'Seat' } }
    /**
     * Find zero or one Seat that matches the filter.
     * @param {SeatFindUniqueArgs} args - Arguments to find a Seat
     * @example
     * // Get one Seat
     * const seat = await prisma.seat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeatFindUniqueArgs>(args: SelectSubset<T, SeatFindUniqueArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Seat that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SeatFindUniqueOrThrowArgs} args - Arguments to find a Seat
     * @example
     * // Get one Seat
     * const seat = await prisma.seat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeatFindUniqueOrThrowArgs>(args: SelectSubset<T, SeatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Seat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatFindFirstArgs} args - Arguments to find a Seat
     * @example
     * // Get one Seat
     * const seat = await prisma.seat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeatFindFirstArgs>(args?: SelectSubset<T, SeatFindFirstArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Seat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatFindFirstOrThrowArgs} args - Arguments to find a Seat
     * @example
     * // Get one Seat
     * const seat = await prisma.seat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeatFindFirstOrThrowArgs>(args?: SelectSubset<T, SeatFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Seats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seats
     * const seats = await prisma.seat.findMany()
     * 
     * // Get first 10 Seats
     * const seats = await prisma.seat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seatWithIdOnly = await prisma.seat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeatFindManyArgs>(args?: SelectSubset<T, SeatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Seat.
     * @param {SeatCreateArgs} args - Arguments to create a Seat.
     * @example
     * // Create one Seat
     * const Seat = await prisma.seat.create({
     *   data: {
     *     // ... data to create a Seat
     *   }
     * })
     * 
     */
    create<T extends SeatCreateArgs>(args: SelectSubset<T, SeatCreateArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Seats.
     * @param {SeatCreateManyArgs} args - Arguments to create many Seats.
     * @example
     * // Create many Seats
     * const seat = await prisma.seat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeatCreateManyArgs>(args?: SelectSubset<T, SeatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Seats and returns the data saved in the database.
     * @param {SeatCreateManyAndReturnArgs} args - Arguments to create many Seats.
     * @example
     * // Create many Seats
     * const seat = await prisma.seat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Seats and only return the `id`
     * const seatWithIdOnly = await prisma.seat.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeatCreateManyAndReturnArgs>(args?: SelectSubset<T, SeatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Seat.
     * @param {SeatDeleteArgs} args - Arguments to delete one Seat.
     * @example
     * // Delete one Seat
     * const Seat = await prisma.seat.delete({
     *   where: {
     *     // ... filter to delete one Seat
     *   }
     * })
     * 
     */
    delete<T extends SeatDeleteArgs>(args: SelectSubset<T, SeatDeleteArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Seat.
     * @param {SeatUpdateArgs} args - Arguments to update one Seat.
     * @example
     * // Update one Seat
     * const seat = await prisma.seat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeatUpdateArgs>(args: SelectSubset<T, SeatUpdateArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Seats.
     * @param {SeatDeleteManyArgs} args - Arguments to filter Seats to delete.
     * @example
     * // Delete a few Seats
     * const { count } = await prisma.seat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeatDeleteManyArgs>(args?: SelectSubset<T, SeatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seats
     * const seat = await prisma.seat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeatUpdateManyArgs>(args: SelectSubset<T, SeatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Seat.
     * @param {SeatUpsertArgs} args - Arguments to update or create a Seat.
     * @example
     * // Update or create a Seat
     * const seat = await prisma.seat.upsert({
     *   create: {
     *     // ... data to create a Seat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Seat we want to update
     *   }
     * })
     */
    upsert<T extends SeatUpsertArgs>(args: SelectSubset<T, SeatUpsertArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Seats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatCountArgs} args - Arguments to filter Seats to count.
     * @example
     * // Count the number of Seats
     * const count = await prisma.seat.count({
     *   where: {
     *     // ... the filter for the Seats we want to count
     *   }
     * })
    **/
    count<T extends SeatCountArgs>(
      args?: Subset<T, SeatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Seat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeatAggregateArgs>(args: Subset<T, SeatAggregateArgs>): Prisma.PrismaPromise<GetSeatAggregateType<T>>

    /**
     * Group by Seat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeatGroupByArgs['orderBy'] }
        : { orderBy?: SeatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Seat model
   */
  readonly fields: SeatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Seat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    showing<T extends ShowingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShowingDefaultArgs<ExtArgs>>): Prisma__ShowingClient<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tickets<T extends Seat$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Seat$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany"> | Null>
    hold<T extends Seat$holdArgs<ExtArgs> = {}>(args?: Subset<T, Seat$holdArgs<ExtArgs>>): Prisma__SeatHoldClient<$Result.GetResult<Prisma.$SeatHoldPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Seat model
   */ 
  interface SeatFieldRefs {
    readonly id: FieldRef<"Seat", 'String'>
    readonly showingId: FieldRef<"Seat", 'String'>
    readonly rowLabel: FieldRef<"Seat", 'String'>
    readonly number: FieldRef<"Seat", 'Int'>
    readonly status: FieldRef<"Seat", 'SeatStatus'>
    readonly createdAt: FieldRef<"Seat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Seat findUnique
   */
  export type SeatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * Filter, which Seat to fetch.
     */
    where: SeatWhereUniqueInput
  }

  /**
   * Seat findUniqueOrThrow
   */
  export type SeatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * Filter, which Seat to fetch.
     */
    where: SeatWhereUniqueInput
  }

  /**
   * Seat findFirst
   */
  export type SeatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * Filter, which Seat to fetch.
     */
    where?: SeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seats to fetch.
     */
    orderBy?: SeatOrderByWithRelationInput | SeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seats.
     */
    cursor?: SeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seats.
     */
    distinct?: SeatScalarFieldEnum | SeatScalarFieldEnum[]
  }

  /**
   * Seat findFirstOrThrow
   */
  export type SeatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * Filter, which Seat to fetch.
     */
    where?: SeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seats to fetch.
     */
    orderBy?: SeatOrderByWithRelationInput | SeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seats.
     */
    cursor?: SeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seats.
     */
    distinct?: SeatScalarFieldEnum | SeatScalarFieldEnum[]
  }

  /**
   * Seat findMany
   */
  export type SeatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * Filter, which Seats to fetch.
     */
    where?: SeatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seats to fetch.
     */
    orderBy?: SeatOrderByWithRelationInput | SeatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Seats.
     */
    cursor?: SeatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seats.
     */
    skip?: number
    distinct?: SeatScalarFieldEnum | SeatScalarFieldEnum[]
  }

  /**
   * Seat create
   */
  export type SeatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * The data needed to create a Seat.
     */
    data: XOR<SeatCreateInput, SeatUncheckedCreateInput>
  }

  /**
   * Seat createMany
   */
  export type SeatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Seats.
     */
    data: SeatCreateManyInput | SeatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Seat createManyAndReturn
   */
  export type SeatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Seats.
     */
    data: SeatCreateManyInput | SeatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Seat update
   */
  export type SeatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * The data needed to update a Seat.
     */
    data: XOR<SeatUpdateInput, SeatUncheckedUpdateInput>
    /**
     * Choose, which Seat to update.
     */
    where: SeatWhereUniqueInput
  }

  /**
   * Seat updateMany
   */
  export type SeatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Seats.
     */
    data: XOR<SeatUpdateManyMutationInput, SeatUncheckedUpdateManyInput>
    /**
     * Filter which Seats to update
     */
    where?: SeatWhereInput
  }

  /**
   * Seat upsert
   */
  export type SeatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * The filter to search for the Seat to update in case it exists.
     */
    where: SeatWhereUniqueInput
    /**
     * In case the Seat found by the `where` argument doesn't exist, create a new Seat with this data.
     */
    create: XOR<SeatCreateInput, SeatUncheckedCreateInput>
    /**
     * In case the Seat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeatUpdateInput, SeatUncheckedUpdateInput>
  }

  /**
   * Seat delete
   */
  export type SeatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
    /**
     * Filter which Seat to delete.
     */
    where: SeatWhereUniqueInput
  }

  /**
   * Seat deleteMany
   */
  export type SeatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seats to delete
     */
    where?: SeatWhereInput
  }

  /**
   * Seat.tickets
   */
  export type Seat$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Seat.hold
   */
  export type Seat$holdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatHold
     */
    select?: SeatHoldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatHoldInclude<ExtArgs> | null
    where?: SeatHoldWhereInput
  }

  /**
   * Seat without action
   */
  export type SeatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seat
     */
    select?: SeatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatInclude<ExtArgs> | null
  }


  /**
   * Model SeatHold
   */

  export type AggregateSeatHold = {
    _count: SeatHoldCountAggregateOutputType | null
    _avg: SeatHoldAvgAggregateOutputType | null
    _sum: SeatHoldSumAggregateOutputType | null
    _min: SeatHoldMinAggregateOutputType | null
    _max: SeatHoldMaxAggregateOutputType | null
  }

  export type SeatHoldAvgAggregateOutputType = {
    userId: number | null
  }

  export type SeatHoldSumAggregateOutputType = {
    userId: number | null
  }

  export type SeatHoldMinAggregateOutputType = {
    id: string | null
    seatId: string | null
    showingId: string | null
    userId: number | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type SeatHoldMaxAggregateOutputType = {
    id: string | null
    seatId: string | null
    showingId: string | null
    userId: number | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type SeatHoldCountAggregateOutputType = {
    id: number
    seatId: number
    showingId: number
    userId: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type SeatHoldAvgAggregateInputType = {
    userId?: true
  }

  export type SeatHoldSumAggregateInputType = {
    userId?: true
  }

  export type SeatHoldMinAggregateInputType = {
    id?: true
    seatId?: true
    showingId?: true
    userId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type SeatHoldMaxAggregateInputType = {
    id?: true
    seatId?: true
    showingId?: true
    userId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type SeatHoldCountAggregateInputType = {
    id?: true
    seatId?: true
    showingId?: true
    userId?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type SeatHoldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeatHold to aggregate.
     */
    where?: SeatHoldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeatHolds to fetch.
     */
    orderBy?: SeatHoldOrderByWithRelationInput | SeatHoldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeatHoldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeatHolds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeatHolds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SeatHolds
    **/
    _count?: true | SeatHoldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeatHoldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeatHoldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeatHoldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeatHoldMaxAggregateInputType
  }

  export type GetSeatHoldAggregateType<T extends SeatHoldAggregateArgs> = {
        [P in keyof T & keyof AggregateSeatHold]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeatHold[P]>
      : GetScalarType<T[P], AggregateSeatHold[P]>
  }




  export type SeatHoldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeatHoldWhereInput
    orderBy?: SeatHoldOrderByWithAggregationInput | SeatHoldOrderByWithAggregationInput[]
    by: SeatHoldScalarFieldEnum[] | SeatHoldScalarFieldEnum
    having?: SeatHoldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeatHoldCountAggregateInputType | true
    _avg?: SeatHoldAvgAggregateInputType
    _sum?: SeatHoldSumAggregateInputType
    _min?: SeatHoldMinAggregateInputType
    _max?: SeatHoldMaxAggregateInputType
  }

  export type SeatHoldGroupByOutputType = {
    id: string
    seatId: string
    showingId: string
    userId: number
    createdAt: Date
    expiresAt: Date
    _count: SeatHoldCountAggregateOutputType | null
    _avg: SeatHoldAvgAggregateOutputType | null
    _sum: SeatHoldSumAggregateOutputType | null
    _min: SeatHoldMinAggregateOutputType | null
    _max: SeatHoldMaxAggregateOutputType | null
  }

  type GetSeatHoldGroupByPayload<T extends SeatHoldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeatHoldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeatHoldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeatHoldGroupByOutputType[P]>
            : GetScalarType<T[P], SeatHoldGroupByOutputType[P]>
        }
      >
    >


  export type SeatHoldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seatId?: boolean
    showingId?: boolean
    userId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    seat?: boolean | SeatDefaultArgs<ExtArgs>
    showing?: boolean | ShowingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seatHold"]>

  export type SeatHoldSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seatId?: boolean
    showingId?: boolean
    userId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    seat?: boolean | SeatDefaultArgs<ExtArgs>
    showing?: boolean | ShowingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seatHold"]>

  export type SeatHoldSelectScalar = {
    id?: boolean
    seatId?: boolean
    showingId?: boolean
    userId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type SeatHoldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seat?: boolean | SeatDefaultArgs<ExtArgs>
    showing?: boolean | ShowingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SeatHoldIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seat?: boolean | SeatDefaultArgs<ExtArgs>
    showing?: boolean | ShowingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SeatHoldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SeatHold"
    objects: {
      seat: Prisma.$SeatPayload<ExtArgs>
      showing: Prisma.$ShowingPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seatId: string
      showingId: string
      userId: number
      createdAt: Date
      expiresAt: Date
    }, ExtArgs["result"]["seatHold"]>
    composites: {}
  }

  type SeatHoldGetPayload<S extends boolean | null | undefined | SeatHoldDefaultArgs> = $Result.GetResult<Prisma.$SeatHoldPayload, S>

  type SeatHoldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SeatHoldFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SeatHoldCountAggregateInputType | true
    }

  export interface SeatHoldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SeatHold'], meta: { name: 'SeatHold' } }
    /**
     * Find zero or one SeatHold that matches the filter.
     * @param {SeatHoldFindUniqueArgs} args - Arguments to find a SeatHold
     * @example
     * // Get one SeatHold
     * const seatHold = await prisma.seatHold.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeatHoldFindUniqueArgs>(args: SelectSubset<T, SeatHoldFindUniqueArgs<ExtArgs>>): Prisma__SeatHoldClient<$Result.GetResult<Prisma.$SeatHoldPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SeatHold that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SeatHoldFindUniqueOrThrowArgs} args - Arguments to find a SeatHold
     * @example
     * // Get one SeatHold
     * const seatHold = await prisma.seatHold.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeatHoldFindUniqueOrThrowArgs>(args: SelectSubset<T, SeatHoldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeatHoldClient<$Result.GetResult<Prisma.$SeatHoldPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SeatHold that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatHoldFindFirstArgs} args - Arguments to find a SeatHold
     * @example
     * // Get one SeatHold
     * const seatHold = await prisma.seatHold.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeatHoldFindFirstArgs>(args?: SelectSubset<T, SeatHoldFindFirstArgs<ExtArgs>>): Prisma__SeatHoldClient<$Result.GetResult<Prisma.$SeatHoldPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SeatHold that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatHoldFindFirstOrThrowArgs} args - Arguments to find a SeatHold
     * @example
     * // Get one SeatHold
     * const seatHold = await prisma.seatHold.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeatHoldFindFirstOrThrowArgs>(args?: SelectSubset<T, SeatHoldFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeatHoldClient<$Result.GetResult<Prisma.$SeatHoldPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SeatHolds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatHoldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeatHolds
     * const seatHolds = await prisma.seatHold.findMany()
     * 
     * // Get first 10 SeatHolds
     * const seatHolds = await prisma.seatHold.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seatHoldWithIdOnly = await prisma.seatHold.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeatHoldFindManyArgs>(args?: SelectSubset<T, SeatHoldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatHoldPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SeatHold.
     * @param {SeatHoldCreateArgs} args - Arguments to create a SeatHold.
     * @example
     * // Create one SeatHold
     * const SeatHold = await prisma.seatHold.create({
     *   data: {
     *     // ... data to create a SeatHold
     *   }
     * })
     * 
     */
    create<T extends SeatHoldCreateArgs>(args: SelectSubset<T, SeatHoldCreateArgs<ExtArgs>>): Prisma__SeatHoldClient<$Result.GetResult<Prisma.$SeatHoldPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SeatHolds.
     * @param {SeatHoldCreateManyArgs} args - Arguments to create many SeatHolds.
     * @example
     * // Create many SeatHolds
     * const seatHold = await prisma.seatHold.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeatHoldCreateManyArgs>(args?: SelectSubset<T, SeatHoldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SeatHolds and returns the data saved in the database.
     * @param {SeatHoldCreateManyAndReturnArgs} args - Arguments to create many SeatHolds.
     * @example
     * // Create many SeatHolds
     * const seatHold = await prisma.seatHold.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SeatHolds and only return the `id`
     * const seatHoldWithIdOnly = await prisma.seatHold.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeatHoldCreateManyAndReturnArgs>(args?: SelectSubset<T, SeatHoldCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeatHoldPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SeatHold.
     * @param {SeatHoldDeleteArgs} args - Arguments to delete one SeatHold.
     * @example
     * // Delete one SeatHold
     * const SeatHold = await prisma.seatHold.delete({
     *   where: {
     *     // ... filter to delete one SeatHold
     *   }
     * })
     * 
     */
    delete<T extends SeatHoldDeleteArgs>(args: SelectSubset<T, SeatHoldDeleteArgs<ExtArgs>>): Prisma__SeatHoldClient<$Result.GetResult<Prisma.$SeatHoldPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SeatHold.
     * @param {SeatHoldUpdateArgs} args - Arguments to update one SeatHold.
     * @example
     * // Update one SeatHold
     * const seatHold = await prisma.seatHold.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeatHoldUpdateArgs>(args: SelectSubset<T, SeatHoldUpdateArgs<ExtArgs>>): Prisma__SeatHoldClient<$Result.GetResult<Prisma.$SeatHoldPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SeatHolds.
     * @param {SeatHoldDeleteManyArgs} args - Arguments to filter SeatHolds to delete.
     * @example
     * // Delete a few SeatHolds
     * const { count } = await prisma.seatHold.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeatHoldDeleteManyArgs>(args?: SelectSubset<T, SeatHoldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeatHolds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatHoldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeatHolds
     * const seatHold = await prisma.seatHold.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeatHoldUpdateManyArgs>(args: SelectSubset<T, SeatHoldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SeatHold.
     * @param {SeatHoldUpsertArgs} args - Arguments to update or create a SeatHold.
     * @example
     * // Update or create a SeatHold
     * const seatHold = await prisma.seatHold.upsert({
     *   create: {
     *     // ... data to create a SeatHold
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeatHold we want to update
     *   }
     * })
     */
    upsert<T extends SeatHoldUpsertArgs>(args: SelectSubset<T, SeatHoldUpsertArgs<ExtArgs>>): Prisma__SeatHoldClient<$Result.GetResult<Prisma.$SeatHoldPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SeatHolds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatHoldCountArgs} args - Arguments to filter SeatHolds to count.
     * @example
     * // Count the number of SeatHolds
     * const count = await prisma.seatHold.count({
     *   where: {
     *     // ... the filter for the SeatHolds we want to count
     *   }
     * })
    **/
    count<T extends SeatHoldCountArgs>(
      args?: Subset<T, SeatHoldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeatHoldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SeatHold.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatHoldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeatHoldAggregateArgs>(args: Subset<T, SeatHoldAggregateArgs>): Prisma.PrismaPromise<GetSeatHoldAggregateType<T>>

    /**
     * Group by SeatHold.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeatHoldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeatHoldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeatHoldGroupByArgs['orderBy'] }
        : { orderBy?: SeatHoldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeatHoldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeatHoldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SeatHold model
   */
  readonly fields: SeatHoldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SeatHold.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeatHoldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seat<T extends SeatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeatDefaultArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    showing<T extends ShowingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShowingDefaultArgs<ExtArgs>>): Prisma__ShowingClient<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SeatHold model
   */ 
  interface SeatHoldFieldRefs {
    readonly id: FieldRef<"SeatHold", 'String'>
    readonly seatId: FieldRef<"SeatHold", 'String'>
    readonly showingId: FieldRef<"SeatHold", 'String'>
    readonly userId: FieldRef<"SeatHold", 'Int'>
    readonly createdAt: FieldRef<"SeatHold", 'DateTime'>
    readonly expiresAt: FieldRef<"SeatHold", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SeatHold findUnique
   */
  export type SeatHoldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatHold
     */
    select?: SeatHoldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatHoldInclude<ExtArgs> | null
    /**
     * Filter, which SeatHold to fetch.
     */
    where: SeatHoldWhereUniqueInput
  }

  /**
   * SeatHold findUniqueOrThrow
   */
  export type SeatHoldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatHold
     */
    select?: SeatHoldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatHoldInclude<ExtArgs> | null
    /**
     * Filter, which SeatHold to fetch.
     */
    where: SeatHoldWhereUniqueInput
  }

  /**
   * SeatHold findFirst
   */
  export type SeatHoldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatHold
     */
    select?: SeatHoldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatHoldInclude<ExtArgs> | null
    /**
     * Filter, which SeatHold to fetch.
     */
    where?: SeatHoldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeatHolds to fetch.
     */
    orderBy?: SeatHoldOrderByWithRelationInput | SeatHoldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeatHolds.
     */
    cursor?: SeatHoldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeatHolds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeatHolds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeatHolds.
     */
    distinct?: SeatHoldScalarFieldEnum | SeatHoldScalarFieldEnum[]
  }

  /**
   * SeatHold findFirstOrThrow
   */
  export type SeatHoldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatHold
     */
    select?: SeatHoldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatHoldInclude<ExtArgs> | null
    /**
     * Filter, which SeatHold to fetch.
     */
    where?: SeatHoldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeatHolds to fetch.
     */
    orderBy?: SeatHoldOrderByWithRelationInput | SeatHoldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeatHolds.
     */
    cursor?: SeatHoldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeatHolds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeatHolds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeatHolds.
     */
    distinct?: SeatHoldScalarFieldEnum | SeatHoldScalarFieldEnum[]
  }

  /**
   * SeatHold findMany
   */
  export type SeatHoldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatHold
     */
    select?: SeatHoldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatHoldInclude<ExtArgs> | null
    /**
     * Filter, which SeatHolds to fetch.
     */
    where?: SeatHoldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeatHolds to fetch.
     */
    orderBy?: SeatHoldOrderByWithRelationInput | SeatHoldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SeatHolds.
     */
    cursor?: SeatHoldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeatHolds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeatHolds.
     */
    skip?: number
    distinct?: SeatHoldScalarFieldEnum | SeatHoldScalarFieldEnum[]
  }

  /**
   * SeatHold create
   */
  export type SeatHoldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatHold
     */
    select?: SeatHoldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatHoldInclude<ExtArgs> | null
    /**
     * The data needed to create a SeatHold.
     */
    data: XOR<SeatHoldCreateInput, SeatHoldUncheckedCreateInput>
  }

  /**
   * SeatHold createMany
   */
  export type SeatHoldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SeatHolds.
     */
    data: SeatHoldCreateManyInput | SeatHoldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SeatHold createManyAndReturn
   */
  export type SeatHoldCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatHold
     */
    select?: SeatHoldSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SeatHolds.
     */
    data: SeatHoldCreateManyInput | SeatHoldCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatHoldIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SeatHold update
   */
  export type SeatHoldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatHold
     */
    select?: SeatHoldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatHoldInclude<ExtArgs> | null
    /**
     * The data needed to update a SeatHold.
     */
    data: XOR<SeatHoldUpdateInput, SeatHoldUncheckedUpdateInput>
    /**
     * Choose, which SeatHold to update.
     */
    where: SeatHoldWhereUniqueInput
  }

  /**
   * SeatHold updateMany
   */
  export type SeatHoldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SeatHolds.
     */
    data: XOR<SeatHoldUpdateManyMutationInput, SeatHoldUncheckedUpdateManyInput>
    /**
     * Filter which SeatHolds to update
     */
    where?: SeatHoldWhereInput
  }

  /**
   * SeatHold upsert
   */
  export type SeatHoldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatHold
     */
    select?: SeatHoldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatHoldInclude<ExtArgs> | null
    /**
     * The filter to search for the SeatHold to update in case it exists.
     */
    where: SeatHoldWhereUniqueInput
    /**
     * In case the SeatHold found by the `where` argument doesn't exist, create a new SeatHold with this data.
     */
    create: XOR<SeatHoldCreateInput, SeatHoldUncheckedCreateInput>
    /**
     * In case the SeatHold was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeatHoldUpdateInput, SeatHoldUncheckedUpdateInput>
  }

  /**
   * SeatHold delete
   */
  export type SeatHoldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatHold
     */
    select?: SeatHoldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatHoldInclude<ExtArgs> | null
    /**
     * Filter which SeatHold to delete.
     */
    where: SeatHoldWhereUniqueInput
  }

  /**
   * SeatHold deleteMany
   */
  export type SeatHoldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeatHolds to delete
     */
    where?: SeatHoldWhereInput
  }

  /**
   * SeatHold without action
   */
  export type SeatHoldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeatHold
     */
    select?: SeatHoldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeatHoldInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    totalPriceCents: number | null
    customerId: number | null
    soldById: number | null
  }

  export type BookingSumAggregateOutputType = {
    totalPriceCents: number | null
    customerId: number | null
    soldById: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    status: $Enums.BookingStatus | null
    channel: $Enums.PurchaseChannel | null
    totalPriceCents: number | null
    customerId: number | null
    soldById: number | null
    customerEmail: string | null
  }

  export type BookingMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    status: $Enums.BookingStatus | null
    channel: $Enums.PurchaseChannel | null
    totalPriceCents: number | null
    customerId: number | null
    soldById: number | null
    customerEmail: string | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    createdAt: number
    status: number
    channel: number
    totalPriceCents: number
    customerId: number
    soldById: number
    customerEmail: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    totalPriceCents?: true
    customerId?: true
    soldById?: true
  }

  export type BookingSumAggregateInputType = {
    totalPriceCents?: true
    customerId?: true
    soldById?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    createdAt?: true
    status?: true
    channel?: true
    totalPriceCents?: true
    customerId?: true
    soldById?: true
    customerEmail?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    createdAt?: true
    status?: true
    channel?: true
    totalPriceCents?: true
    customerId?: true
    soldById?: true
    customerEmail?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    createdAt?: true
    status?: true
    channel?: true
    totalPriceCents?: true
    customerId?: true
    soldById?: true
    customerEmail?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: string
    createdAt: Date
    status: $Enums.BookingStatus
    channel: $Enums.PurchaseChannel
    totalPriceCents: number
    customerId: number | null
    soldById: number | null
    customerEmail: string | null
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    status?: boolean
    channel?: boolean
    totalPriceCents?: boolean
    customerId?: boolean
    soldById?: boolean
    customerEmail?: boolean
    customer?: boolean | Booking$customerArgs<ExtArgs>
    soldBy?: boolean | Booking$soldByArgs<ExtArgs>
    tickets?: boolean | Booking$ticketsArgs<ExtArgs>
    credits?: boolean | Booking$creditsArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    status?: boolean
    channel?: boolean
    totalPriceCents?: boolean
    customerId?: boolean
    soldById?: boolean
    customerEmail?: boolean
    customer?: boolean | Booking$customerArgs<ExtArgs>
    soldBy?: boolean | Booking$soldByArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    createdAt?: boolean
    status?: boolean
    channel?: boolean
    totalPriceCents?: boolean
    customerId?: boolean
    soldById?: boolean
    customerEmail?: boolean
  }

  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Booking$customerArgs<ExtArgs>
    soldBy?: boolean | Booking$soldByArgs<ExtArgs>
    tickets?: boolean | Booking$ticketsArgs<ExtArgs>
    credits?: boolean | Booking$creditsArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Booking$customerArgs<ExtArgs>
    soldBy?: boolean | Booking$soldByArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      customer: Prisma.$UserPayload<ExtArgs> | null
      soldBy: Prisma.$UserPayload<ExtArgs> | null
      tickets: Prisma.$TicketPayload<ExtArgs>[]
      credits: Prisma.$CinemaCreditPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      status: $Enums.BookingStatus
      channel: $Enums.PurchaseChannel
      totalPriceCents: number
      customerId: number | null
      soldById: number | null
      customerEmail: string | null
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends Booking$customerArgs<ExtArgs> = {}>(args?: Subset<T, Booking$customerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    soldBy<T extends Booking$soldByArgs<ExtArgs> = {}>(args?: Subset<T, Booking$soldByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tickets<T extends Booking$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany"> | Null>
    credits<T extends Booking$creditsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$creditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CinemaCreditPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */ 
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'String'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
    readonly status: FieldRef<"Booking", 'BookingStatus'>
    readonly channel: FieldRef<"Booking", 'PurchaseChannel'>
    readonly totalPriceCents: FieldRef<"Booking", 'Int'>
    readonly customerId: FieldRef<"Booking", 'Int'>
    readonly soldById: FieldRef<"Booking", 'Int'>
    readonly customerEmail: FieldRef<"Booking", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
  }

  /**
   * Booking.customer
   */
  export type Booking$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Booking.soldBy
   */
  export type Booking$soldByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Booking.tickets
   */
  export type Booking$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Booking.credits
   */
  export type Booking$creditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaCredit
     */
    select?: CinemaCreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaCreditInclude<ExtArgs> | null
    where?: CinemaCreditWhereInput
    orderBy?: CinemaCreditOrderByWithRelationInput | CinemaCreditOrderByWithRelationInput[]
    cursor?: CinemaCreditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CinemaCreditScalarFieldEnum | CinemaCreditScalarFieldEnum[]
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model Ticket
   */

  export type AggregateTicket = {
    _count: TicketCountAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  export type TicketMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    seatId: string | null
    qrToken: string | null
    checkedInAt: Date | null
    createdAt: Date | null
  }

  export type TicketMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    seatId: string | null
    qrToken: string | null
    checkedInAt: Date | null
    createdAt: Date | null
  }

  export type TicketCountAggregateOutputType = {
    id: number
    bookingId: number
    seatId: number
    qrToken: number
    checkedInAt: number
    createdAt: number
    _all: number
  }


  export type TicketMinAggregateInputType = {
    id?: true
    bookingId?: true
    seatId?: true
    qrToken?: true
    checkedInAt?: true
    createdAt?: true
  }

  export type TicketMaxAggregateInputType = {
    id?: true
    bookingId?: true
    seatId?: true
    qrToken?: true
    checkedInAt?: true
    createdAt?: true
  }

  export type TicketCountAggregateInputType = {
    id?: true
    bookingId?: true
    seatId?: true
    qrToken?: true
    checkedInAt?: true
    createdAt?: true
    _all?: true
  }

  export type TicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ticket to aggregate.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tickets
    **/
    _count?: true | TicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMaxAggregateInputType
  }

  export type GetTicketAggregateType<T extends TicketAggregateArgs> = {
        [P in keyof T & keyof AggregateTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicket[P]>
      : GetScalarType<T[P], AggregateTicket[P]>
  }




  export type TicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithAggregationInput | TicketOrderByWithAggregationInput[]
    by: TicketScalarFieldEnum[] | TicketScalarFieldEnum
    having?: TicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCountAggregateInputType | true
    _min?: TicketMinAggregateInputType
    _max?: TicketMaxAggregateInputType
  }

  export type TicketGroupByOutputType = {
    id: string
    bookingId: string
    seatId: string
    qrToken: string
    checkedInAt: Date | null
    createdAt: Date
    _count: TicketCountAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  type GetTicketGroupByPayload<T extends TicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketGroupByOutputType[P]>
            : GetScalarType<T[P], TicketGroupByOutputType[P]>
        }
      >
    >


  export type TicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    seatId?: boolean
    qrToken?: boolean
    checkedInAt?: boolean
    createdAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    seat?: boolean | SeatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    seatId?: boolean
    qrToken?: boolean
    checkedInAt?: boolean
    createdAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    seat?: boolean | SeatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectScalar = {
    id?: boolean
    bookingId?: boolean
    seatId?: boolean
    qrToken?: boolean
    checkedInAt?: boolean
    createdAt?: boolean
  }

  export type TicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    seat?: boolean | SeatDefaultArgs<ExtArgs>
  }
  export type TicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    seat?: boolean | SeatDefaultArgs<ExtArgs>
  }

  export type $TicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ticket"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
      seat: Prisma.$SeatPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      seatId: string
      qrToken: string
      checkedInAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["ticket"]>
    composites: {}
  }

  type TicketGetPayload<S extends boolean | null | undefined | TicketDefaultArgs> = $Result.GetResult<Prisma.$TicketPayload, S>

  type TicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TicketFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TicketCountAggregateInputType | true
    }

  export interface TicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ticket'], meta: { name: 'Ticket' } }
    /**
     * Find zero or one Ticket that matches the filter.
     * @param {TicketFindUniqueArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketFindUniqueArgs>(args: SelectSubset<T, TicketFindUniqueArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ticket that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TicketFindUniqueOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ticket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketFindFirstArgs>(args?: SelectSubset<T, TicketFindFirstArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ticket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.ticket.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.ticket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketWithIdOnly = await prisma.ticket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketFindManyArgs>(args?: SelectSubset<T, TicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ticket.
     * @param {TicketCreateArgs} args - Arguments to create a Ticket.
     * @example
     * // Create one Ticket
     * const Ticket = await prisma.ticket.create({
     *   data: {
     *     // ... data to create a Ticket
     *   }
     * })
     * 
     */
    create<T extends TicketCreateArgs>(args: SelectSubset<T, TicketCreateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tickets.
     * @param {TicketCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCreateManyArgs>(args?: SelectSubset<T, TicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tickets and returns the data saved in the database.
     * @param {TicketCreateManyAndReturnArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Ticket.
     * @param {TicketDeleteArgs} args - Arguments to delete one Ticket.
     * @example
     * // Delete one Ticket
     * const Ticket = await prisma.ticket.delete({
     *   where: {
     *     // ... filter to delete one Ticket
     *   }
     * })
     * 
     */
    delete<T extends TicketDeleteArgs>(args: SelectSubset<T, TicketDeleteArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ticket.
     * @param {TicketUpdateArgs} args - Arguments to update one Ticket.
     * @example
     * // Update one Ticket
     * const ticket = await prisma.ticket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketUpdateArgs>(args: SelectSubset<T, TicketUpdateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tickets.
     * @param {TicketDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.ticket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketDeleteManyArgs>(args?: SelectSubset<T, TicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketUpdateManyArgs>(args: SelectSubset<T, TicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ticket.
     * @param {TicketUpsertArgs} args - Arguments to update or create a Ticket.
     * @example
     * // Update or create a Ticket
     * const ticket = await prisma.ticket.upsert({
     *   create: {
     *     // ... data to create a Ticket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ticket we want to update
     *   }
     * })
     */
    upsert<T extends TicketUpsertArgs>(args: SelectSubset<T, TicketUpsertArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.ticket.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends TicketCountArgs>(
      args?: Subset<T, TicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAggregateArgs>(args: Subset<T, TicketAggregateArgs>): Prisma.PrismaPromise<GetTicketAggregateType<T>>

    /**
     * Group by Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketGroupByArgs['orderBy'] }
        : { orderBy?: TicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ticket model
   */
  readonly fields: TicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ticket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    seat<T extends SeatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeatDefaultArgs<ExtArgs>>): Prisma__SeatClient<$Result.GetResult<Prisma.$SeatPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ticket model
   */ 
  interface TicketFieldRefs {
    readonly id: FieldRef<"Ticket", 'String'>
    readonly bookingId: FieldRef<"Ticket", 'String'>
    readonly seatId: FieldRef<"Ticket", 'String'>
    readonly qrToken: FieldRef<"Ticket", 'String'>
    readonly checkedInAt: FieldRef<"Ticket", 'DateTime'>
    readonly createdAt: FieldRef<"Ticket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ticket findUnique
   */
  export type TicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findUniqueOrThrow
   */
  export type TicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findFirst
   */
  export type TicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findFirstOrThrow
   */
  export type TicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findMany
   */
  export type TicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket create
   */
  export type TicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to create a Ticket.
     */
    data: XOR<TicketCreateInput, TicketUncheckedCreateInput>
  }

  /**
   * Ticket createMany
   */
  export type TicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ticket createManyAndReturn
   */
  export type TicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket update
   */
  export type TicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to update a Ticket.
     */
    data: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
    /**
     * Choose, which Ticket to update.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket updateMany
   */
  export type TicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
  }

  /**
   * Ticket upsert
   */
  export type TicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The filter to search for the Ticket to update in case it exists.
     */
    where: TicketWhereUniqueInput
    /**
     * In case the Ticket found by the `where` argument doesn't exist, create a new Ticket with this data.
     */
    create: XOR<TicketCreateInput, TicketUncheckedCreateInput>
    /**
     * In case the Ticket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
  }

  /**
   * Ticket delete
   */
  export type TicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter which Ticket to delete.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket deleteMany
   */
  export type TicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to delete
     */
    where?: TicketWhereInput
  }

  /**
   * Ticket without action
   */
  export type TicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
  }


  /**
   * Model CinemaCredit
   */

  export type AggregateCinemaCredit = {
    _count: CinemaCreditCountAggregateOutputType | null
    _avg: CinemaCreditAvgAggregateOutputType | null
    _sum: CinemaCreditSumAggregateOutputType | null
    _min: CinemaCreditMinAggregateOutputType | null
    _max: CinemaCreditMaxAggregateOutputType | null
  }

  export type CinemaCreditAvgAggregateOutputType = {
    userId: number | null
    amountCents: number | null
    remainingCents: number | null
  }

  export type CinemaCreditSumAggregateOutputType = {
    userId: number | null
    amountCents: number | null
    remainingCents: number | null
  }

  export type CinemaCreditMinAggregateOutputType = {
    id: string | null
    userId: number | null
    bookingId: string | null
    showingId: string | null
    amountCents: number | null
    remainingCents: number | null
    reason: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type CinemaCreditMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    bookingId: string | null
    showingId: string | null
    amountCents: number | null
    remainingCents: number | null
    reason: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type CinemaCreditCountAggregateOutputType = {
    id: number
    userId: number
    bookingId: number
    showingId: number
    amountCents: number
    remainingCents: number
    reason: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type CinemaCreditAvgAggregateInputType = {
    userId?: true
    amountCents?: true
    remainingCents?: true
  }

  export type CinemaCreditSumAggregateInputType = {
    userId?: true
    amountCents?: true
    remainingCents?: true
  }

  export type CinemaCreditMinAggregateInputType = {
    id?: true
    userId?: true
    bookingId?: true
    showingId?: true
    amountCents?: true
    remainingCents?: true
    reason?: true
    createdAt?: true
    expiresAt?: true
  }

  export type CinemaCreditMaxAggregateInputType = {
    id?: true
    userId?: true
    bookingId?: true
    showingId?: true
    amountCents?: true
    remainingCents?: true
    reason?: true
    createdAt?: true
    expiresAt?: true
  }

  export type CinemaCreditCountAggregateInputType = {
    id?: true
    userId?: true
    bookingId?: true
    showingId?: true
    amountCents?: true
    remainingCents?: true
    reason?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type CinemaCreditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CinemaCredit to aggregate.
     */
    where?: CinemaCreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CinemaCredits to fetch.
     */
    orderBy?: CinemaCreditOrderByWithRelationInput | CinemaCreditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CinemaCreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CinemaCredits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CinemaCredits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CinemaCredits
    **/
    _count?: true | CinemaCreditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CinemaCreditAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CinemaCreditSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CinemaCreditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CinemaCreditMaxAggregateInputType
  }

  export type GetCinemaCreditAggregateType<T extends CinemaCreditAggregateArgs> = {
        [P in keyof T & keyof AggregateCinemaCredit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCinemaCredit[P]>
      : GetScalarType<T[P], AggregateCinemaCredit[P]>
  }




  export type CinemaCreditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CinemaCreditWhereInput
    orderBy?: CinemaCreditOrderByWithAggregationInput | CinemaCreditOrderByWithAggregationInput[]
    by: CinemaCreditScalarFieldEnum[] | CinemaCreditScalarFieldEnum
    having?: CinemaCreditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CinemaCreditCountAggregateInputType | true
    _avg?: CinemaCreditAvgAggregateInputType
    _sum?: CinemaCreditSumAggregateInputType
    _min?: CinemaCreditMinAggregateInputType
    _max?: CinemaCreditMaxAggregateInputType
  }

  export type CinemaCreditGroupByOutputType = {
    id: string
    userId: number
    bookingId: string | null
    showingId: string | null
    amountCents: number
    remainingCents: number
    reason: string
    createdAt: Date
    expiresAt: Date | null
    _count: CinemaCreditCountAggregateOutputType | null
    _avg: CinemaCreditAvgAggregateOutputType | null
    _sum: CinemaCreditSumAggregateOutputType | null
    _min: CinemaCreditMinAggregateOutputType | null
    _max: CinemaCreditMaxAggregateOutputType | null
  }

  type GetCinemaCreditGroupByPayload<T extends CinemaCreditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CinemaCreditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CinemaCreditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CinemaCreditGroupByOutputType[P]>
            : GetScalarType<T[P], CinemaCreditGroupByOutputType[P]>
        }
      >
    >


  export type CinemaCreditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bookingId?: boolean
    showingId?: boolean
    amountCents?: boolean
    remainingCents?: boolean
    reason?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | CinemaCredit$bookingArgs<ExtArgs>
    showing?: boolean | CinemaCredit$showingArgs<ExtArgs>
  }, ExtArgs["result"]["cinemaCredit"]>

  export type CinemaCreditSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bookingId?: boolean
    showingId?: boolean
    amountCents?: boolean
    remainingCents?: boolean
    reason?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | CinemaCredit$bookingArgs<ExtArgs>
    showing?: boolean | CinemaCredit$showingArgs<ExtArgs>
  }, ExtArgs["result"]["cinemaCredit"]>

  export type CinemaCreditSelectScalar = {
    id?: boolean
    userId?: boolean
    bookingId?: boolean
    showingId?: boolean
    amountCents?: boolean
    remainingCents?: boolean
    reason?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type CinemaCreditInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | CinemaCredit$bookingArgs<ExtArgs>
    showing?: boolean | CinemaCredit$showingArgs<ExtArgs>
  }
  export type CinemaCreditIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | CinemaCredit$bookingArgs<ExtArgs>
    showing?: boolean | CinemaCredit$showingArgs<ExtArgs>
  }

  export type $CinemaCreditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CinemaCredit"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      booking: Prisma.$BookingPayload<ExtArgs> | null
      showing: Prisma.$ShowingPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number
      bookingId: string | null
      showingId: string | null
      amountCents: number
      remainingCents: number
      reason: string
      createdAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["cinemaCredit"]>
    composites: {}
  }

  type CinemaCreditGetPayload<S extends boolean | null | undefined | CinemaCreditDefaultArgs> = $Result.GetResult<Prisma.$CinemaCreditPayload, S>

  type CinemaCreditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CinemaCreditFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CinemaCreditCountAggregateInputType | true
    }

  export interface CinemaCreditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CinemaCredit'], meta: { name: 'CinemaCredit' } }
    /**
     * Find zero or one CinemaCredit that matches the filter.
     * @param {CinemaCreditFindUniqueArgs} args - Arguments to find a CinemaCredit
     * @example
     * // Get one CinemaCredit
     * const cinemaCredit = await prisma.cinemaCredit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CinemaCreditFindUniqueArgs>(args: SelectSubset<T, CinemaCreditFindUniqueArgs<ExtArgs>>): Prisma__CinemaCreditClient<$Result.GetResult<Prisma.$CinemaCreditPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CinemaCredit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CinemaCreditFindUniqueOrThrowArgs} args - Arguments to find a CinemaCredit
     * @example
     * // Get one CinemaCredit
     * const cinemaCredit = await prisma.cinemaCredit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CinemaCreditFindUniqueOrThrowArgs>(args: SelectSubset<T, CinemaCreditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CinemaCreditClient<$Result.GetResult<Prisma.$CinemaCreditPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CinemaCredit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaCreditFindFirstArgs} args - Arguments to find a CinemaCredit
     * @example
     * // Get one CinemaCredit
     * const cinemaCredit = await prisma.cinemaCredit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CinemaCreditFindFirstArgs>(args?: SelectSubset<T, CinemaCreditFindFirstArgs<ExtArgs>>): Prisma__CinemaCreditClient<$Result.GetResult<Prisma.$CinemaCreditPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CinemaCredit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaCreditFindFirstOrThrowArgs} args - Arguments to find a CinemaCredit
     * @example
     * // Get one CinemaCredit
     * const cinemaCredit = await prisma.cinemaCredit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CinemaCreditFindFirstOrThrowArgs>(args?: SelectSubset<T, CinemaCreditFindFirstOrThrowArgs<ExtArgs>>): Prisma__CinemaCreditClient<$Result.GetResult<Prisma.$CinemaCreditPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CinemaCredits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaCreditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CinemaCredits
     * const cinemaCredits = await prisma.cinemaCredit.findMany()
     * 
     * // Get first 10 CinemaCredits
     * const cinemaCredits = await prisma.cinemaCredit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cinemaCreditWithIdOnly = await prisma.cinemaCredit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CinemaCreditFindManyArgs>(args?: SelectSubset<T, CinemaCreditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CinemaCreditPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CinemaCredit.
     * @param {CinemaCreditCreateArgs} args - Arguments to create a CinemaCredit.
     * @example
     * // Create one CinemaCredit
     * const CinemaCredit = await prisma.cinemaCredit.create({
     *   data: {
     *     // ... data to create a CinemaCredit
     *   }
     * })
     * 
     */
    create<T extends CinemaCreditCreateArgs>(args: SelectSubset<T, CinemaCreditCreateArgs<ExtArgs>>): Prisma__CinemaCreditClient<$Result.GetResult<Prisma.$CinemaCreditPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CinemaCredits.
     * @param {CinemaCreditCreateManyArgs} args - Arguments to create many CinemaCredits.
     * @example
     * // Create many CinemaCredits
     * const cinemaCredit = await prisma.cinemaCredit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CinemaCreditCreateManyArgs>(args?: SelectSubset<T, CinemaCreditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CinemaCredits and returns the data saved in the database.
     * @param {CinemaCreditCreateManyAndReturnArgs} args - Arguments to create many CinemaCredits.
     * @example
     * // Create many CinemaCredits
     * const cinemaCredit = await prisma.cinemaCredit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CinemaCredits and only return the `id`
     * const cinemaCreditWithIdOnly = await prisma.cinemaCredit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CinemaCreditCreateManyAndReturnArgs>(args?: SelectSubset<T, CinemaCreditCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CinemaCreditPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CinemaCredit.
     * @param {CinemaCreditDeleteArgs} args - Arguments to delete one CinemaCredit.
     * @example
     * // Delete one CinemaCredit
     * const CinemaCredit = await prisma.cinemaCredit.delete({
     *   where: {
     *     // ... filter to delete one CinemaCredit
     *   }
     * })
     * 
     */
    delete<T extends CinemaCreditDeleteArgs>(args: SelectSubset<T, CinemaCreditDeleteArgs<ExtArgs>>): Prisma__CinemaCreditClient<$Result.GetResult<Prisma.$CinemaCreditPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CinemaCredit.
     * @param {CinemaCreditUpdateArgs} args - Arguments to update one CinemaCredit.
     * @example
     * // Update one CinemaCredit
     * const cinemaCredit = await prisma.cinemaCredit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CinemaCreditUpdateArgs>(args: SelectSubset<T, CinemaCreditUpdateArgs<ExtArgs>>): Prisma__CinemaCreditClient<$Result.GetResult<Prisma.$CinemaCreditPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CinemaCredits.
     * @param {CinemaCreditDeleteManyArgs} args - Arguments to filter CinemaCredits to delete.
     * @example
     * // Delete a few CinemaCredits
     * const { count } = await prisma.cinemaCredit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CinemaCreditDeleteManyArgs>(args?: SelectSubset<T, CinemaCreditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CinemaCredits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaCreditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CinemaCredits
     * const cinemaCredit = await prisma.cinemaCredit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CinemaCreditUpdateManyArgs>(args: SelectSubset<T, CinemaCreditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CinemaCredit.
     * @param {CinemaCreditUpsertArgs} args - Arguments to update or create a CinemaCredit.
     * @example
     * // Update or create a CinemaCredit
     * const cinemaCredit = await prisma.cinemaCredit.upsert({
     *   create: {
     *     // ... data to create a CinemaCredit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CinemaCredit we want to update
     *   }
     * })
     */
    upsert<T extends CinemaCreditUpsertArgs>(args: SelectSubset<T, CinemaCreditUpsertArgs<ExtArgs>>): Prisma__CinemaCreditClient<$Result.GetResult<Prisma.$CinemaCreditPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CinemaCredits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaCreditCountArgs} args - Arguments to filter CinemaCredits to count.
     * @example
     * // Count the number of CinemaCredits
     * const count = await prisma.cinemaCredit.count({
     *   where: {
     *     // ... the filter for the CinemaCredits we want to count
     *   }
     * })
    **/
    count<T extends CinemaCreditCountArgs>(
      args?: Subset<T, CinemaCreditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CinemaCreditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CinemaCredit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaCreditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CinemaCreditAggregateArgs>(args: Subset<T, CinemaCreditAggregateArgs>): Prisma.PrismaPromise<GetCinemaCreditAggregateType<T>>

    /**
     * Group by CinemaCredit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CinemaCreditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CinemaCreditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CinemaCreditGroupByArgs['orderBy'] }
        : { orderBy?: CinemaCreditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CinemaCreditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCinemaCreditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CinemaCredit model
   */
  readonly fields: CinemaCreditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CinemaCredit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CinemaCreditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    booking<T extends CinemaCredit$bookingArgs<ExtArgs> = {}>(args?: Subset<T, CinemaCredit$bookingArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    showing<T extends CinemaCredit$showingArgs<ExtArgs> = {}>(args?: Subset<T, CinemaCredit$showingArgs<ExtArgs>>): Prisma__ShowingClient<$Result.GetResult<Prisma.$ShowingPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CinemaCredit model
   */ 
  interface CinemaCreditFieldRefs {
    readonly id: FieldRef<"CinemaCredit", 'String'>
    readonly userId: FieldRef<"CinemaCredit", 'Int'>
    readonly bookingId: FieldRef<"CinemaCredit", 'String'>
    readonly showingId: FieldRef<"CinemaCredit", 'String'>
    readonly amountCents: FieldRef<"CinemaCredit", 'Int'>
    readonly remainingCents: FieldRef<"CinemaCredit", 'Int'>
    readonly reason: FieldRef<"CinemaCredit", 'String'>
    readonly createdAt: FieldRef<"CinemaCredit", 'DateTime'>
    readonly expiresAt: FieldRef<"CinemaCredit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CinemaCredit findUnique
   */
  export type CinemaCreditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaCredit
     */
    select?: CinemaCreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaCreditInclude<ExtArgs> | null
    /**
     * Filter, which CinemaCredit to fetch.
     */
    where: CinemaCreditWhereUniqueInput
  }

  /**
   * CinemaCredit findUniqueOrThrow
   */
  export type CinemaCreditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaCredit
     */
    select?: CinemaCreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaCreditInclude<ExtArgs> | null
    /**
     * Filter, which CinemaCredit to fetch.
     */
    where: CinemaCreditWhereUniqueInput
  }

  /**
   * CinemaCredit findFirst
   */
  export type CinemaCreditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaCredit
     */
    select?: CinemaCreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaCreditInclude<ExtArgs> | null
    /**
     * Filter, which CinemaCredit to fetch.
     */
    where?: CinemaCreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CinemaCredits to fetch.
     */
    orderBy?: CinemaCreditOrderByWithRelationInput | CinemaCreditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CinemaCredits.
     */
    cursor?: CinemaCreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CinemaCredits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CinemaCredits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CinemaCredits.
     */
    distinct?: CinemaCreditScalarFieldEnum | CinemaCreditScalarFieldEnum[]
  }

  /**
   * CinemaCredit findFirstOrThrow
   */
  export type CinemaCreditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaCredit
     */
    select?: CinemaCreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaCreditInclude<ExtArgs> | null
    /**
     * Filter, which CinemaCredit to fetch.
     */
    where?: CinemaCreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CinemaCredits to fetch.
     */
    orderBy?: CinemaCreditOrderByWithRelationInput | CinemaCreditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CinemaCredits.
     */
    cursor?: CinemaCreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CinemaCredits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CinemaCredits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CinemaCredits.
     */
    distinct?: CinemaCreditScalarFieldEnum | CinemaCreditScalarFieldEnum[]
  }

  /**
   * CinemaCredit findMany
   */
  export type CinemaCreditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaCredit
     */
    select?: CinemaCreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaCreditInclude<ExtArgs> | null
    /**
     * Filter, which CinemaCredits to fetch.
     */
    where?: CinemaCreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CinemaCredits to fetch.
     */
    orderBy?: CinemaCreditOrderByWithRelationInput | CinemaCreditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CinemaCredits.
     */
    cursor?: CinemaCreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CinemaCredits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CinemaCredits.
     */
    skip?: number
    distinct?: CinemaCreditScalarFieldEnum | CinemaCreditScalarFieldEnum[]
  }

  /**
   * CinemaCredit create
   */
  export type CinemaCreditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaCredit
     */
    select?: CinemaCreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaCreditInclude<ExtArgs> | null
    /**
     * The data needed to create a CinemaCredit.
     */
    data: XOR<CinemaCreditCreateInput, CinemaCreditUncheckedCreateInput>
  }

  /**
   * CinemaCredit createMany
   */
  export type CinemaCreditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CinemaCredits.
     */
    data: CinemaCreditCreateManyInput | CinemaCreditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CinemaCredit createManyAndReturn
   */
  export type CinemaCreditCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaCredit
     */
    select?: CinemaCreditSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CinemaCredits.
     */
    data: CinemaCreditCreateManyInput | CinemaCreditCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaCreditIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CinemaCredit update
   */
  export type CinemaCreditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaCredit
     */
    select?: CinemaCreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaCreditInclude<ExtArgs> | null
    /**
     * The data needed to update a CinemaCredit.
     */
    data: XOR<CinemaCreditUpdateInput, CinemaCreditUncheckedUpdateInput>
    /**
     * Choose, which CinemaCredit to update.
     */
    where: CinemaCreditWhereUniqueInput
  }

  /**
   * CinemaCredit updateMany
   */
  export type CinemaCreditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CinemaCredits.
     */
    data: XOR<CinemaCreditUpdateManyMutationInput, CinemaCreditUncheckedUpdateManyInput>
    /**
     * Filter which CinemaCredits to update
     */
    where?: CinemaCreditWhereInput
  }

  /**
   * CinemaCredit upsert
   */
  export type CinemaCreditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaCredit
     */
    select?: CinemaCreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaCreditInclude<ExtArgs> | null
    /**
     * The filter to search for the CinemaCredit to update in case it exists.
     */
    where: CinemaCreditWhereUniqueInput
    /**
     * In case the CinemaCredit found by the `where` argument doesn't exist, create a new CinemaCredit with this data.
     */
    create: XOR<CinemaCreditCreateInput, CinemaCreditUncheckedCreateInput>
    /**
     * In case the CinemaCredit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CinemaCreditUpdateInput, CinemaCreditUncheckedUpdateInput>
  }

  /**
   * CinemaCredit delete
   */
  export type CinemaCreditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaCredit
     */
    select?: CinemaCreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaCreditInclude<ExtArgs> | null
    /**
     * Filter which CinemaCredit to delete.
     */
    where: CinemaCreditWhereUniqueInput
  }

  /**
   * CinemaCredit deleteMany
   */
  export type CinemaCreditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CinemaCredits to delete
     */
    where?: CinemaCreditWhereInput
  }

  /**
   * CinemaCredit.booking
   */
  export type CinemaCredit$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
  }

  /**
   * CinemaCredit.showing
   */
  export type CinemaCredit$showingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showing
     */
    select?: ShowingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowingInclude<ExtArgs> | null
    where?: ShowingWhereInput
  }

  /**
   * CinemaCredit without action
   */
  export type CinemaCreditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CinemaCredit
     */
    select?: CinemaCreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CinemaCreditInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    lastName: 'lastName',
    email: 'email',
    password: 'password',
    type: 'type',
    dni: 'dni',
    role: 'role',
    availableHours: 'availableHours',
    availableMinutes: 'availableMinutes',
    usedHours: 'usedHours',
    recoveryCode: 'recoveryCode'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SellPointScalarFieldEnum: {
    id: 'id',
    address: 'address',
    street: 'street',
    streetNumber: 'streetNumber',
    availableHours: 'availableHours',
    usedHours: 'usedHours',
    pointName: 'pointName',
    dni: 'dni',
    userId: 'userId',
    profitPercentage: 'profitPercentage'
  };

  export type SellPointScalarFieldEnum = (typeof SellPointScalarFieldEnum)[keyof typeof SellPointScalarFieldEnum]


  export const PatentScalarFieldEnum: {
    id: 'id',
    patentId: 'patentId',
    userId: 'userId',
    createdAt: 'createdAt',
    hasSingleHours: 'hasSingleHours',
    singleHours: 'singleHours',
    dni: 'dni',
    isAllowed: 'isAllowed',
    canShow: 'canShow',
    isAllowedIn: 'isAllowedIn',
    houseType: 'houseType'
  };

  export type PatentScalarFieldEnum = (typeof PatentScalarFieldEnum)[keyof typeof PatentScalarFieldEnum]


  export const PatentValidationScalarFieldEnum: {
    id: 'id',
    patentId: 'patentId',
    validationsToday: 'validationsToday',
    validatedAt: 'validatedAt'
  };

  export type PatentValidationScalarFieldEnum = (typeof PatentValidationScalarFieldEnum)[keyof typeof PatentValidationScalarFieldEnum]


  export const DeletedPatentsScalarFieldEnum: {
    id: 'id',
    patentId: 'patentId',
    userId: 'userId',
    deletedAt: 'deletedAt'
  };

  export type DeletedPatentsScalarFieldEnum = (typeof DeletedPatentsScalarFieldEnum)[keyof typeof DeletedPatentsScalarFieldEnum]


  export const AssignHoursReportsScalarFieldEnum: {
    id: 'id',
    hoursAdded: 'hoursAdded',
    addedAt: 'addedAt',
    sellPointId: 'sellPointId',
    hourPrice: 'hourPrice',
    soldBy: 'soldBy'
  };

  export type AssignHoursReportsScalarFieldEnum = (typeof AssignHoursReportsScalarFieldEnum)[keyof typeof AssignHoursReportsScalarFieldEnum]


  export const AssignPatentHoursReportsScalarFieldEnum: {
    id: 'id',
    hoursAdded: 'hoursAdded',
    addedAt: 'addedAt',
    sellPointId: 'sellPointId',
    hourPrice: 'hourPrice',
    patentId: 'patentId',
    dni: 'dni',
    soldBy: 'soldBy'
  };

  export type AssignPatentHoursReportsScalarFieldEnum = (typeof AssignPatentHoursReportsScalarFieldEnum)[keyof typeof AssignPatentHoursReportsScalarFieldEnum]


  export const SellingHoursReportsScalarFieldEnum: {
    id: 'id',
    hoursAdded: 'hoursAdded',
    addedAt: 'addedAt',
    userId: 'userId',
    hourPrice: 'hourPrice',
    soldBy: 'soldBy',
    targetUserId: 'targetUserId'
  };

  export type SellingHoursReportsScalarFieldEnum = (typeof SellingHoursReportsScalarFieldEnum)[keyof typeof SellingHoursReportsScalarFieldEnum]


  export const UserHoursReportsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    hoursBought: 'hoursBought',
    boughtAt: 'boughtAt',
    hourPrice: 'hourPrice',
    soldBy: 'soldBy'
  };

  export type UserHoursReportsScalarFieldEnum = (typeof UserHoursReportsScalarFieldEnum)[keyof typeof UserHoursReportsScalarFieldEnum]


  export const UserParkingReportsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    startedAt: 'startedAt',
    finishedAt: 'finishedAt',
    patentId: 'patentId',
    totalHours: 'totalHours',
    hourPrice: 'hourPrice'
  };

  export type UserParkingReportsScalarFieldEnum = (typeof UserParkingReportsScalarFieldEnum)[keyof typeof UserParkingReportsScalarFieldEnum]


  export const HoursPricesScalarFieldEnum: {
    id: 'id',
    currency: 'currency',
    hourPrice: 'hourPrice',
    createdAt: 'createdAt',
    deleted: 'deleted',
    deletedAt: 'deletedAt',
    dayPrice: 'dayPrice',
    weekPrice: 'weekPrice'
  };

  export type HoursPricesScalarFieldEnum = (typeof HoursPricesScalarFieldEnum)[keyof typeof HoursPricesScalarFieldEnum]


  export const ParkingScalarFieldEnum: {
    id: 'id',
    hours: 'hours',
    startedAt: 'startedAt',
    finishedAt: 'finishedAt',
    patentId: 'patentId',
    userId: 'userId',
    isMonthly: 'isMonthly'
  };

  export type ParkingScalarFieldEnum = (typeof ParkingScalarFieldEnum)[keyof typeof ParkingScalarFieldEnum]


  export const InfractionScalarFieldEnum: {
    id: 'id',
    numberId: 'numberId',
    createdAt: 'createdAt',
    cancelled: 'cancelled',
    cancelledAt: 'cancelledAt',
    cancelledReason: 'cancelledReason',
    patentId: 'patentId',
    street: 'street',
    payed: 'payed',
    payedAt: 'payedAt',
    isEnableToPay: 'isEnableToPay',
    paymentMethod: 'paymentMethod',
    payedByUserId: 'payedByUserId'
  };

  export type InfractionScalarFieldEnum = (typeof InfractionScalarFieldEnum)[keyof typeof InfractionScalarFieldEnum]


  export const InfractionImageScalarFieldEnum: {
    id: 'id',
    url: 'url',
    infractionId: 'infractionId',
    createdAt: 'createdAt'
  };

  export type InfractionImageScalarFieldEnum = (typeof InfractionImageScalarFieldEnum)[keyof typeof InfractionImageScalarFieldEnum]


  export const SingleParkingComprobantScalarFieldEnum: {
    id: 'id',
    patentId: 'patentId',
    dni: 'dni',
    hours: 'hours',
    sellingPoint: 'sellingPoint',
    createdAt: 'createdAt'
  };

  export type SingleParkingComprobantScalarFieldEnum = (typeof SingleParkingComprobantScalarFieldEnum)[keyof typeof SingleParkingComprobantScalarFieldEnum]


  export const SellingHoursComprobantScalarFieldEnum: {
    id: 'id',
    dni: 'dni',
    hours: 'hours',
    sellingPoint: 'sellingPoint',
    price: 'price',
    createdAt: 'createdAt'
  };

  export type SellingHoursComprobantScalarFieldEnum = (typeof SellingHoursComprobantScalarFieldEnum)[keyof typeof SellingHoursComprobantScalarFieldEnum]


  export const HolidayScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    name: 'name',
    type: 'type',
    infoUrl: 'infoUrl',
    day: 'day',
    month: 'month',
    original: 'original',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HolidayScalarFieldEnum = (typeof HolidayScalarFieldEnum)[keyof typeof HolidayScalarFieldEnum]


  export const SellingPointHoursComprobantScalarFieldEnum: {
    id: 'id',
    dni: 'dni',
    hours: 'hours',
    sellingPoint: 'sellingPoint',
    sellerName: 'sellerName',
    price: 'price',
    createdAt: 'createdAt'
  };

  export type SellingPointHoursComprobantScalarFieldEnum = (typeof SellingPointHoursComprobantScalarFieldEnum)[keyof typeof SellingPointHoursComprobantScalarFieldEnum]


  export const SellingMonthlyComprobantScalarFieldEnum: {
    id: 'id',
    dni: 'dni',
    patentId: 'patentId',
    createdAt: 'createdAt',
    finishedAt: 'finishedAt',
    totalPrice: 'totalPrice',
    soldBy: 'soldBy'
  };

  export type SellingMonthlyComprobantScalarFieldEnum = (typeof SellingMonthlyComprobantScalarFieldEnum)[keyof typeof SellingMonthlyComprobantScalarFieldEnum]


  export const MovieScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    durationMinutes: 'durationMinutes',
    language: 'language',
    format: 'format',
    posterUrl: 'posterUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MovieScalarFieldEnum = (typeof MovieScalarFieldEnum)[keyof typeof MovieScalarFieldEnum]


  export const ShowingScalarFieldEnum: {
    id: 'id',
    movieId: 'movieId',
    startTime: 'startTime',
    priceCents: 'priceCents',
    rows: 'rows',
    seatsPerRow: 'seatsPerRow',
    totalSeats: 'totalSeats',
    status: 'status',
    cancelledAt: 'cancelledAt',
    createdAt: 'createdAt'
  };

  export type ShowingScalarFieldEnum = (typeof ShowingScalarFieldEnum)[keyof typeof ShowingScalarFieldEnum]


  export const SeatScalarFieldEnum: {
    id: 'id',
    showingId: 'showingId',
    rowLabel: 'rowLabel',
    number: 'number',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type SeatScalarFieldEnum = (typeof SeatScalarFieldEnum)[keyof typeof SeatScalarFieldEnum]


  export const SeatHoldScalarFieldEnum: {
    id: 'id',
    seatId: 'seatId',
    showingId: 'showingId',
    userId: 'userId',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type SeatHoldScalarFieldEnum = (typeof SeatHoldScalarFieldEnum)[keyof typeof SeatHoldScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    status: 'status',
    channel: 'channel',
    totalPriceCents: 'totalPriceCents',
    customerId: 'customerId',
    soldById: 'soldById',
    customerEmail: 'customerEmail'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const TicketScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    seatId: 'seatId',
    qrToken: 'qrToken',
    checkedInAt: 'checkedInAt',
    createdAt: 'createdAt'
  };

  export type TicketScalarFieldEnum = (typeof TicketScalarFieldEnum)[keyof typeof TicketScalarFieldEnum]


  export const CinemaCreditScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    bookingId: 'bookingId',
    showingId: 'showingId',
    amountCents: 'amountCents',
    remainingCents: 'remainingCents',
    reason: 'reason',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type CinemaCreditScalarFieldEnum = (typeof CinemaCreditScalarFieldEnum)[keyof typeof CinemaCreditScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Format'
   */
  export type EnumFormatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Format'>
    


  /**
   * Reference to a field of type 'Format[]'
   */
  export type ListEnumFormatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Format[]'>
    


  /**
   * Reference to a field of type 'ShowingStatus'
   */
  export type EnumShowingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShowingStatus'>
    


  /**
   * Reference to a field of type 'ShowingStatus[]'
   */
  export type ListEnumShowingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShowingStatus[]'>
    


  /**
   * Reference to a field of type 'SeatStatus'
   */
  export type EnumSeatStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SeatStatus'>
    


  /**
   * Reference to a field of type 'SeatStatus[]'
   */
  export type ListEnumSeatStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SeatStatus[]'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'PurchaseChannel'
   */
  export type EnumPurchaseChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseChannel'>
    


  /**
   * Reference to a field of type 'PurchaseChannel[]'
   */
  export type ListEnumPurchaseChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseChannel[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    type?: IntFilter<"User"> | number
    dni?: IntFilter<"User"> | number
    role?: EnumRoleFilter<"User"> | $Enums.Role
    availableHours?: IntNullableFilter<"User"> | number | null
    availableMinutes?: IntNullableFilter<"User"> | number | null
    usedHours?: IntNullableFilter<"User"> | number | null
    recoveryCode?: IntNullableFilter<"User"> | number | null
    patents?: PatentListRelationFilter
    deletedPatent?: DeletedPatentsListRelationFilter
    sellPoint?: SellPointListRelationFilter
    sellingHoursReports?: SellingHoursReportsListRelationFilter
    parking?: ParkingListRelationFilter
    userReports?: UserHoursReportsListRelationFilter
    userParkingReports?: UserParkingReportsListRelationFilter
    paidInfractions?: InfractionListRelationFilter
    receivedHoursSales?: SellingHoursReportsListRelationFilter
    bookings?: BookingListRelationFilter
    soldBookings?: BookingListRelationFilter
    seatHolds?: SeatHoldListRelationFilter
    cinemaCredits?: CinemaCreditListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    type?: SortOrder
    dni?: SortOrder
    role?: SortOrder
    availableHours?: SortOrderInput | SortOrder
    availableMinutes?: SortOrderInput | SortOrder
    usedHours?: SortOrderInput | SortOrder
    recoveryCode?: SortOrderInput | SortOrder
    patents?: PatentOrderByRelationAggregateInput
    deletedPatent?: DeletedPatentsOrderByRelationAggregateInput
    sellPoint?: SellPointOrderByRelationAggregateInput
    sellingHoursReports?: SellingHoursReportsOrderByRelationAggregateInput
    parking?: ParkingOrderByRelationAggregateInput
    userReports?: UserHoursReportsOrderByRelationAggregateInput
    userParkingReports?: UserParkingReportsOrderByRelationAggregateInput
    paidInfractions?: InfractionOrderByRelationAggregateInput
    receivedHoursSales?: SellingHoursReportsOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    soldBookings?: BookingOrderByRelationAggregateInput
    seatHolds?: SeatHoldOrderByRelationAggregateInput
    cinemaCredits?: CinemaCreditOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    dni?: number
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    type?: IntFilter<"User"> | number
    role?: EnumRoleFilter<"User"> | $Enums.Role
    availableHours?: IntNullableFilter<"User"> | number | null
    availableMinutes?: IntNullableFilter<"User"> | number | null
    usedHours?: IntNullableFilter<"User"> | number | null
    recoveryCode?: IntNullableFilter<"User"> | number | null
    patents?: PatentListRelationFilter
    deletedPatent?: DeletedPatentsListRelationFilter
    sellPoint?: SellPointListRelationFilter
    sellingHoursReports?: SellingHoursReportsListRelationFilter
    parking?: ParkingListRelationFilter
    userReports?: UserHoursReportsListRelationFilter
    userParkingReports?: UserParkingReportsListRelationFilter
    paidInfractions?: InfractionListRelationFilter
    receivedHoursSales?: SellingHoursReportsListRelationFilter
    bookings?: BookingListRelationFilter
    soldBookings?: BookingListRelationFilter
    seatHolds?: SeatHoldListRelationFilter
    cinemaCredits?: CinemaCreditListRelationFilter
  }, "id" | "id" | "email" | "dni">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    type?: SortOrder
    dni?: SortOrder
    role?: SortOrder
    availableHours?: SortOrderInput | SortOrder
    availableMinutes?: SortOrderInput | SortOrder
    usedHours?: SortOrderInput | SortOrder
    recoveryCode?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    type?: IntWithAggregatesFilter<"User"> | number
    dni?: IntWithAggregatesFilter<"User"> | number
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    availableHours?: IntNullableWithAggregatesFilter<"User"> | number | null
    availableMinutes?: IntNullableWithAggregatesFilter<"User"> | number | null
    usedHours?: IntNullableWithAggregatesFilter<"User"> | number | null
    recoveryCode?: IntNullableWithAggregatesFilter<"User"> | number | null
  }

  export type SellPointWhereInput = {
    AND?: SellPointWhereInput | SellPointWhereInput[]
    OR?: SellPointWhereInput[]
    NOT?: SellPointWhereInput | SellPointWhereInput[]
    id?: IntFilter<"SellPoint"> | number
    address?: StringFilter<"SellPoint"> | string
    street?: StringNullableFilter<"SellPoint"> | string | null
    streetNumber?: IntNullableFilter<"SellPoint"> | number | null
    availableHours?: IntFilter<"SellPoint"> | number
    usedHours?: IntFilter<"SellPoint"> | number
    pointName?: StringFilter<"SellPoint"> | string
    dni?: IntNullableFilter<"SellPoint"> | number | null
    userId?: IntNullableFilter<"SellPoint"> | number | null
    profitPercentage?: IntFilter<"SellPoint"> | number
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    reports?: AssignHoursReportsListRelationFilter
    patentReports?: AssignPatentHoursReportsListRelationFilter
  }

  export type SellPointOrderByWithRelationInput = {
    id?: SortOrder
    address?: SortOrder
    street?: SortOrderInput | SortOrder
    streetNumber?: SortOrderInput | SortOrder
    availableHours?: SortOrder
    usedHours?: SortOrder
    pointName?: SortOrder
    dni?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    profitPercentage?: SortOrder
    user?: UserOrderByWithRelationInput
    reports?: AssignHoursReportsOrderByRelationAggregateInput
    patentReports?: AssignPatentHoursReportsOrderByRelationAggregateInput
  }

  export type SellPointWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    dni?: number
    userId?: number
    AND?: SellPointWhereInput | SellPointWhereInput[]
    OR?: SellPointWhereInput[]
    NOT?: SellPointWhereInput | SellPointWhereInput[]
    address?: StringFilter<"SellPoint"> | string
    street?: StringNullableFilter<"SellPoint"> | string | null
    streetNumber?: IntNullableFilter<"SellPoint"> | number | null
    availableHours?: IntFilter<"SellPoint"> | number
    usedHours?: IntFilter<"SellPoint"> | number
    pointName?: StringFilter<"SellPoint"> | string
    profitPercentage?: IntFilter<"SellPoint"> | number
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    reports?: AssignHoursReportsListRelationFilter
    patentReports?: AssignPatentHoursReportsListRelationFilter
  }, "id" | "id" | "dni" | "userId">

  export type SellPointOrderByWithAggregationInput = {
    id?: SortOrder
    address?: SortOrder
    street?: SortOrderInput | SortOrder
    streetNumber?: SortOrderInput | SortOrder
    availableHours?: SortOrder
    usedHours?: SortOrder
    pointName?: SortOrder
    dni?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    profitPercentage?: SortOrder
    _count?: SellPointCountOrderByAggregateInput
    _avg?: SellPointAvgOrderByAggregateInput
    _max?: SellPointMaxOrderByAggregateInput
    _min?: SellPointMinOrderByAggregateInput
    _sum?: SellPointSumOrderByAggregateInput
  }

  export type SellPointScalarWhereWithAggregatesInput = {
    AND?: SellPointScalarWhereWithAggregatesInput | SellPointScalarWhereWithAggregatesInput[]
    OR?: SellPointScalarWhereWithAggregatesInput[]
    NOT?: SellPointScalarWhereWithAggregatesInput | SellPointScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SellPoint"> | number
    address?: StringWithAggregatesFilter<"SellPoint"> | string
    street?: StringNullableWithAggregatesFilter<"SellPoint"> | string | null
    streetNumber?: IntNullableWithAggregatesFilter<"SellPoint"> | number | null
    availableHours?: IntWithAggregatesFilter<"SellPoint"> | number
    usedHours?: IntWithAggregatesFilter<"SellPoint"> | number
    pointName?: StringWithAggregatesFilter<"SellPoint"> | string
    dni?: IntNullableWithAggregatesFilter<"SellPoint"> | number | null
    userId?: IntNullableWithAggregatesFilter<"SellPoint"> | number | null
    profitPercentage?: IntWithAggregatesFilter<"SellPoint"> | number
  }

  export type PatentWhereInput = {
    AND?: PatentWhereInput | PatentWhereInput[]
    OR?: PatentWhereInput[]
    NOT?: PatentWhereInput | PatentWhereInput[]
    id?: IntFilter<"Patent"> | number
    patentId?: StringFilter<"Patent"> | string
    userId?: IntNullableFilter<"Patent"> | number | null
    createdAt?: DateTimeFilter<"Patent"> | Date | string
    hasSingleHours?: BoolFilter<"Patent"> | boolean
    singleHours?: IntFilter<"Patent"> | number
    dni?: IntNullableFilter<"Patent"> | number | null
    isAllowed?: BoolFilter<"Patent"> | boolean
    canShow?: BoolFilter<"Patent"> | boolean
    isAllowedIn?: StringNullableFilter<"Patent"> | string | null
    houseType?: StringNullableFilter<"Patent"> | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type PatentOrderByWithRelationInput = {
    id?: SortOrder
    patentId?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    hasSingleHours?: SortOrder
    singleHours?: SortOrder
    dni?: SortOrderInput | SortOrder
    isAllowed?: SortOrder
    canShow?: SortOrder
    isAllowedIn?: SortOrderInput | SortOrder
    houseType?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PatentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PatentWhereInput | PatentWhereInput[]
    OR?: PatentWhereInput[]
    NOT?: PatentWhereInput | PatentWhereInput[]
    patentId?: StringFilter<"Patent"> | string
    userId?: IntNullableFilter<"Patent"> | number | null
    createdAt?: DateTimeFilter<"Patent"> | Date | string
    hasSingleHours?: BoolFilter<"Patent"> | boolean
    singleHours?: IntFilter<"Patent"> | number
    dni?: IntNullableFilter<"Patent"> | number | null
    isAllowed?: BoolFilter<"Patent"> | boolean
    canShow?: BoolFilter<"Patent"> | boolean
    isAllowedIn?: StringNullableFilter<"Patent"> | string | null
    houseType?: StringNullableFilter<"Patent"> | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "id">

  export type PatentOrderByWithAggregationInput = {
    id?: SortOrder
    patentId?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    hasSingleHours?: SortOrder
    singleHours?: SortOrder
    dni?: SortOrderInput | SortOrder
    isAllowed?: SortOrder
    canShow?: SortOrder
    isAllowedIn?: SortOrderInput | SortOrder
    houseType?: SortOrderInput | SortOrder
    _count?: PatentCountOrderByAggregateInput
    _avg?: PatentAvgOrderByAggregateInput
    _max?: PatentMaxOrderByAggregateInput
    _min?: PatentMinOrderByAggregateInput
    _sum?: PatentSumOrderByAggregateInput
  }

  export type PatentScalarWhereWithAggregatesInput = {
    AND?: PatentScalarWhereWithAggregatesInput | PatentScalarWhereWithAggregatesInput[]
    OR?: PatentScalarWhereWithAggregatesInput[]
    NOT?: PatentScalarWhereWithAggregatesInput | PatentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Patent"> | number
    patentId?: StringWithAggregatesFilter<"Patent"> | string
    userId?: IntNullableWithAggregatesFilter<"Patent"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Patent"> | Date | string
    hasSingleHours?: BoolWithAggregatesFilter<"Patent"> | boolean
    singleHours?: IntWithAggregatesFilter<"Patent"> | number
    dni?: IntNullableWithAggregatesFilter<"Patent"> | number | null
    isAllowed?: BoolWithAggregatesFilter<"Patent"> | boolean
    canShow?: BoolWithAggregatesFilter<"Patent"> | boolean
    isAllowedIn?: StringNullableWithAggregatesFilter<"Patent"> | string | null
    houseType?: StringNullableWithAggregatesFilter<"Patent"> | string | null
  }

  export type PatentValidationWhereInput = {
    AND?: PatentValidationWhereInput | PatentValidationWhereInput[]
    OR?: PatentValidationWhereInput[]
    NOT?: PatentValidationWhereInput | PatentValidationWhereInput[]
    id?: IntFilter<"PatentValidation"> | number
    patentId?: StringFilter<"PatentValidation"> | string
    validationsToday?: IntFilter<"PatentValidation"> | number
    validatedAt?: DateTimeNullableFilter<"PatentValidation"> | Date | string | null
  }

  export type PatentValidationOrderByWithRelationInput = {
    id?: SortOrder
    patentId?: SortOrder
    validationsToday?: SortOrder
    validatedAt?: SortOrderInput | SortOrder
  }

  export type PatentValidationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    patentId?: string
    AND?: PatentValidationWhereInput | PatentValidationWhereInput[]
    OR?: PatentValidationWhereInput[]
    NOT?: PatentValidationWhereInput | PatentValidationWhereInput[]
    validationsToday?: IntFilter<"PatentValidation"> | number
    validatedAt?: DateTimeNullableFilter<"PatentValidation"> | Date | string | null
  }, "id" | "id" | "patentId">

  export type PatentValidationOrderByWithAggregationInput = {
    id?: SortOrder
    patentId?: SortOrder
    validationsToday?: SortOrder
    validatedAt?: SortOrderInput | SortOrder
    _count?: PatentValidationCountOrderByAggregateInput
    _avg?: PatentValidationAvgOrderByAggregateInput
    _max?: PatentValidationMaxOrderByAggregateInput
    _min?: PatentValidationMinOrderByAggregateInput
    _sum?: PatentValidationSumOrderByAggregateInput
  }

  export type PatentValidationScalarWhereWithAggregatesInput = {
    AND?: PatentValidationScalarWhereWithAggregatesInput | PatentValidationScalarWhereWithAggregatesInput[]
    OR?: PatentValidationScalarWhereWithAggregatesInput[]
    NOT?: PatentValidationScalarWhereWithAggregatesInput | PatentValidationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PatentValidation"> | number
    patentId?: StringWithAggregatesFilter<"PatentValidation"> | string
    validationsToday?: IntWithAggregatesFilter<"PatentValidation"> | number
    validatedAt?: DateTimeNullableWithAggregatesFilter<"PatentValidation"> | Date | string | null
  }

  export type DeletedPatentsWhereInput = {
    AND?: DeletedPatentsWhereInput | DeletedPatentsWhereInput[]
    OR?: DeletedPatentsWhereInput[]
    NOT?: DeletedPatentsWhereInput | DeletedPatentsWhereInput[]
    id?: IntFilter<"DeletedPatents"> | number
    patentId?: StringFilter<"DeletedPatents"> | string
    userId?: IntFilter<"DeletedPatents"> | number
    deletedAt?: DateTimeNullableFilter<"DeletedPatents"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DeletedPatentsOrderByWithRelationInput = {
    id?: SortOrder
    patentId?: SortOrder
    userId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DeletedPatentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DeletedPatentsWhereInput | DeletedPatentsWhereInput[]
    OR?: DeletedPatentsWhereInput[]
    NOT?: DeletedPatentsWhereInput | DeletedPatentsWhereInput[]
    patentId?: StringFilter<"DeletedPatents"> | string
    userId?: IntFilter<"DeletedPatents"> | number
    deletedAt?: DateTimeNullableFilter<"DeletedPatents"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "id">

  export type DeletedPatentsOrderByWithAggregationInput = {
    id?: SortOrder
    patentId?: SortOrder
    userId?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: DeletedPatentsCountOrderByAggregateInput
    _avg?: DeletedPatentsAvgOrderByAggregateInput
    _max?: DeletedPatentsMaxOrderByAggregateInput
    _min?: DeletedPatentsMinOrderByAggregateInput
    _sum?: DeletedPatentsSumOrderByAggregateInput
  }

  export type DeletedPatentsScalarWhereWithAggregatesInput = {
    AND?: DeletedPatentsScalarWhereWithAggregatesInput | DeletedPatentsScalarWhereWithAggregatesInput[]
    OR?: DeletedPatentsScalarWhereWithAggregatesInput[]
    NOT?: DeletedPatentsScalarWhereWithAggregatesInput | DeletedPatentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DeletedPatents"> | number
    patentId?: StringWithAggregatesFilter<"DeletedPatents"> | string
    userId?: IntWithAggregatesFilter<"DeletedPatents"> | number
    deletedAt?: DateTimeNullableWithAggregatesFilter<"DeletedPatents"> | Date | string | null
  }

  export type AssignHoursReportsWhereInput = {
    AND?: AssignHoursReportsWhereInput | AssignHoursReportsWhereInput[]
    OR?: AssignHoursReportsWhereInput[]
    NOT?: AssignHoursReportsWhereInput | AssignHoursReportsWhereInput[]
    id?: StringFilter<"AssignHoursReports"> | string
    hoursAdded?: IntFilter<"AssignHoursReports"> | number
    addedAt?: DateTimeFilter<"AssignHoursReports"> | Date | string
    sellPointId?: IntFilter<"AssignHoursReports"> | number
    hourPrice?: FloatFilter<"AssignHoursReports"> | number
    soldBy?: IntNullableFilter<"AssignHoursReports"> | number | null
    sellPoint?: XOR<SellPointRelationFilter, SellPointWhereInput>
  }

  export type AssignHoursReportsOrderByWithRelationInput = {
    id?: SortOrder
    hoursAdded?: SortOrder
    addedAt?: SortOrder
    sellPointId?: SortOrder
    hourPrice?: SortOrder
    soldBy?: SortOrderInput | SortOrder
    sellPoint?: SellPointOrderByWithRelationInput
  }

  export type AssignHoursReportsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssignHoursReportsWhereInput | AssignHoursReportsWhereInput[]
    OR?: AssignHoursReportsWhereInput[]
    NOT?: AssignHoursReportsWhereInput | AssignHoursReportsWhereInput[]
    hoursAdded?: IntFilter<"AssignHoursReports"> | number
    addedAt?: DateTimeFilter<"AssignHoursReports"> | Date | string
    sellPointId?: IntFilter<"AssignHoursReports"> | number
    hourPrice?: FloatFilter<"AssignHoursReports"> | number
    soldBy?: IntNullableFilter<"AssignHoursReports"> | number | null
    sellPoint?: XOR<SellPointRelationFilter, SellPointWhereInput>
  }, "id" | "id">

  export type AssignHoursReportsOrderByWithAggregationInput = {
    id?: SortOrder
    hoursAdded?: SortOrder
    addedAt?: SortOrder
    sellPointId?: SortOrder
    hourPrice?: SortOrder
    soldBy?: SortOrderInput | SortOrder
    _count?: AssignHoursReportsCountOrderByAggregateInput
    _avg?: AssignHoursReportsAvgOrderByAggregateInput
    _max?: AssignHoursReportsMaxOrderByAggregateInput
    _min?: AssignHoursReportsMinOrderByAggregateInput
    _sum?: AssignHoursReportsSumOrderByAggregateInput
  }

  export type AssignHoursReportsScalarWhereWithAggregatesInput = {
    AND?: AssignHoursReportsScalarWhereWithAggregatesInput | AssignHoursReportsScalarWhereWithAggregatesInput[]
    OR?: AssignHoursReportsScalarWhereWithAggregatesInput[]
    NOT?: AssignHoursReportsScalarWhereWithAggregatesInput | AssignHoursReportsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AssignHoursReports"> | string
    hoursAdded?: IntWithAggregatesFilter<"AssignHoursReports"> | number
    addedAt?: DateTimeWithAggregatesFilter<"AssignHoursReports"> | Date | string
    sellPointId?: IntWithAggregatesFilter<"AssignHoursReports"> | number
    hourPrice?: FloatWithAggregatesFilter<"AssignHoursReports"> | number
    soldBy?: IntNullableWithAggregatesFilter<"AssignHoursReports"> | number | null
  }

  export type AssignPatentHoursReportsWhereInput = {
    AND?: AssignPatentHoursReportsWhereInput | AssignPatentHoursReportsWhereInput[]
    OR?: AssignPatentHoursReportsWhereInput[]
    NOT?: AssignPatentHoursReportsWhereInput | AssignPatentHoursReportsWhereInput[]
    id?: StringFilter<"AssignPatentHoursReports"> | string
    hoursAdded?: IntFilter<"AssignPatentHoursReports"> | number
    addedAt?: DateTimeFilter<"AssignPatentHoursReports"> | Date | string
    sellPointId?: IntNullableFilter<"AssignPatentHoursReports"> | number | null
    hourPrice?: FloatFilter<"AssignPatentHoursReports"> | number
    patentId?: StringFilter<"AssignPatentHoursReports"> | string
    dni?: IntFilter<"AssignPatentHoursReports"> | number
    soldBy?: IntNullableFilter<"AssignPatentHoursReports"> | number | null
    sellPoint?: XOR<SellPointNullableRelationFilter, SellPointWhereInput> | null
  }

  export type AssignPatentHoursReportsOrderByWithRelationInput = {
    id?: SortOrder
    hoursAdded?: SortOrder
    addedAt?: SortOrder
    sellPointId?: SortOrderInput | SortOrder
    hourPrice?: SortOrder
    patentId?: SortOrder
    dni?: SortOrder
    soldBy?: SortOrderInput | SortOrder
    sellPoint?: SellPointOrderByWithRelationInput
  }

  export type AssignPatentHoursReportsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssignPatentHoursReportsWhereInput | AssignPatentHoursReportsWhereInput[]
    OR?: AssignPatentHoursReportsWhereInput[]
    NOT?: AssignPatentHoursReportsWhereInput | AssignPatentHoursReportsWhereInput[]
    hoursAdded?: IntFilter<"AssignPatentHoursReports"> | number
    addedAt?: DateTimeFilter<"AssignPatentHoursReports"> | Date | string
    sellPointId?: IntNullableFilter<"AssignPatentHoursReports"> | number | null
    hourPrice?: FloatFilter<"AssignPatentHoursReports"> | number
    patentId?: StringFilter<"AssignPatentHoursReports"> | string
    dni?: IntFilter<"AssignPatentHoursReports"> | number
    soldBy?: IntNullableFilter<"AssignPatentHoursReports"> | number | null
    sellPoint?: XOR<SellPointNullableRelationFilter, SellPointWhereInput> | null
  }, "id" | "id">

  export type AssignPatentHoursReportsOrderByWithAggregationInput = {
    id?: SortOrder
    hoursAdded?: SortOrder
    addedAt?: SortOrder
    sellPointId?: SortOrderInput | SortOrder
    hourPrice?: SortOrder
    patentId?: SortOrder
    dni?: SortOrder
    soldBy?: SortOrderInput | SortOrder
    _count?: AssignPatentHoursReportsCountOrderByAggregateInput
    _avg?: AssignPatentHoursReportsAvgOrderByAggregateInput
    _max?: AssignPatentHoursReportsMaxOrderByAggregateInput
    _min?: AssignPatentHoursReportsMinOrderByAggregateInput
    _sum?: AssignPatentHoursReportsSumOrderByAggregateInput
  }

  export type AssignPatentHoursReportsScalarWhereWithAggregatesInput = {
    AND?: AssignPatentHoursReportsScalarWhereWithAggregatesInput | AssignPatentHoursReportsScalarWhereWithAggregatesInput[]
    OR?: AssignPatentHoursReportsScalarWhereWithAggregatesInput[]
    NOT?: AssignPatentHoursReportsScalarWhereWithAggregatesInput | AssignPatentHoursReportsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AssignPatentHoursReports"> | string
    hoursAdded?: IntWithAggregatesFilter<"AssignPatentHoursReports"> | number
    addedAt?: DateTimeWithAggregatesFilter<"AssignPatentHoursReports"> | Date | string
    sellPointId?: IntNullableWithAggregatesFilter<"AssignPatentHoursReports"> | number | null
    hourPrice?: FloatWithAggregatesFilter<"AssignPatentHoursReports"> | number
    patentId?: StringWithAggregatesFilter<"AssignPatentHoursReports"> | string
    dni?: IntWithAggregatesFilter<"AssignPatentHoursReports"> | number
    soldBy?: IntNullableWithAggregatesFilter<"AssignPatentHoursReports"> | number | null
  }

  export type SellingHoursReportsWhereInput = {
    AND?: SellingHoursReportsWhereInput | SellingHoursReportsWhereInput[]
    OR?: SellingHoursReportsWhereInput[]
    NOT?: SellingHoursReportsWhereInput | SellingHoursReportsWhereInput[]
    id?: StringFilter<"SellingHoursReports"> | string
    hoursAdded?: IntFilter<"SellingHoursReports"> | number
    addedAt?: DateTimeFilter<"SellingHoursReports"> | Date | string
    userId?: IntFilter<"SellingHoursReports"> | number
    hourPrice?: FloatFilter<"SellingHoursReports"> | number
    soldBy?: IntNullableFilter<"SellingHoursReports"> | number | null
    targetUserId?: IntNullableFilter<"SellingHoursReports"> | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    targetUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type SellingHoursReportsOrderByWithRelationInput = {
    id?: SortOrder
    hoursAdded?: SortOrder
    addedAt?: SortOrder
    userId?: SortOrder
    hourPrice?: SortOrder
    soldBy?: SortOrderInput | SortOrder
    targetUserId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    targetUser?: UserOrderByWithRelationInput
  }

  export type SellingHoursReportsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SellingHoursReportsWhereInput | SellingHoursReportsWhereInput[]
    OR?: SellingHoursReportsWhereInput[]
    NOT?: SellingHoursReportsWhereInput | SellingHoursReportsWhereInput[]
    hoursAdded?: IntFilter<"SellingHoursReports"> | number
    addedAt?: DateTimeFilter<"SellingHoursReports"> | Date | string
    userId?: IntFilter<"SellingHoursReports"> | number
    hourPrice?: FloatFilter<"SellingHoursReports"> | number
    soldBy?: IntNullableFilter<"SellingHoursReports"> | number | null
    targetUserId?: IntNullableFilter<"SellingHoursReports"> | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    targetUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "id">

  export type SellingHoursReportsOrderByWithAggregationInput = {
    id?: SortOrder
    hoursAdded?: SortOrder
    addedAt?: SortOrder
    userId?: SortOrder
    hourPrice?: SortOrder
    soldBy?: SortOrderInput | SortOrder
    targetUserId?: SortOrderInput | SortOrder
    _count?: SellingHoursReportsCountOrderByAggregateInput
    _avg?: SellingHoursReportsAvgOrderByAggregateInput
    _max?: SellingHoursReportsMaxOrderByAggregateInput
    _min?: SellingHoursReportsMinOrderByAggregateInput
    _sum?: SellingHoursReportsSumOrderByAggregateInput
  }

  export type SellingHoursReportsScalarWhereWithAggregatesInput = {
    AND?: SellingHoursReportsScalarWhereWithAggregatesInput | SellingHoursReportsScalarWhereWithAggregatesInput[]
    OR?: SellingHoursReportsScalarWhereWithAggregatesInput[]
    NOT?: SellingHoursReportsScalarWhereWithAggregatesInput | SellingHoursReportsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SellingHoursReports"> | string
    hoursAdded?: IntWithAggregatesFilter<"SellingHoursReports"> | number
    addedAt?: DateTimeWithAggregatesFilter<"SellingHoursReports"> | Date | string
    userId?: IntWithAggregatesFilter<"SellingHoursReports"> | number
    hourPrice?: FloatWithAggregatesFilter<"SellingHoursReports"> | number
    soldBy?: IntNullableWithAggregatesFilter<"SellingHoursReports"> | number | null
    targetUserId?: IntNullableWithAggregatesFilter<"SellingHoursReports"> | number | null
  }

  export type UserHoursReportsWhereInput = {
    AND?: UserHoursReportsWhereInput | UserHoursReportsWhereInput[]
    OR?: UserHoursReportsWhereInput[]
    NOT?: UserHoursReportsWhereInput | UserHoursReportsWhereInput[]
    id?: StringFilter<"UserHoursReports"> | string
    userId?: IntFilter<"UserHoursReports"> | number
    hoursBought?: IntFilter<"UserHoursReports"> | number
    boughtAt?: DateTimeFilter<"UserHoursReports"> | Date | string
    hourPrice?: FloatFilter<"UserHoursReports"> | number
    soldBy?: IntFilter<"UserHoursReports"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserHoursReportsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    hoursBought?: SortOrder
    boughtAt?: SortOrder
    hourPrice?: SortOrder
    soldBy?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserHoursReportsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserHoursReportsWhereInput | UserHoursReportsWhereInput[]
    OR?: UserHoursReportsWhereInput[]
    NOT?: UserHoursReportsWhereInput | UserHoursReportsWhereInput[]
    userId?: IntFilter<"UserHoursReports"> | number
    hoursBought?: IntFilter<"UserHoursReports"> | number
    boughtAt?: DateTimeFilter<"UserHoursReports"> | Date | string
    hourPrice?: FloatFilter<"UserHoursReports"> | number
    soldBy?: IntFilter<"UserHoursReports"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "id">

  export type UserHoursReportsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    hoursBought?: SortOrder
    boughtAt?: SortOrder
    hourPrice?: SortOrder
    soldBy?: SortOrder
    _count?: UserHoursReportsCountOrderByAggregateInput
    _avg?: UserHoursReportsAvgOrderByAggregateInput
    _max?: UserHoursReportsMaxOrderByAggregateInput
    _min?: UserHoursReportsMinOrderByAggregateInput
    _sum?: UserHoursReportsSumOrderByAggregateInput
  }

  export type UserHoursReportsScalarWhereWithAggregatesInput = {
    AND?: UserHoursReportsScalarWhereWithAggregatesInput | UserHoursReportsScalarWhereWithAggregatesInput[]
    OR?: UserHoursReportsScalarWhereWithAggregatesInput[]
    NOT?: UserHoursReportsScalarWhereWithAggregatesInput | UserHoursReportsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserHoursReports"> | string
    userId?: IntWithAggregatesFilter<"UserHoursReports"> | number
    hoursBought?: IntWithAggregatesFilter<"UserHoursReports"> | number
    boughtAt?: DateTimeWithAggregatesFilter<"UserHoursReports"> | Date | string
    hourPrice?: FloatWithAggregatesFilter<"UserHoursReports"> | number
    soldBy?: IntWithAggregatesFilter<"UserHoursReports"> | number
  }

  export type UserParkingReportsWhereInput = {
    AND?: UserParkingReportsWhereInput | UserParkingReportsWhereInput[]
    OR?: UserParkingReportsWhereInput[]
    NOT?: UserParkingReportsWhereInput | UserParkingReportsWhereInput[]
    id?: StringFilter<"UserParkingReports"> | string
    userId?: IntFilter<"UserParkingReports"> | number
    startedAt?: DateTimeFilter<"UserParkingReports"> | Date | string
    finishedAt?: DateTimeFilter<"UserParkingReports"> | Date | string
    patentId?: StringFilter<"UserParkingReports"> | string
    totalHours?: IntFilter<"UserParkingReports"> | number
    hourPrice?: FloatFilter<"UserParkingReports"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserParkingReportsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    patentId?: SortOrder
    totalHours?: SortOrder
    hourPrice?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserParkingReportsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserParkingReportsWhereInput | UserParkingReportsWhereInput[]
    OR?: UserParkingReportsWhereInput[]
    NOT?: UserParkingReportsWhereInput | UserParkingReportsWhereInput[]
    userId?: IntFilter<"UserParkingReports"> | number
    startedAt?: DateTimeFilter<"UserParkingReports"> | Date | string
    finishedAt?: DateTimeFilter<"UserParkingReports"> | Date | string
    patentId?: StringFilter<"UserParkingReports"> | string
    totalHours?: IntFilter<"UserParkingReports"> | number
    hourPrice?: FloatFilter<"UserParkingReports"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "id">

  export type UserParkingReportsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    patentId?: SortOrder
    totalHours?: SortOrder
    hourPrice?: SortOrder
    _count?: UserParkingReportsCountOrderByAggregateInput
    _avg?: UserParkingReportsAvgOrderByAggregateInput
    _max?: UserParkingReportsMaxOrderByAggregateInput
    _min?: UserParkingReportsMinOrderByAggregateInput
    _sum?: UserParkingReportsSumOrderByAggregateInput
  }

  export type UserParkingReportsScalarWhereWithAggregatesInput = {
    AND?: UserParkingReportsScalarWhereWithAggregatesInput | UserParkingReportsScalarWhereWithAggregatesInput[]
    OR?: UserParkingReportsScalarWhereWithAggregatesInput[]
    NOT?: UserParkingReportsScalarWhereWithAggregatesInput | UserParkingReportsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserParkingReports"> | string
    userId?: IntWithAggregatesFilter<"UserParkingReports"> | number
    startedAt?: DateTimeWithAggregatesFilter<"UserParkingReports"> | Date | string
    finishedAt?: DateTimeWithAggregatesFilter<"UserParkingReports"> | Date | string
    patentId?: StringWithAggregatesFilter<"UserParkingReports"> | string
    totalHours?: IntWithAggregatesFilter<"UserParkingReports"> | number
    hourPrice?: FloatWithAggregatesFilter<"UserParkingReports"> | number
  }

  export type HoursPricesWhereInput = {
    AND?: HoursPricesWhereInput | HoursPricesWhereInput[]
    OR?: HoursPricesWhereInput[]
    NOT?: HoursPricesWhereInput | HoursPricesWhereInput[]
    id?: IntFilter<"HoursPrices"> | number
    currency?: StringFilter<"HoursPrices"> | string
    hourPrice?: FloatFilter<"HoursPrices"> | number
    createdAt?: DateTimeFilter<"HoursPrices"> | Date | string
    deleted?: BoolFilter<"HoursPrices"> | boolean
    deletedAt?: DateTimeNullableFilter<"HoursPrices"> | Date | string | null
    dayPrice?: FloatNullableFilter<"HoursPrices"> | number | null
    weekPrice?: FloatNullableFilter<"HoursPrices"> | number | null
  }

  export type HoursPricesOrderByWithRelationInput = {
    id?: SortOrder
    currency?: SortOrder
    hourPrice?: SortOrder
    createdAt?: SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    dayPrice?: SortOrderInput | SortOrder
    weekPrice?: SortOrderInput | SortOrder
  }

  export type HoursPricesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HoursPricesWhereInput | HoursPricesWhereInput[]
    OR?: HoursPricesWhereInput[]
    NOT?: HoursPricesWhereInput | HoursPricesWhereInput[]
    currency?: StringFilter<"HoursPrices"> | string
    hourPrice?: FloatFilter<"HoursPrices"> | number
    createdAt?: DateTimeFilter<"HoursPrices"> | Date | string
    deleted?: BoolFilter<"HoursPrices"> | boolean
    deletedAt?: DateTimeNullableFilter<"HoursPrices"> | Date | string | null
    dayPrice?: FloatNullableFilter<"HoursPrices"> | number | null
    weekPrice?: FloatNullableFilter<"HoursPrices"> | number | null
  }, "id" | "id">

  export type HoursPricesOrderByWithAggregationInput = {
    id?: SortOrder
    currency?: SortOrder
    hourPrice?: SortOrder
    createdAt?: SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    dayPrice?: SortOrderInput | SortOrder
    weekPrice?: SortOrderInput | SortOrder
    _count?: HoursPricesCountOrderByAggregateInput
    _avg?: HoursPricesAvgOrderByAggregateInput
    _max?: HoursPricesMaxOrderByAggregateInput
    _min?: HoursPricesMinOrderByAggregateInput
    _sum?: HoursPricesSumOrderByAggregateInput
  }

  export type HoursPricesScalarWhereWithAggregatesInput = {
    AND?: HoursPricesScalarWhereWithAggregatesInput | HoursPricesScalarWhereWithAggregatesInput[]
    OR?: HoursPricesScalarWhereWithAggregatesInput[]
    NOT?: HoursPricesScalarWhereWithAggregatesInput | HoursPricesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HoursPrices"> | number
    currency?: StringWithAggregatesFilter<"HoursPrices"> | string
    hourPrice?: FloatWithAggregatesFilter<"HoursPrices"> | number
    createdAt?: DateTimeWithAggregatesFilter<"HoursPrices"> | Date | string
    deleted?: BoolWithAggregatesFilter<"HoursPrices"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"HoursPrices"> | Date | string | null
    dayPrice?: FloatNullableWithAggregatesFilter<"HoursPrices"> | number | null
    weekPrice?: FloatNullableWithAggregatesFilter<"HoursPrices"> | number | null
  }

  export type ParkingWhereInput = {
    AND?: ParkingWhereInput | ParkingWhereInput[]
    OR?: ParkingWhereInput[]
    NOT?: ParkingWhereInput | ParkingWhereInput[]
    id?: StringFilter<"Parking"> | string
    hours?: IntFilter<"Parking"> | number
    startedAt?: DateTimeFilter<"Parking"> | Date | string
    finishedAt?: DateTimeNullableFilter<"Parking"> | Date | string | null
    patentId?: StringFilter<"Parking"> | string
    userId?: IntNullableFilter<"Parking"> | number | null
    isMonthly?: BoolFilter<"Parking"> | boolean
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ParkingOrderByWithRelationInput = {
    id?: SortOrder
    hours?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    patentId?: SortOrder
    userId?: SortOrderInput | SortOrder
    isMonthly?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ParkingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ParkingWhereInput | ParkingWhereInput[]
    OR?: ParkingWhereInput[]
    NOT?: ParkingWhereInput | ParkingWhereInput[]
    hours?: IntFilter<"Parking"> | number
    startedAt?: DateTimeFilter<"Parking"> | Date | string
    finishedAt?: DateTimeNullableFilter<"Parking"> | Date | string | null
    patentId?: StringFilter<"Parking"> | string
    userId?: IntNullableFilter<"Parking"> | number | null
    isMonthly?: BoolFilter<"Parking"> | boolean
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "id">

  export type ParkingOrderByWithAggregationInput = {
    id?: SortOrder
    hours?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    patentId?: SortOrder
    userId?: SortOrderInput | SortOrder
    isMonthly?: SortOrder
    _count?: ParkingCountOrderByAggregateInput
    _avg?: ParkingAvgOrderByAggregateInput
    _max?: ParkingMaxOrderByAggregateInput
    _min?: ParkingMinOrderByAggregateInput
    _sum?: ParkingSumOrderByAggregateInput
  }

  export type ParkingScalarWhereWithAggregatesInput = {
    AND?: ParkingScalarWhereWithAggregatesInput | ParkingScalarWhereWithAggregatesInput[]
    OR?: ParkingScalarWhereWithAggregatesInput[]
    NOT?: ParkingScalarWhereWithAggregatesInput | ParkingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Parking"> | string
    hours?: IntWithAggregatesFilter<"Parking"> | number
    startedAt?: DateTimeWithAggregatesFilter<"Parking"> | Date | string
    finishedAt?: DateTimeNullableWithAggregatesFilter<"Parking"> | Date | string | null
    patentId?: StringWithAggregatesFilter<"Parking"> | string
    userId?: IntNullableWithAggregatesFilter<"Parking"> | number | null
    isMonthly?: BoolWithAggregatesFilter<"Parking"> | boolean
  }

  export type InfractionWhereInput = {
    AND?: InfractionWhereInput | InfractionWhereInput[]
    OR?: InfractionWhereInput[]
    NOT?: InfractionWhereInput | InfractionWhereInput[]
    id?: StringFilter<"Infraction"> | string
    numberId?: IntFilter<"Infraction"> | number
    createdAt?: DateTimeFilter<"Infraction"> | Date | string
    cancelled?: BoolFilter<"Infraction"> | boolean
    cancelledAt?: DateTimeNullableFilter<"Infraction"> | Date | string | null
    cancelledReason?: StringNullableFilter<"Infraction"> | string | null
    patentId?: StringFilter<"Infraction"> | string
    street?: StringNullableFilter<"Infraction"> | string | null
    payed?: BoolFilter<"Infraction"> | boolean
    payedAt?: DateTimeNullableFilter<"Infraction"> | Date | string | null
    isEnableToPay?: BoolNullableFilter<"Infraction"> | boolean | null
    paymentMethod?: StringNullableFilter<"Infraction"> | string | null
    payedByUserId?: IntNullableFilter<"Infraction"> | number | null
    images?: InfractionImageListRelationFilter
    payedByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type InfractionOrderByWithRelationInput = {
    id?: SortOrder
    numberId?: SortOrder
    createdAt?: SortOrder
    cancelled?: SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancelledReason?: SortOrderInput | SortOrder
    patentId?: SortOrder
    street?: SortOrderInput | SortOrder
    payed?: SortOrder
    payedAt?: SortOrderInput | SortOrder
    isEnableToPay?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    payedByUserId?: SortOrderInput | SortOrder
    images?: InfractionImageOrderByRelationAggregateInput
    payedByUser?: UserOrderByWithRelationInput
  }

  export type InfractionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    numberId?: number
    AND?: InfractionWhereInput | InfractionWhereInput[]
    OR?: InfractionWhereInput[]
    NOT?: InfractionWhereInput | InfractionWhereInput[]
    createdAt?: DateTimeFilter<"Infraction"> | Date | string
    cancelled?: BoolFilter<"Infraction"> | boolean
    cancelledAt?: DateTimeNullableFilter<"Infraction"> | Date | string | null
    cancelledReason?: StringNullableFilter<"Infraction"> | string | null
    patentId?: StringFilter<"Infraction"> | string
    street?: StringNullableFilter<"Infraction"> | string | null
    payed?: BoolFilter<"Infraction"> | boolean
    payedAt?: DateTimeNullableFilter<"Infraction"> | Date | string | null
    isEnableToPay?: BoolNullableFilter<"Infraction"> | boolean | null
    paymentMethod?: StringNullableFilter<"Infraction"> | string | null
    payedByUserId?: IntNullableFilter<"Infraction"> | number | null
    images?: InfractionImageListRelationFilter
    payedByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "id" | "numberId">

  export type InfractionOrderByWithAggregationInput = {
    id?: SortOrder
    numberId?: SortOrder
    createdAt?: SortOrder
    cancelled?: SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancelledReason?: SortOrderInput | SortOrder
    patentId?: SortOrder
    street?: SortOrderInput | SortOrder
    payed?: SortOrder
    payedAt?: SortOrderInput | SortOrder
    isEnableToPay?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    payedByUserId?: SortOrderInput | SortOrder
    _count?: InfractionCountOrderByAggregateInput
    _avg?: InfractionAvgOrderByAggregateInput
    _max?: InfractionMaxOrderByAggregateInput
    _min?: InfractionMinOrderByAggregateInput
    _sum?: InfractionSumOrderByAggregateInput
  }

  export type InfractionScalarWhereWithAggregatesInput = {
    AND?: InfractionScalarWhereWithAggregatesInput | InfractionScalarWhereWithAggregatesInput[]
    OR?: InfractionScalarWhereWithAggregatesInput[]
    NOT?: InfractionScalarWhereWithAggregatesInput | InfractionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Infraction"> | string
    numberId?: IntWithAggregatesFilter<"Infraction"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Infraction"> | Date | string
    cancelled?: BoolWithAggregatesFilter<"Infraction"> | boolean
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Infraction"> | Date | string | null
    cancelledReason?: StringNullableWithAggregatesFilter<"Infraction"> | string | null
    patentId?: StringWithAggregatesFilter<"Infraction"> | string
    street?: StringNullableWithAggregatesFilter<"Infraction"> | string | null
    payed?: BoolWithAggregatesFilter<"Infraction"> | boolean
    payedAt?: DateTimeNullableWithAggregatesFilter<"Infraction"> | Date | string | null
    isEnableToPay?: BoolNullableWithAggregatesFilter<"Infraction"> | boolean | null
    paymentMethod?: StringNullableWithAggregatesFilter<"Infraction"> | string | null
    payedByUserId?: IntNullableWithAggregatesFilter<"Infraction"> | number | null
  }

  export type InfractionImageWhereInput = {
    AND?: InfractionImageWhereInput | InfractionImageWhereInput[]
    OR?: InfractionImageWhereInput[]
    NOT?: InfractionImageWhereInput | InfractionImageWhereInput[]
    id?: StringFilter<"InfractionImage"> | string
    url?: StringFilter<"InfractionImage"> | string
    infractionId?: StringFilter<"InfractionImage"> | string
    createdAt?: DateTimeFilter<"InfractionImage"> | Date | string
    infraction?: XOR<InfractionRelationFilter, InfractionWhereInput>
  }

  export type InfractionImageOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    infractionId?: SortOrder
    createdAt?: SortOrder
    infraction?: InfractionOrderByWithRelationInput
  }

  export type InfractionImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InfractionImageWhereInput | InfractionImageWhereInput[]
    OR?: InfractionImageWhereInput[]
    NOT?: InfractionImageWhereInput | InfractionImageWhereInput[]
    url?: StringFilter<"InfractionImage"> | string
    infractionId?: StringFilter<"InfractionImage"> | string
    createdAt?: DateTimeFilter<"InfractionImage"> | Date | string
    infraction?: XOR<InfractionRelationFilter, InfractionWhereInput>
  }, "id" | "id">

  export type InfractionImageOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    infractionId?: SortOrder
    createdAt?: SortOrder
    _count?: InfractionImageCountOrderByAggregateInput
    _max?: InfractionImageMaxOrderByAggregateInput
    _min?: InfractionImageMinOrderByAggregateInput
  }

  export type InfractionImageScalarWhereWithAggregatesInput = {
    AND?: InfractionImageScalarWhereWithAggregatesInput | InfractionImageScalarWhereWithAggregatesInput[]
    OR?: InfractionImageScalarWhereWithAggregatesInput[]
    NOT?: InfractionImageScalarWhereWithAggregatesInput | InfractionImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InfractionImage"> | string
    url?: StringWithAggregatesFilter<"InfractionImage"> | string
    infractionId?: StringWithAggregatesFilter<"InfractionImage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"InfractionImage"> | Date | string
  }

  export type SingleParkingComprobantWhereInput = {
    AND?: SingleParkingComprobantWhereInput | SingleParkingComprobantWhereInput[]
    OR?: SingleParkingComprobantWhereInput[]
    NOT?: SingleParkingComprobantWhereInput | SingleParkingComprobantWhereInput[]
    id?: IntFilter<"SingleParkingComprobant"> | number
    patentId?: StringFilter<"SingleParkingComprobant"> | string
    dni?: IntFilter<"SingleParkingComprobant"> | number
    hours?: IntFilter<"SingleParkingComprobant"> | number
    sellingPoint?: StringFilter<"SingleParkingComprobant"> | string
    createdAt?: DateTimeFilter<"SingleParkingComprobant"> | Date | string
  }

  export type SingleParkingComprobantOrderByWithRelationInput = {
    id?: SortOrder
    patentId?: SortOrder
    dni?: SortOrder
    hours?: SortOrder
    sellingPoint?: SortOrder
    createdAt?: SortOrder
  }

  export type SingleParkingComprobantWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SingleParkingComprobantWhereInput | SingleParkingComprobantWhereInput[]
    OR?: SingleParkingComprobantWhereInput[]
    NOT?: SingleParkingComprobantWhereInput | SingleParkingComprobantWhereInput[]
    patentId?: StringFilter<"SingleParkingComprobant"> | string
    dni?: IntFilter<"SingleParkingComprobant"> | number
    hours?: IntFilter<"SingleParkingComprobant"> | number
    sellingPoint?: StringFilter<"SingleParkingComprobant"> | string
    createdAt?: DateTimeFilter<"SingleParkingComprobant"> | Date | string
  }, "id" | "id">

  export type SingleParkingComprobantOrderByWithAggregationInput = {
    id?: SortOrder
    patentId?: SortOrder
    dni?: SortOrder
    hours?: SortOrder
    sellingPoint?: SortOrder
    createdAt?: SortOrder
    _count?: SingleParkingComprobantCountOrderByAggregateInput
    _avg?: SingleParkingComprobantAvgOrderByAggregateInput
    _max?: SingleParkingComprobantMaxOrderByAggregateInput
    _min?: SingleParkingComprobantMinOrderByAggregateInput
    _sum?: SingleParkingComprobantSumOrderByAggregateInput
  }

  export type SingleParkingComprobantScalarWhereWithAggregatesInput = {
    AND?: SingleParkingComprobantScalarWhereWithAggregatesInput | SingleParkingComprobantScalarWhereWithAggregatesInput[]
    OR?: SingleParkingComprobantScalarWhereWithAggregatesInput[]
    NOT?: SingleParkingComprobantScalarWhereWithAggregatesInput | SingleParkingComprobantScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SingleParkingComprobant"> | number
    patentId?: StringWithAggregatesFilter<"SingleParkingComprobant"> | string
    dni?: IntWithAggregatesFilter<"SingleParkingComprobant"> | number
    hours?: IntWithAggregatesFilter<"SingleParkingComprobant"> | number
    sellingPoint?: StringWithAggregatesFilter<"SingleParkingComprobant"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SingleParkingComprobant"> | Date | string
  }

  export type SellingHoursComprobantWhereInput = {
    AND?: SellingHoursComprobantWhereInput | SellingHoursComprobantWhereInput[]
    OR?: SellingHoursComprobantWhereInput[]
    NOT?: SellingHoursComprobantWhereInput | SellingHoursComprobantWhereInput[]
    id?: IntFilter<"SellingHoursComprobant"> | number
    dni?: IntFilter<"SellingHoursComprobant"> | number
    hours?: IntFilter<"SellingHoursComprobant"> | number
    sellingPoint?: StringFilter<"SellingHoursComprobant"> | string
    price?: IntFilter<"SellingHoursComprobant"> | number
    createdAt?: DateTimeFilter<"SellingHoursComprobant"> | Date | string
  }

  export type SellingHoursComprobantOrderByWithRelationInput = {
    id?: SortOrder
    dni?: SortOrder
    hours?: SortOrder
    sellingPoint?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type SellingHoursComprobantWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SellingHoursComprobantWhereInput | SellingHoursComprobantWhereInput[]
    OR?: SellingHoursComprobantWhereInput[]
    NOT?: SellingHoursComprobantWhereInput | SellingHoursComprobantWhereInput[]
    dni?: IntFilter<"SellingHoursComprobant"> | number
    hours?: IntFilter<"SellingHoursComprobant"> | number
    sellingPoint?: StringFilter<"SellingHoursComprobant"> | string
    price?: IntFilter<"SellingHoursComprobant"> | number
    createdAt?: DateTimeFilter<"SellingHoursComprobant"> | Date | string
  }, "id" | "id">

  export type SellingHoursComprobantOrderByWithAggregationInput = {
    id?: SortOrder
    dni?: SortOrder
    hours?: SortOrder
    sellingPoint?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    _count?: SellingHoursComprobantCountOrderByAggregateInput
    _avg?: SellingHoursComprobantAvgOrderByAggregateInput
    _max?: SellingHoursComprobantMaxOrderByAggregateInput
    _min?: SellingHoursComprobantMinOrderByAggregateInput
    _sum?: SellingHoursComprobantSumOrderByAggregateInput
  }

  export type SellingHoursComprobantScalarWhereWithAggregatesInput = {
    AND?: SellingHoursComprobantScalarWhereWithAggregatesInput | SellingHoursComprobantScalarWhereWithAggregatesInput[]
    OR?: SellingHoursComprobantScalarWhereWithAggregatesInput[]
    NOT?: SellingHoursComprobantScalarWhereWithAggregatesInput | SellingHoursComprobantScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SellingHoursComprobant"> | number
    dni?: IntWithAggregatesFilter<"SellingHoursComprobant"> | number
    hours?: IntWithAggregatesFilter<"SellingHoursComprobant"> | number
    sellingPoint?: StringWithAggregatesFilter<"SellingHoursComprobant"> | string
    price?: IntWithAggregatesFilter<"SellingHoursComprobant"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SellingHoursComprobant"> | Date | string
  }

  export type HolidayWhereInput = {
    AND?: HolidayWhereInput | HolidayWhereInput[]
    OR?: HolidayWhereInput[]
    NOT?: HolidayWhereInput | HolidayWhereInput[]
    id?: IntFilter<"Holiday"> | number
    identifier?: StringFilter<"Holiday"> | string
    name?: StringFilter<"Holiday"> | string
    type?: StringFilter<"Holiday"> | string
    infoUrl?: StringNullableFilter<"Holiday"> | string | null
    day?: IntFilter<"Holiday"> | number
    month?: IntFilter<"Holiday"> | number
    original?: StringNullableFilter<"Holiday"> | string | null
    createdAt?: DateTimeFilter<"Holiday"> | Date | string
    updatedAt?: DateTimeFilter<"Holiday"> | Date | string
  }

  export type HolidayOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    name?: SortOrder
    type?: SortOrder
    infoUrl?: SortOrderInput | SortOrder
    day?: SortOrder
    month?: SortOrder
    original?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HolidayWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    identifier?: string
    AND?: HolidayWhereInput | HolidayWhereInput[]
    OR?: HolidayWhereInput[]
    NOT?: HolidayWhereInput | HolidayWhereInput[]
    name?: StringFilter<"Holiday"> | string
    type?: StringFilter<"Holiday"> | string
    infoUrl?: StringNullableFilter<"Holiday"> | string | null
    day?: IntFilter<"Holiday"> | number
    month?: IntFilter<"Holiday"> | number
    original?: StringNullableFilter<"Holiday"> | string | null
    createdAt?: DateTimeFilter<"Holiday"> | Date | string
    updatedAt?: DateTimeFilter<"Holiday"> | Date | string
  }, "id" | "id" | "identifier">

  export type HolidayOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    name?: SortOrder
    type?: SortOrder
    infoUrl?: SortOrderInput | SortOrder
    day?: SortOrder
    month?: SortOrder
    original?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HolidayCountOrderByAggregateInput
    _avg?: HolidayAvgOrderByAggregateInput
    _max?: HolidayMaxOrderByAggregateInput
    _min?: HolidayMinOrderByAggregateInput
    _sum?: HolidaySumOrderByAggregateInput
  }

  export type HolidayScalarWhereWithAggregatesInput = {
    AND?: HolidayScalarWhereWithAggregatesInput | HolidayScalarWhereWithAggregatesInput[]
    OR?: HolidayScalarWhereWithAggregatesInput[]
    NOT?: HolidayScalarWhereWithAggregatesInput | HolidayScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Holiday"> | number
    identifier?: StringWithAggregatesFilter<"Holiday"> | string
    name?: StringWithAggregatesFilter<"Holiday"> | string
    type?: StringWithAggregatesFilter<"Holiday"> | string
    infoUrl?: StringNullableWithAggregatesFilter<"Holiday"> | string | null
    day?: IntWithAggregatesFilter<"Holiday"> | number
    month?: IntWithAggregatesFilter<"Holiday"> | number
    original?: StringNullableWithAggregatesFilter<"Holiday"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Holiday"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Holiday"> | Date | string
  }

  export type SellingPointHoursComprobantWhereInput = {
    AND?: SellingPointHoursComprobantWhereInput | SellingPointHoursComprobantWhereInput[]
    OR?: SellingPointHoursComprobantWhereInput[]
    NOT?: SellingPointHoursComprobantWhereInput | SellingPointHoursComprobantWhereInput[]
    id?: IntFilter<"SellingPointHoursComprobant"> | number
    dni?: IntFilter<"SellingPointHoursComprobant"> | number
    hours?: IntFilter<"SellingPointHoursComprobant"> | number
    sellingPoint?: StringFilter<"SellingPointHoursComprobant"> | string
    sellerName?: StringFilter<"SellingPointHoursComprobant"> | string
    price?: IntFilter<"SellingPointHoursComprobant"> | number
    createdAt?: DateTimeFilter<"SellingPointHoursComprobant"> | Date | string
  }

  export type SellingPointHoursComprobantOrderByWithRelationInput = {
    id?: SortOrder
    dni?: SortOrder
    hours?: SortOrder
    sellingPoint?: SortOrder
    sellerName?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type SellingPointHoursComprobantWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SellingPointHoursComprobantWhereInput | SellingPointHoursComprobantWhereInput[]
    OR?: SellingPointHoursComprobantWhereInput[]
    NOT?: SellingPointHoursComprobantWhereInput | SellingPointHoursComprobantWhereInput[]
    dni?: IntFilter<"SellingPointHoursComprobant"> | number
    hours?: IntFilter<"SellingPointHoursComprobant"> | number
    sellingPoint?: StringFilter<"SellingPointHoursComprobant"> | string
    sellerName?: StringFilter<"SellingPointHoursComprobant"> | string
    price?: IntFilter<"SellingPointHoursComprobant"> | number
    createdAt?: DateTimeFilter<"SellingPointHoursComprobant"> | Date | string
  }, "id" | "id">

  export type SellingPointHoursComprobantOrderByWithAggregationInput = {
    id?: SortOrder
    dni?: SortOrder
    hours?: SortOrder
    sellingPoint?: SortOrder
    sellerName?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    _count?: SellingPointHoursComprobantCountOrderByAggregateInput
    _avg?: SellingPointHoursComprobantAvgOrderByAggregateInput
    _max?: SellingPointHoursComprobantMaxOrderByAggregateInput
    _min?: SellingPointHoursComprobantMinOrderByAggregateInput
    _sum?: SellingPointHoursComprobantSumOrderByAggregateInput
  }

  export type SellingPointHoursComprobantScalarWhereWithAggregatesInput = {
    AND?: SellingPointHoursComprobantScalarWhereWithAggregatesInput | SellingPointHoursComprobantScalarWhereWithAggregatesInput[]
    OR?: SellingPointHoursComprobantScalarWhereWithAggregatesInput[]
    NOT?: SellingPointHoursComprobantScalarWhereWithAggregatesInput | SellingPointHoursComprobantScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SellingPointHoursComprobant"> | number
    dni?: IntWithAggregatesFilter<"SellingPointHoursComprobant"> | number
    hours?: IntWithAggregatesFilter<"SellingPointHoursComprobant"> | number
    sellingPoint?: StringWithAggregatesFilter<"SellingPointHoursComprobant"> | string
    sellerName?: StringWithAggregatesFilter<"SellingPointHoursComprobant"> | string
    price?: IntWithAggregatesFilter<"SellingPointHoursComprobant"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SellingPointHoursComprobant"> | Date | string
  }

  export type SellingMonthlyComprobantWhereInput = {
    AND?: SellingMonthlyComprobantWhereInput | SellingMonthlyComprobantWhereInput[]
    OR?: SellingMonthlyComprobantWhereInput[]
    NOT?: SellingMonthlyComprobantWhereInput | SellingMonthlyComprobantWhereInput[]
    id?: IntFilter<"SellingMonthlyComprobant"> | number
    dni?: IntFilter<"SellingMonthlyComprobant"> | number
    patentId?: StringFilter<"SellingMonthlyComprobant"> | string
    createdAt?: DateTimeFilter<"SellingMonthlyComprobant"> | Date | string
    finishedAt?: DateTimeNullableFilter<"SellingMonthlyComprobant"> | Date | string | null
    totalPrice?: IntFilter<"SellingMonthlyComprobant"> | number
    soldBy?: IntFilter<"SellingMonthlyComprobant"> | number
  }

  export type SellingMonthlyComprobantOrderByWithRelationInput = {
    id?: SortOrder
    dni?: SortOrder
    patentId?: SortOrder
    createdAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    totalPrice?: SortOrder
    soldBy?: SortOrder
  }

  export type SellingMonthlyComprobantWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SellingMonthlyComprobantWhereInput | SellingMonthlyComprobantWhereInput[]
    OR?: SellingMonthlyComprobantWhereInput[]
    NOT?: SellingMonthlyComprobantWhereInput | SellingMonthlyComprobantWhereInput[]
    dni?: IntFilter<"SellingMonthlyComprobant"> | number
    patentId?: StringFilter<"SellingMonthlyComprobant"> | string
    createdAt?: DateTimeFilter<"SellingMonthlyComprobant"> | Date | string
    finishedAt?: DateTimeNullableFilter<"SellingMonthlyComprobant"> | Date | string | null
    totalPrice?: IntFilter<"SellingMonthlyComprobant"> | number
    soldBy?: IntFilter<"SellingMonthlyComprobant"> | number
  }, "id" | "id">

  export type SellingMonthlyComprobantOrderByWithAggregationInput = {
    id?: SortOrder
    dni?: SortOrder
    patentId?: SortOrder
    createdAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    totalPrice?: SortOrder
    soldBy?: SortOrder
    _count?: SellingMonthlyComprobantCountOrderByAggregateInput
    _avg?: SellingMonthlyComprobantAvgOrderByAggregateInput
    _max?: SellingMonthlyComprobantMaxOrderByAggregateInput
    _min?: SellingMonthlyComprobantMinOrderByAggregateInput
    _sum?: SellingMonthlyComprobantSumOrderByAggregateInput
  }

  export type SellingMonthlyComprobantScalarWhereWithAggregatesInput = {
    AND?: SellingMonthlyComprobantScalarWhereWithAggregatesInput | SellingMonthlyComprobantScalarWhereWithAggregatesInput[]
    OR?: SellingMonthlyComprobantScalarWhereWithAggregatesInput[]
    NOT?: SellingMonthlyComprobantScalarWhereWithAggregatesInput | SellingMonthlyComprobantScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SellingMonthlyComprobant"> | number
    dni?: IntWithAggregatesFilter<"SellingMonthlyComprobant"> | number
    patentId?: StringWithAggregatesFilter<"SellingMonthlyComprobant"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SellingMonthlyComprobant"> | Date | string
    finishedAt?: DateTimeNullableWithAggregatesFilter<"SellingMonthlyComprobant"> | Date | string | null
    totalPrice?: IntWithAggregatesFilter<"SellingMonthlyComprobant"> | number
    soldBy?: IntWithAggregatesFilter<"SellingMonthlyComprobant"> | number
  }

  export type MovieWhereInput = {
    AND?: MovieWhereInput | MovieWhereInput[]
    OR?: MovieWhereInput[]
    NOT?: MovieWhereInput | MovieWhereInput[]
    id?: StringFilter<"Movie"> | string
    title?: StringFilter<"Movie"> | string
    description?: StringFilter<"Movie"> | string
    durationMinutes?: IntFilter<"Movie"> | number
    language?: StringFilter<"Movie"> | string
    format?: EnumFormatFilter<"Movie"> | $Enums.Format
    posterUrl?: StringNullableFilter<"Movie"> | string | null
    createdAt?: DateTimeFilter<"Movie"> | Date | string
    updatedAt?: DateTimeFilter<"Movie"> | Date | string
    showings?: ShowingListRelationFilter
  }

  export type MovieOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    durationMinutes?: SortOrder
    language?: SortOrder
    format?: SortOrder
    posterUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    showings?: ShowingOrderByRelationAggregateInput
  }

  export type MovieWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MovieWhereInput | MovieWhereInput[]
    OR?: MovieWhereInput[]
    NOT?: MovieWhereInput | MovieWhereInput[]
    title?: StringFilter<"Movie"> | string
    description?: StringFilter<"Movie"> | string
    durationMinutes?: IntFilter<"Movie"> | number
    language?: StringFilter<"Movie"> | string
    format?: EnumFormatFilter<"Movie"> | $Enums.Format
    posterUrl?: StringNullableFilter<"Movie"> | string | null
    createdAt?: DateTimeFilter<"Movie"> | Date | string
    updatedAt?: DateTimeFilter<"Movie"> | Date | string
    showings?: ShowingListRelationFilter
  }, "id" | "id">

  export type MovieOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    durationMinutes?: SortOrder
    language?: SortOrder
    format?: SortOrder
    posterUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MovieCountOrderByAggregateInput
    _avg?: MovieAvgOrderByAggregateInput
    _max?: MovieMaxOrderByAggregateInput
    _min?: MovieMinOrderByAggregateInput
    _sum?: MovieSumOrderByAggregateInput
  }

  export type MovieScalarWhereWithAggregatesInput = {
    AND?: MovieScalarWhereWithAggregatesInput | MovieScalarWhereWithAggregatesInput[]
    OR?: MovieScalarWhereWithAggregatesInput[]
    NOT?: MovieScalarWhereWithAggregatesInput | MovieScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Movie"> | string
    title?: StringWithAggregatesFilter<"Movie"> | string
    description?: StringWithAggregatesFilter<"Movie"> | string
    durationMinutes?: IntWithAggregatesFilter<"Movie"> | number
    language?: StringWithAggregatesFilter<"Movie"> | string
    format?: EnumFormatWithAggregatesFilter<"Movie"> | $Enums.Format
    posterUrl?: StringNullableWithAggregatesFilter<"Movie"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Movie"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Movie"> | Date | string
  }

  export type ShowingWhereInput = {
    AND?: ShowingWhereInput | ShowingWhereInput[]
    OR?: ShowingWhereInput[]
    NOT?: ShowingWhereInput | ShowingWhereInput[]
    id?: StringFilter<"Showing"> | string
    movieId?: StringFilter<"Showing"> | string
    startTime?: DateTimeFilter<"Showing"> | Date | string
    priceCents?: IntFilter<"Showing"> | number
    rows?: IntFilter<"Showing"> | number
    seatsPerRow?: IntFilter<"Showing"> | number
    totalSeats?: IntFilter<"Showing"> | number
    status?: EnumShowingStatusFilter<"Showing"> | $Enums.ShowingStatus
    cancelledAt?: DateTimeNullableFilter<"Showing"> | Date | string | null
    createdAt?: DateTimeFilter<"Showing"> | Date | string
    movie?: XOR<MovieRelationFilter, MovieWhereInput>
    seats?: SeatListRelationFilter
    seatHolds?: SeatHoldListRelationFilter
    credits?: CinemaCreditListRelationFilter
  }

  export type ShowingOrderByWithRelationInput = {
    id?: SortOrder
    movieId?: SortOrder
    startTime?: SortOrder
    priceCents?: SortOrder
    rows?: SortOrder
    seatsPerRow?: SortOrder
    totalSeats?: SortOrder
    status?: SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    movie?: MovieOrderByWithRelationInput
    seats?: SeatOrderByRelationAggregateInput
    seatHolds?: SeatHoldOrderByRelationAggregateInput
    credits?: CinemaCreditOrderByRelationAggregateInput
  }

  export type ShowingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShowingWhereInput | ShowingWhereInput[]
    OR?: ShowingWhereInput[]
    NOT?: ShowingWhereInput | ShowingWhereInput[]
    movieId?: StringFilter<"Showing"> | string
    startTime?: DateTimeFilter<"Showing"> | Date | string
    priceCents?: IntFilter<"Showing"> | number
    rows?: IntFilter<"Showing"> | number
    seatsPerRow?: IntFilter<"Showing"> | number
    totalSeats?: IntFilter<"Showing"> | number
    status?: EnumShowingStatusFilter<"Showing"> | $Enums.ShowingStatus
    cancelledAt?: DateTimeNullableFilter<"Showing"> | Date | string | null
    createdAt?: DateTimeFilter<"Showing"> | Date | string
    movie?: XOR<MovieRelationFilter, MovieWhereInput>
    seats?: SeatListRelationFilter
    seatHolds?: SeatHoldListRelationFilter
    credits?: CinemaCreditListRelationFilter
  }, "id" | "id">

  export type ShowingOrderByWithAggregationInput = {
    id?: SortOrder
    movieId?: SortOrder
    startTime?: SortOrder
    priceCents?: SortOrder
    rows?: SortOrder
    seatsPerRow?: SortOrder
    totalSeats?: SortOrder
    status?: SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ShowingCountOrderByAggregateInput
    _avg?: ShowingAvgOrderByAggregateInput
    _max?: ShowingMaxOrderByAggregateInput
    _min?: ShowingMinOrderByAggregateInput
    _sum?: ShowingSumOrderByAggregateInput
  }

  export type ShowingScalarWhereWithAggregatesInput = {
    AND?: ShowingScalarWhereWithAggregatesInput | ShowingScalarWhereWithAggregatesInput[]
    OR?: ShowingScalarWhereWithAggregatesInput[]
    NOT?: ShowingScalarWhereWithAggregatesInput | ShowingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Showing"> | string
    movieId?: StringWithAggregatesFilter<"Showing"> | string
    startTime?: DateTimeWithAggregatesFilter<"Showing"> | Date | string
    priceCents?: IntWithAggregatesFilter<"Showing"> | number
    rows?: IntWithAggregatesFilter<"Showing"> | number
    seatsPerRow?: IntWithAggregatesFilter<"Showing"> | number
    totalSeats?: IntWithAggregatesFilter<"Showing"> | number
    status?: EnumShowingStatusWithAggregatesFilter<"Showing"> | $Enums.ShowingStatus
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Showing"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Showing"> | Date | string
  }

  export type SeatWhereInput = {
    AND?: SeatWhereInput | SeatWhereInput[]
    OR?: SeatWhereInput[]
    NOT?: SeatWhereInput | SeatWhereInput[]
    id?: StringFilter<"Seat"> | string
    showingId?: StringFilter<"Seat"> | string
    rowLabel?: StringFilter<"Seat"> | string
    number?: IntFilter<"Seat"> | number
    status?: EnumSeatStatusFilter<"Seat"> | $Enums.SeatStatus
    createdAt?: DateTimeFilter<"Seat"> | Date | string
    showing?: XOR<ShowingRelationFilter, ShowingWhereInput>
    tickets?: TicketListRelationFilter
    hold?: XOR<SeatHoldNullableRelationFilter, SeatHoldWhereInput> | null
  }

  export type SeatOrderByWithRelationInput = {
    id?: SortOrder
    showingId?: SortOrder
    rowLabel?: SortOrder
    number?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    showing?: ShowingOrderByWithRelationInput
    tickets?: TicketOrderByRelationAggregateInput
    hold?: SeatHoldOrderByWithRelationInput
  }

  export type SeatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    showingId_rowLabel_number?: SeatShowingIdRowLabelNumberCompoundUniqueInput
    AND?: SeatWhereInput | SeatWhereInput[]
    OR?: SeatWhereInput[]
    NOT?: SeatWhereInput | SeatWhereInput[]
    showingId?: StringFilter<"Seat"> | string
    rowLabel?: StringFilter<"Seat"> | string
    number?: IntFilter<"Seat"> | number
    status?: EnumSeatStatusFilter<"Seat"> | $Enums.SeatStatus
    createdAt?: DateTimeFilter<"Seat"> | Date | string
    showing?: XOR<ShowingRelationFilter, ShowingWhereInput>
    tickets?: TicketListRelationFilter
    hold?: XOR<SeatHoldNullableRelationFilter, SeatHoldWhereInput> | null
  }, "id" | "id" | "showingId_rowLabel_number">

  export type SeatOrderByWithAggregationInput = {
    id?: SortOrder
    showingId?: SortOrder
    rowLabel?: SortOrder
    number?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: SeatCountOrderByAggregateInput
    _avg?: SeatAvgOrderByAggregateInput
    _max?: SeatMaxOrderByAggregateInput
    _min?: SeatMinOrderByAggregateInput
    _sum?: SeatSumOrderByAggregateInput
  }

  export type SeatScalarWhereWithAggregatesInput = {
    AND?: SeatScalarWhereWithAggregatesInput | SeatScalarWhereWithAggregatesInput[]
    OR?: SeatScalarWhereWithAggregatesInput[]
    NOT?: SeatScalarWhereWithAggregatesInput | SeatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Seat"> | string
    showingId?: StringWithAggregatesFilter<"Seat"> | string
    rowLabel?: StringWithAggregatesFilter<"Seat"> | string
    number?: IntWithAggregatesFilter<"Seat"> | number
    status?: EnumSeatStatusWithAggregatesFilter<"Seat"> | $Enums.SeatStatus
    createdAt?: DateTimeWithAggregatesFilter<"Seat"> | Date | string
  }

  export type SeatHoldWhereInput = {
    AND?: SeatHoldWhereInput | SeatHoldWhereInput[]
    OR?: SeatHoldWhereInput[]
    NOT?: SeatHoldWhereInput | SeatHoldWhereInput[]
    id?: StringFilter<"SeatHold"> | string
    seatId?: StringFilter<"SeatHold"> | string
    showingId?: StringFilter<"SeatHold"> | string
    userId?: IntFilter<"SeatHold"> | number
    createdAt?: DateTimeFilter<"SeatHold"> | Date | string
    expiresAt?: DateTimeFilter<"SeatHold"> | Date | string
    seat?: XOR<SeatRelationFilter, SeatWhereInput>
    showing?: XOR<ShowingRelationFilter, ShowingWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SeatHoldOrderByWithRelationInput = {
    id?: SortOrder
    seatId?: SortOrder
    showingId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    seat?: SeatOrderByWithRelationInput
    showing?: ShowingOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type SeatHoldWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seatId?: string
    AND?: SeatHoldWhereInput | SeatHoldWhereInput[]
    OR?: SeatHoldWhereInput[]
    NOT?: SeatHoldWhereInput | SeatHoldWhereInput[]
    showingId?: StringFilter<"SeatHold"> | string
    userId?: IntFilter<"SeatHold"> | number
    createdAt?: DateTimeFilter<"SeatHold"> | Date | string
    expiresAt?: DateTimeFilter<"SeatHold"> | Date | string
    seat?: XOR<SeatRelationFilter, SeatWhereInput>
    showing?: XOR<ShowingRelationFilter, ShowingWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "id" | "seatId">

  export type SeatHoldOrderByWithAggregationInput = {
    id?: SortOrder
    seatId?: SortOrder
    showingId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    _count?: SeatHoldCountOrderByAggregateInput
    _avg?: SeatHoldAvgOrderByAggregateInput
    _max?: SeatHoldMaxOrderByAggregateInput
    _min?: SeatHoldMinOrderByAggregateInput
    _sum?: SeatHoldSumOrderByAggregateInput
  }

  export type SeatHoldScalarWhereWithAggregatesInput = {
    AND?: SeatHoldScalarWhereWithAggregatesInput | SeatHoldScalarWhereWithAggregatesInput[]
    OR?: SeatHoldScalarWhereWithAggregatesInput[]
    NOT?: SeatHoldScalarWhereWithAggregatesInput | SeatHoldScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SeatHold"> | string
    seatId?: StringWithAggregatesFilter<"SeatHold"> | string
    showingId?: StringWithAggregatesFilter<"SeatHold"> | string
    userId?: IntWithAggregatesFilter<"SeatHold"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SeatHold"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"SeatHold"> | Date | string
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: StringFilter<"Booking"> | string
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    channel?: EnumPurchaseChannelFilter<"Booking"> | $Enums.PurchaseChannel
    totalPriceCents?: IntFilter<"Booking"> | number
    customerId?: IntNullableFilter<"Booking"> | number | null
    soldById?: IntNullableFilter<"Booking"> | number | null
    customerEmail?: StringNullableFilter<"Booking"> | string | null
    customer?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    soldBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    tickets?: TicketListRelationFilter
    credits?: CinemaCreditListRelationFilter
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    channel?: SortOrder
    totalPriceCents?: SortOrder
    customerId?: SortOrderInput | SortOrder
    soldById?: SortOrderInput | SortOrder
    customerEmail?: SortOrderInput | SortOrder
    customer?: UserOrderByWithRelationInput
    soldBy?: UserOrderByWithRelationInput
    tickets?: TicketOrderByRelationAggregateInput
    credits?: CinemaCreditOrderByRelationAggregateInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    channel?: EnumPurchaseChannelFilter<"Booking"> | $Enums.PurchaseChannel
    totalPriceCents?: IntFilter<"Booking"> | number
    customerId?: IntNullableFilter<"Booking"> | number | null
    soldById?: IntNullableFilter<"Booking"> | number | null
    customerEmail?: StringNullableFilter<"Booking"> | string | null
    customer?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    soldBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    tickets?: TicketListRelationFilter
    credits?: CinemaCreditListRelationFilter
  }, "id" | "id">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    channel?: SortOrder
    totalPriceCents?: SortOrder
    customerId?: SortOrderInput | SortOrder
    soldById?: SortOrderInput | SortOrder
    customerEmail?: SortOrderInput | SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Booking"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    status?: EnumBookingStatusWithAggregatesFilter<"Booking"> | $Enums.BookingStatus
    channel?: EnumPurchaseChannelWithAggregatesFilter<"Booking"> | $Enums.PurchaseChannel
    totalPriceCents?: IntWithAggregatesFilter<"Booking"> | number
    customerId?: IntNullableWithAggregatesFilter<"Booking"> | number | null
    soldById?: IntNullableWithAggregatesFilter<"Booking"> | number | null
    customerEmail?: StringNullableWithAggregatesFilter<"Booking"> | string | null
  }

  export type TicketWhereInput = {
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    id?: StringFilter<"Ticket"> | string
    bookingId?: StringFilter<"Ticket"> | string
    seatId?: StringFilter<"Ticket"> | string
    qrToken?: StringFilter<"Ticket"> | string
    checkedInAt?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    booking?: XOR<BookingRelationFilter, BookingWhereInput>
    seat?: XOR<SeatRelationFilter, SeatWhereInput>
  }

  export type TicketOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    seatId?: SortOrder
    qrToken?: SortOrder
    checkedInAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
    seat?: SeatOrderByWithRelationInput
  }

  export type TicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seatId?: string
    qrToken?: string
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    bookingId?: StringFilter<"Ticket"> | string
    checkedInAt?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    booking?: XOR<BookingRelationFilter, BookingWhereInput>
    seat?: XOR<SeatRelationFilter, SeatWhereInput>
  }, "id" | "id" | "seatId" | "qrToken">

  export type TicketOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    seatId?: SortOrder
    qrToken?: SortOrder
    checkedInAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TicketCountOrderByAggregateInput
    _max?: TicketMaxOrderByAggregateInput
    _min?: TicketMinOrderByAggregateInput
  }

  export type TicketScalarWhereWithAggregatesInput = {
    AND?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    OR?: TicketScalarWhereWithAggregatesInput[]
    NOT?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ticket"> | string
    bookingId?: StringWithAggregatesFilter<"Ticket"> | string
    seatId?: StringWithAggregatesFilter<"Ticket"> | string
    qrToken?: StringWithAggregatesFilter<"Ticket"> | string
    checkedInAt?: DateTimeNullableWithAggregatesFilter<"Ticket"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
  }

  export type CinemaCreditWhereInput = {
    AND?: CinemaCreditWhereInput | CinemaCreditWhereInput[]
    OR?: CinemaCreditWhereInput[]
    NOT?: CinemaCreditWhereInput | CinemaCreditWhereInput[]
    id?: StringFilter<"CinemaCredit"> | string
    userId?: IntFilter<"CinemaCredit"> | number
    bookingId?: StringNullableFilter<"CinemaCredit"> | string | null
    showingId?: StringNullableFilter<"CinemaCredit"> | string | null
    amountCents?: IntFilter<"CinemaCredit"> | number
    remainingCents?: IntFilter<"CinemaCredit"> | number
    reason?: StringFilter<"CinemaCredit"> | string
    createdAt?: DateTimeFilter<"CinemaCredit"> | Date | string
    expiresAt?: DateTimeNullableFilter<"CinemaCredit"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    booking?: XOR<BookingNullableRelationFilter, BookingWhereInput> | null
    showing?: XOR<ShowingNullableRelationFilter, ShowingWhereInput> | null
  }

  export type CinemaCreditOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    showingId?: SortOrderInput | SortOrder
    amountCents?: SortOrder
    remainingCents?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    booking?: BookingOrderByWithRelationInput
    showing?: ShowingOrderByWithRelationInput
  }

  export type CinemaCreditWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CinemaCreditWhereInput | CinemaCreditWhereInput[]
    OR?: CinemaCreditWhereInput[]
    NOT?: CinemaCreditWhereInput | CinemaCreditWhereInput[]
    userId?: IntFilter<"CinemaCredit"> | number
    bookingId?: StringNullableFilter<"CinemaCredit"> | string | null
    showingId?: StringNullableFilter<"CinemaCredit"> | string | null
    amountCents?: IntFilter<"CinemaCredit"> | number
    remainingCents?: IntFilter<"CinemaCredit"> | number
    reason?: StringFilter<"CinemaCredit"> | string
    createdAt?: DateTimeFilter<"CinemaCredit"> | Date | string
    expiresAt?: DateTimeNullableFilter<"CinemaCredit"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    booking?: XOR<BookingNullableRelationFilter, BookingWhereInput> | null
    showing?: XOR<ShowingNullableRelationFilter, ShowingWhereInput> | null
  }, "id" | "id">

  export type CinemaCreditOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    showingId?: SortOrderInput | SortOrder
    amountCents?: SortOrder
    remainingCents?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: CinemaCreditCountOrderByAggregateInput
    _avg?: CinemaCreditAvgOrderByAggregateInput
    _max?: CinemaCreditMaxOrderByAggregateInput
    _min?: CinemaCreditMinOrderByAggregateInput
    _sum?: CinemaCreditSumOrderByAggregateInput
  }

  export type CinemaCreditScalarWhereWithAggregatesInput = {
    AND?: CinemaCreditScalarWhereWithAggregatesInput | CinemaCreditScalarWhereWithAggregatesInput[]
    OR?: CinemaCreditScalarWhereWithAggregatesInput[]
    NOT?: CinemaCreditScalarWhereWithAggregatesInput | CinemaCreditScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CinemaCredit"> | string
    userId?: IntWithAggregatesFilter<"CinemaCredit"> | number
    bookingId?: StringNullableWithAggregatesFilter<"CinemaCredit"> | string | null
    showingId?: StringNullableWithAggregatesFilter<"CinemaCredit"> | string | null
    amountCents?: IntWithAggregatesFilter<"CinemaCredit"> | number
    remainingCents?: IntWithAggregatesFilter<"CinemaCredit"> | number
    reason?: StringWithAggregatesFilter<"CinemaCredit"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CinemaCredit"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"CinemaCredit"> | Date | string | null
  }

  export type UserCreateInput = {
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
    patents?: PatentCreateNestedManyWithoutUserInput
    deletedPatent?: DeletedPatentsCreateNestedManyWithoutUserInput
    sellPoint?: SellPointCreateNestedManyWithoutUserInput
    sellingHoursReports?: SellingHoursReportsCreateNestedManyWithoutUserInput
    parking?: ParkingCreateNestedManyWithoutUserInput
    userReports?: UserHoursReportsCreateNestedManyWithoutUserInput
    userParkingReports?: UserParkingReportsCreateNestedManyWithoutUserInput
    paidInfractions?: InfractionCreateNestedManyWithoutPayedByUserInput
    receivedHoursSales?: SellingHoursReportsCreateNestedManyWithoutTargetUserInput
    bookings?: BookingCreateNestedManyWithoutCustomerInput
    soldBookings?: BookingCreateNestedManyWithoutSoldByInput
    seatHolds?: SeatHoldCreateNestedManyWithoutUserInput
    cinemaCredits?: CinemaCreditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
    patents?: PatentUncheckedCreateNestedManyWithoutUserInput
    deletedPatent?: DeletedPatentsUncheckedCreateNestedManyWithoutUserInput
    sellPoint?: SellPointUncheckedCreateNestedManyWithoutUserInput
    sellingHoursReports?: SellingHoursReportsUncheckedCreateNestedManyWithoutUserInput
    parking?: ParkingUncheckedCreateNestedManyWithoutUserInput
    userReports?: UserHoursReportsUncheckedCreateNestedManyWithoutUserInput
    userParkingReports?: UserParkingReportsUncheckedCreateNestedManyWithoutUserInput
    paidInfractions?: InfractionUncheckedCreateNestedManyWithoutPayedByUserInput
    receivedHoursSales?: SellingHoursReportsUncheckedCreateNestedManyWithoutTargetUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutCustomerInput
    soldBookings?: BookingUncheckedCreateNestedManyWithoutSoldByInput
    seatHolds?: SeatHoldUncheckedCreateNestedManyWithoutUserInput
    cinemaCredits?: CinemaCreditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
    patents?: PatentUpdateManyWithoutUserNestedInput
    deletedPatent?: DeletedPatentsUpdateManyWithoutUserNestedInput
    sellPoint?: SellPointUpdateManyWithoutUserNestedInput
    sellingHoursReports?: SellingHoursReportsUpdateManyWithoutUserNestedInput
    parking?: ParkingUpdateManyWithoutUserNestedInput
    userReports?: UserHoursReportsUpdateManyWithoutUserNestedInput
    userParkingReports?: UserParkingReportsUpdateManyWithoutUserNestedInput
    paidInfractions?: InfractionUpdateManyWithoutPayedByUserNestedInput
    receivedHoursSales?: SellingHoursReportsUpdateManyWithoutTargetUserNestedInput
    bookings?: BookingUpdateManyWithoutCustomerNestedInput
    soldBookings?: BookingUpdateManyWithoutSoldByNestedInput
    seatHolds?: SeatHoldUpdateManyWithoutUserNestedInput
    cinemaCredits?: CinemaCreditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
    patents?: PatentUncheckedUpdateManyWithoutUserNestedInput
    deletedPatent?: DeletedPatentsUncheckedUpdateManyWithoutUserNestedInput
    sellPoint?: SellPointUncheckedUpdateManyWithoutUserNestedInput
    sellingHoursReports?: SellingHoursReportsUncheckedUpdateManyWithoutUserNestedInput
    parking?: ParkingUncheckedUpdateManyWithoutUserNestedInput
    userReports?: UserHoursReportsUncheckedUpdateManyWithoutUserNestedInput
    userParkingReports?: UserParkingReportsUncheckedUpdateManyWithoutUserNestedInput
    paidInfractions?: InfractionUncheckedUpdateManyWithoutPayedByUserNestedInput
    receivedHoursSales?: SellingHoursReportsUncheckedUpdateManyWithoutTargetUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutCustomerNestedInput
    soldBookings?: BookingUncheckedUpdateManyWithoutSoldByNestedInput
    seatHolds?: SeatHoldUncheckedUpdateManyWithoutUserNestedInput
    cinemaCredits?: CinemaCreditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SellPointCreateInput = {
    address: string
    street?: string | null
    streetNumber?: number | null
    availableHours?: number
    usedHours?: number
    pointName: string
    dni?: number | null
    profitPercentage: number
    user?: UserCreateNestedOneWithoutSellPointInput
    reports?: AssignHoursReportsCreateNestedManyWithoutSellPointInput
    patentReports?: AssignPatentHoursReportsCreateNestedManyWithoutSellPointInput
  }

  export type SellPointUncheckedCreateInput = {
    id?: number
    address: string
    street?: string | null
    streetNumber?: number | null
    availableHours?: number
    usedHours?: number
    pointName: string
    dni?: number | null
    userId?: number | null
    profitPercentage: number
    reports?: AssignHoursReportsUncheckedCreateNestedManyWithoutSellPointInput
    patentReports?: AssignPatentHoursReportsUncheckedCreateNestedManyWithoutSellPointInput
  }

  export type SellPointUpdateInput = {
    address?: StringFieldUpdateOperationsInput | string
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableIntFieldUpdateOperationsInput | number | null
    availableHours?: IntFieldUpdateOperationsInput | number
    usedHours?: IntFieldUpdateOperationsInput | number
    pointName?: StringFieldUpdateOperationsInput | string
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    profitPercentage?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneWithoutSellPointNestedInput
    reports?: AssignHoursReportsUpdateManyWithoutSellPointNestedInput
    patentReports?: AssignPatentHoursReportsUpdateManyWithoutSellPointNestedInput
  }

  export type SellPointUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableIntFieldUpdateOperationsInput | number | null
    availableHours?: IntFieldUpdateOperationsInput | number
    usedHours?: IntFieldUpdateOperationsInput | number
    pointName?: StringFieldUpdateOperationsInput | string
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    profitPercentage?: IntFieldUpdateOperationsInput | number
    reports?: AssignHoursReportsUncheckedUpdateManyWithoutSellPointNestedInput
    patentReports?: AssignPatentHoursReportsUncheckedUpdateManyWithoutSellPointNestedInput
  }

  export type SellPointCreateManyInput = {
    id?: number
    address: string
    street?: string | null
    streetNumber?: number | null
    availableHours?: number
    usedHours?: number
    pointName: string
    dni?: number | null
    userId?: number | null
    profitPercentage: number
  }

  export type SellPointUpdateManyMutationInput = {
    address?: StringFieldUpdateOperationsInput | string
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableIntFieldUpdateOperationsInput | number | null
    availableHours?: IntFieldUpdateOperationsInput | number
    usedHours?: IntFieldUpdateOperationsInput | number
    pointName?: StringFieldUpdateOperationsInput | string
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    profitPercentage?: IntFieldUpdateOperationsInput | number
  }

  export type SellPointUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableIntFieldUpdateOperationsInput | number | null
    availableHours?: IntFieldUpdateOperationsInput | number
    usedHours?: IntFieldUpdateOperationsInput | number
    pointName?: StringFieldUpdateOperationsInput | string
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    profitPercentage?: IntFieldUpdateOperationsInput | number
  }

  export type PatentCreateInput = {
    patentId: string
    createdAt?: Date | string
    hasSingleHours?: boolean
    singleHours?: number
    dni?: number | null
    isAllowed?: boolean
    canShow?: boolean
    isAllowedIn?: string | null
    houseType?: string | null
    user?: UserCreateNestedOneWithoutPatentsInput
  }

  export type PatentUncheckedCreateInput = {
    id?: number
    patentId: string
    userId?: number | null
    createdAt?: Date | string
    hasSingleHours?: boolean
    singleHours?: number
    dni?: number | null
    isAllowed?: boolean
    canShow?: boolean
    isAllowedIn?: string | null
    houseType?: string | null
  }

  export type PatentUpdateInput = {
    patentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasSingleHours?: BoolFieldUpdateOperationsInput | boolean
    singleHours?: IntFieldUpdateOperationsInput | number
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowed?: BoolFieldUpdateOperationsInput | boolean
    canShow?: BoolFieldUpdateOperationsInput | boolean
    isAllowedIn?: NullableStringFieldUpdateOperationsInput | string | null
    houseType?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutPatentsNestedInput
  }

  export type PatentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patentId?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasSingleHours?: BoolFieldUpdateOperationsInput | boolean
    singleHours?: IntFieldUpdateOperationsInput | number
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowed?: BoolFieldUpdateOperationsInput | boolean
    canShow?: BoolFieldUpdateOperationsInput | boolean
    isAllowedIn?: NullableStringFieldUpdateOperationsInput | string | null
    houseType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatentCreateManyInput = {
    id?: number
    patentId: string
    userId?: number | null
    createdAt?: Date | string
    hasSingleHours?: boolean
    singleHours?: number
    dni?: number | null
    isAllowed?: boolean
    canShow?: boolean
    isAllowedIn?: string | null
    houseType?: string | null
  }

  export type PatentUpdateManyMutationInput = {
    patentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasSingleHours?: BoolFieldUpdateOperationsInput | boolean
    singleHours?: IntFieldUpdateOperationsInput | number
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowed?: BoolFieldUpdateOperationsInput | boolean
    canShow?: BoolFieldUpdateOperationsInput | boolean
    isAllowedIn?: NullableStringFieldUpdateOperationsInput | string | null
    houseType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patentId?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasSingleHours?: BoolFieldUpdateOperationsInput | boolean
    singleHours?: IntFieldUpdateOperationsInput | number
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowed?: BoolFieldUpdateOperationsInput | boolean
    canShow?: BoolFieldUpdateOperationsInput | boolean
    isAllowedIn?: NullableStringFieldUpdateOperationsInput | string | null
    houseType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatentValidationCreateInput = {
    patentId: string
    validationsToday?: number
    validatedAt?: Date | string | null
  }

  export type PatentValidationUncheckedCreateInput = {
    id?: number
    patentId: string
    validationsToday?: number
    validatedAt?: Date | string | null
  }

  export type PatentValidationUpdateInput = {
    patentId?: StringFieldUpdateOperationsInput | string
    validationsToday?: IntFieldUpdateOperationsInput | number
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PatentValidationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patentId?: StringFieldUpdateOperationsInput | string
    validationsToday?: IntFieldUpdateOperationsInput | number
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PatentValidationCreateManyInput = {
    id?: number
    patentId: string
    validationsToday?: number
    validatedAt?: Date | string | null
  }

  export type PatentValidationUpdateManyMutationInput = {
    patentId?: StringFieldUpdateOperationsInput | string
    validationsToday?: IntFieldUpdateOperationsInput | number
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PatentValidationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patentId?: StringFieldUpdateOperationsInput | string
    validationsToday?: IntFieldUpdateOperationsInput | number
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeletedPatentsCreateInput = {
    patentId: string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutDeletedPatentInput
  }

  export type DeletedPatentsUncheckedCreateInput = {
    id?: number
    patentId: string
    userId: number
    deletedAt?: Date | string | null
  }

  export type DeletedPatentsUpdateInput = {
    patentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutDeletedPatentNestedInput
  }

  export type DeletedPatentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patentId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeletedPatentsCreateManyInput = {
    id?: number
    patentId: string
    userId: number
    deletedAt?: Date | string | null
  }

  export type DeletedPatentsUpdateManyMutationInput = {
    patentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeletedPatentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patentId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssignHoursReportsCreateInput = {
    id?: string
    hoursAdded: number
    addedAt: Date | string
    hourPrice: number
    soldBy?: number | null
    sellPoint: SellPointCreateNestedOneWithoutReportsInput
  }

  export type AssignHoursReportsUncheckedCreateInput = {
    id?: string
    hoursAdded: number
    addedAt: Date | string
    sellPointId: number
    hourPrice: number
    soldBy?: number | null
  }

  export type AssignHoursReportsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursAdded?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hourPrice?: FloatFieldUpdateOperationsInput | number
    soldBy?: NullableIntFieldUpdateOperationsInput | number | null
    sellPoint?: SellPointUpdateOneRequiredWithoutReportsNestedInput
  }

  export type AssignHoursReportsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursAdded?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sellPointId?: IntFieldUpdateOperationsInput | number
    hourPrice?: FloatFieldUpdateOperationsInput | number
    soldBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AssignHoursReportsCreateManyInput = {
    id?: string
    hoursAdded: number
    addedAt: Date | string
    sellPointId: number
    hourPrice: number
    soldBy?: number | null
  }

  export type AssignHoursReportsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursAdded?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hourPrice?: FloatFieldUpdateOperationsInput | number
    soldBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AssignHoursReportsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursAdded?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sellPointId?: IntFieldUpdateOperationsInput | number
    hourPrice?: FloatFieldUpdateOperationsInput | number
    soldBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AssignPatentHoursReportsCreateInput = {
    id?: string
    hoursAdded: number
    addedAt: Date | string
    hourPrice: number
    patentId: string
    dni: number
    soldBy?: number | null
    sellPoint?: SellPointCreateNestedOneWithoutPatentReportsInput
  }

  export type AssignPatentHoursReportsUncheckedCreateInput = {
    id?: string
    hoursAdded: number
    addedAt: Date | string
    sellPointId?: number | null
    hourPrice: number
    patentId: string
    dni: number
    soldBy?: number | null
  }

  export type AssignPatentHoursReportsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursAdded?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hourPrice?: FloatFieldUpdateOperationsInput | number
    patentId?: StringFieldUpdateOperationsInput | string
    dni?: IntFieldUpdateOperationsInput | number
    soldBy?: NullableIntFieldUpdateOperationsInput | number | null
    sellPoint?: SellPointUpdateOneWithoutPatentReportsNestedInput
  }

  export type AssignPatentHoursReportsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursAdded?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sellPointId?: NullableIntFieldUpdateOperationsInput | number | null
    hourPrice?: FloatFieldUpdateOperationsInput | number
    patentId?: StringFieldUpdateOperationsInput | string
    dni?: IntFieldUpdateOperationsInput | number
    soldBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AssignPatentHoursReportsCreateManyInput = {
    id?: string
    hoursAdded: number
    addedAt: Date | string
    sellPointId?: number | null
    hourPrice: number
    patentId: string
    dni: number
    soldBy?: number | null
  }

  export type AssignPatentHoursReportsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursAdded?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hourPrice?: FloatFieldUpdateOperationsInput | number
    patentId?: StringFieldUpdateOperationsInput | string
    dni?: IntFieldUpdateOperationsInput | number
    soldBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AssignPatentHoursReportsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursAdded?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sellPointId?: NullableIntFieldUpdateOperationsInput | number | null
    hourPrice?: FloatFieldUpdateOperationsInput | number
    patentId?: StringFieldUpdateOperationsInput | string
    dni?: IntFieldUpdateOperationsInput | number
    soldBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SellingHoursReportsCreateInput = {
    id?: string
    hoursAdded: number
    addedAt: Date | string
    hourPrice: number
    soldBy?: number | null
    user: UserCreateNestedOneWithoutSellingHoursReportsInput
    targetUser?: UserCreateNestedOneWithoutReceivedHoursSalesInput
  }

  export type SellingHoursReportsUncheckedCreateInput = {
    id?: string
    hoursAdded: number
    addedAt: Date | string
    userId: number
    hourPrice: number
    soldBy?: number | null
    targetUserId?: number | null
  }

  export type SellingHoursReportsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursAdded?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hourPrice?: FloatFieldUpdateOperationsInput | number
    soldBy?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutSellingHoursReportsNestedInput
    targetUser?: UserUpdateOneWithoutReceivedHoursSalesNestedInput
  }

  export type SellingHoursReportsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursAdded?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    hourPrice?: FloatFieldUpdateOperationsInput | number
    soldBy?: NullableIntFieldUpdateOperationsInput | number | null
    targetUserId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SellingHoursReportsCreateManyInput = {
    id?: string
    hoursAdded: number
    addedAt: Date | string
    userId: number
    hourPrice: number
    soldBy?: number | null
    targetUserId?: number | null
  }

  export type SellingHoursReportsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursAdded?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hourPrice?: FloatFieldUpdateOperationsInput | number
    soldBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SellingHoursReportsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursAdded?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    hourPrice?: FloatFieldUpdateOperationsInput | number
    soldBy?: NullableIntFieldUpdateOperationsInput | number | null
    targetUserId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserHoursReportsCreateInput = {
    id?: string
    hoursBought: number
    boughtAt: Date | string
    hourPrice: number
    soldBy: number
    user: UserCreateNestedOneWithoutUserReportsInput
  }

  export type UserHoursReportsUncheckedCreateInput = {
    id?: string
    userId: number
    hoursBought: number
    boughtAt: Date | string
    hourPrice: number
    soldBy: number
  }

  export type UserHoursReportsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursBought?: IntFieldUpdateOperationsInput | number
    boughtAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hourPrice?: FloatFieldUpdateOperationsInput | number
    soldBy?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutUserReportsNestedInput
  }

  export type UserHoursReportsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    hoursBought?: IntFieldUpdateOperationsInput | number
    boughtAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hourPrice?: FloatFieldUpdateOperationsInput | number
    soldBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserHoursReportsCreateManyInput = {
    id?: string
    userId: number
    hoursBought: number
    boughtAt: Date | string
    hourPrice: number
    soldBy: number
  }

  export type UserHoursReportsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursBought?: IntFieldUpdateOperationsInput | number
    boughtAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hourPrice?: FloatFieldUpdateOperationsInput | number
    soldBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserHoursReportsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    hoursBought?: IntFieldUpdateOperationsInput | number
    boughtAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hourPrice?: FloatFieldUpdateOperationsInput | number
    soldBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserParkingReportsCreateInput = {
    id?: string
    startedAt: Date | string
    finishedAt: Date | string
    patentId: string
    totalHours: number
    hourPrice: number
    user: UserCreateNestedOneWithoutUserParkingReportsInput
  }

  export type UserParkingReportsUncheckedCreateInput = {
    id?: string
    userId: number
    startedAt: Date | string
    finishedAt: Date | string
    patentId: string
    totalHours: number
    hourPrice: number
  }

  export type UserParkingReportsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patentId?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    hourPrice?: FloatFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutUserParkingReportsNestedInput
  }

  export type UserParkingReportsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patentId?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    hourPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type UserParkingReportsCreateManyInput = {
    id?: string
    userId: number
    startedAt: Date | string
    finishedAt: Date | string
    patentId: string
    totalHours: number
    hourPrice: number
  }

  export type UserParkingReportsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patentId?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    hourPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type UserParkingReportsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patentId?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    hourPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type HoursPricesCreateInput = {
    currency: string
    hourPrice: number
    createdAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    dayPrice?: number | null
    weekPrice?: number | null
  }

  export type HoursPricesUncheckedCreateInput = {
    id?: number
    currency: string
    hourPrice: number
    createdAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    dayPrice?: number | null
    weekPrice?: number | null
  }

  export type HoursPricesUpdateInput = {
    currency?: StringFieldUpdateOperationsInput | string
    hourPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weekPrice?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type HoursPricesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    hourPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weekPrice?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type HoursPricesCreateManyInput = {
    id?: number
    currency: string
    hourPrice: number
    createdAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    dayPrice?: number | null
    weekPrice?: number | null
  }

  export type HoursPricesUpdateManyMutationInput = {
    currency?: StringFieldUpdateOperationsInput | string
    hourPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weekPrice?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type HoursPricesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    hourPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weekPrice?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ParkingCreateInput = {
    id?: string
    hours: number
    startedAt?: Date | string
    finishedAt?: Date | string | null
    patentId: string
    isMonthly?: boolean
    user?: UserCreateNestedOneWithoutParkingInput
  }

  export type ParkingUncheckedCreateInput = {
    id?: string
    hours: number
    startedAt?: Date | string
    finishedAt?: Date | string | null
    patentId: string
    userId?: number | null
    isMonthly?: boolean
  }

  export type ParkingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hours?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patentId?: StringFieldUpdateOperationsInput | string
    isMonthly?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutParkingNestedInput
  }

  export type ParkingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hours?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patentId?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    isMonthly?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ParkingCreateManyInput = {
    id?: string
    hours: number
    startedAt?: Date | string
    finishedAt?: Date | string | null
    patentId: string
    userId?: number | null
    isMonthly?: boolean
  }

  export type ParkingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hours?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patentId?: StringFieldUpdateOperationsInput | string
    isMonthly?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ParkingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hours?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patentId?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    isMonthly?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InfractionCreateInput = {
    id?: string
    numberId?: number
    createdAt: Date | string
    cancelled?: boolean
    cancelledAt?: Date | string | null
    cancelledReason?: string | null
    patentId: string
    street?: string | null
    payed: boolean
    payedAt?: Date | string | null
    isEnableToPay?: boolean | null
    paymentMethod?: string | null
    images?: InfractionImageCreateNestedManyWithoutInfractionInput
    payedByUser?: UserCreateNestedOneWithoutPaidInfractionsInput
  }

  export type InfractionUncheckedCreateInput = {
    id?: string
    numberId?: number
    createdAt: Date | string
    cancelled?: boolean
    cancelledAt?: Date | string | null
    cancelledReason?: string | null
    patentId: string
    street?: string | null
    payed: boolean
    payedAt?: Date | string | null
    isEnableToPay?: boolean | null
    paymentMethod?: string | null
    payedByUserId?: number | null
    images?: InfractionImageUncheckedCreateNestedManyWithoutInfractionInput
  }

  export type InfractionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledReason?: NullableStringFieldUpdateOperationsInput | string | null
    patentId?: StringFieldUpdateOperationsInput | string
    street?: NullableStringFieldUpdateOperationsInput | string | null
    payed?: BoolFieldUpdateOperationsInput | boolean
    payedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEnableToPay?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    images?: InfractionImageUpdateManyWithoutInfractionNestedInput
    payedByUser?: UserUpdateOneWithoutPaidInfractionsNestedInput
  }

  export type InfractionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numberId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledReason?: NullableStringFieldUpdateOperationsInput | string | null
    patentId?: StringFieldUpdateOperationsInput | string
    street?: NullableStringFieldUpdateOperationsInput | string | null
    payed?: BoolFieldUpdateOperationsInput | boolean
    payedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEnableToPay?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    payedByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    images?: InfractionImageUncheckedUpdateManyWithoutInfractionNestedInput
  }

  export type InfractionCreateManyInput = {
    id?: string
    numberId?: number
    createdAt: Date | string
    cancelled?: boolean
    cancelledAt?: Date | string | null
    cancelledReason?: string | null
    patentId: string
    street?: string | null
    payed: boolean
    payedAt?: Date | string | null
    isEnableToPay?: boolean | null
    paymentMethod?: string | null
    payedByUserId?: number | null
  }

  export type InfractionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledReason?: NullableStringFieldUpdateOperationsInput | string | null
    patentId?: StringFieldUpdateOperationsInput | string
    street?: NullableStringFieldUpdateOperationsInput | string | null
    payed?: BoolFieldUpdateOperationsInput | boolean
    payedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEnableToPay?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InfractionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numberId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledReason?: NullableStringFieldUpdateOperationsInput | string | null
    patentId?: StringFieldUpdateOperationsInput | string
    street?: NullableStringFieldUpdateOperationsInput | string | null
    payed?: BoolFieldUpdateOperationsInput | boolean
    payedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEnableToPay?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    payedByUserId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InfractionImageCreateInput = {
    id?: string
    url: string
    createdAt?: Date | string
    infraction: InfractionCreateNestedOneWithoutImagesInput
  }

  export type InfractionImageUncheckedCreateInput = {
    id?: string
    url: string
    infractionId: string
    createdAt?: Date | string
  }

  export type InfractionImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    infraction?: InfractionUpdateOneRequiredWithoutImagesNestedInput
  }

  export type InfractionImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    infractionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfractionImageCreateManyInput = {
    id?: string
    url: string
    infractionId: string
    createdAt?: Date | string
  }

  export type InfractionImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfractionImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    infractionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SingleParkingComprobantCreateInput = {
    patentId: string
    dni: number
    hours: number
    sellingPoint: string
    createdAt?: Date | string
  }

  export type SingleParkingComprobantUncheckedCreateInput = {
    id?: number
    patentId: string
    dni: number
    hours: number
    sellingPoint: string
    createdAt?: Date | string
  }

  export type SingleParkingComprobantUpdateInput = {
    patentId?: StringFieldUpdateOperationsInput | string
    dni?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    sellingPoint?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SingleParkingComprobantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patentId?: StringFieldUpdateOperationsInput | string
    dni?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    sellingPoint?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SingleParkingComprobantCreateManyInput = {
    id?: number
    patentId: string
    dni: number
    hours: number
    sellingPoint: string
    createdAt?: Date | string
  }

  export type SingleParkingComprobantUpdateManyMutationInput = {
    patentId?: StringFieldUpdateOperationsInput | string
    dni?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    sellingPoint?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SingleParkingComprobantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patentId?: StringFieldUpdateOperationsInput | string
    dni?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    sellingPoint?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellingHoursComprobantCreateInput = {
    dni: number
    hours: number
    sellingPoint: string
    price: number
    createdAt: Date | string
  }

  export type SellingHoursComprobantUncheckedCreateInput = {
    id?: number
    dni: number
    hours: number
    sellingPoint: string
    price: number
    createdAt: Date | string
  }

  export type SellingHoursComprobantUpdateInput = {
    dni?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    sellingPoint?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellingHoursComprobantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    sellingPoint?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellingHoursComprobantCreateManyInput = {
    id?: number
    dni: number
    hours: number
    sellingPoint: string
    price: number
    createdAt: Date | string
  }

  export type SellingHoursComprobantUpdateManyMutationInput = {
    dni?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    sellingPoint?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellingHoursComprobantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    sellingPoint?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolidayCreateInput = {
    identifier: string
    name: string
    type: string
    infoUrl?: string | null
    day: number
    month: number
    original?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HolidayUncheckedCreateInput = {
    id?: number
    identifier: string
    name: string
    type: string
    infoUrl?: string | null
    day: number
    month: number
    original?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HolidayUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    infoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    day?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    original?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolidayUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    infoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    day?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    original?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolidayCreateManyInput = {
    id?: number
    identifier: string
    name: string
    type: string
    infoUrl?: string | null
    day: number
    month: number
    original?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HolidayUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    infoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    day?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    original?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolidayUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    identifier?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    infoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    day?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    original?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellingPointHoursComprobantCreateInput = {
    dni: number
    hours: number
    sellingPoint: string
    sellerName: string
    price: number
    createdAt: Date | string
  }

  export type SellingPointHoursComprobantUncheckedCreateInput = {
    id?: number
    dni: number
    hours: number
    sellingPoint: string
    sellerName: string
    price: number
    createdAt: Date | string
  }

  export type SellingPointHoursComprobantUpdateInput = {
    dni?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    sellingPoint?: StringFieldUpdateOperationsInput | string
    sellerName?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellingPointHoursComprobantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    sellingPoint?: StringFieldUpdateOperationsInput | string
    sellerName?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellingPointHoursComprobantCreateManyInput = {
    id?: number
    dni: number
    hours: number
    sellingPoint: string
    sellerName: string
    price: number
    createdAt: Date | string
  }

  export type SellingPointHoursComprobantUpdateManyMutationInput = {
    dni?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    sellingPoint?: StringFieldUpdateOperationsInput | string
    sellerName?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellingPointHoursComprobantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    sellingPoint?: StringFieldUpdateOperationsInput | string
    sellerName?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellingMonthlyComprobantCreateInput = {
    dni: number
    patentId: string
    createdAt?: Date | string
    finishedAt?: Date | string | null
    totalPrice: number
    soldBy: number
  }

  export type SellingMonthlyComprobantUncheckedCreateInput = {
    id?: number
    dni: number
    patentId: string
    createdAt?: Date | string
    finishedAt?: Date | string | null
    totalPrice: number
    soldBy: number
  }

  export type SellingMonthlyComprobantUpdateInput = {
    dni?: IntFieldUpdateOperationsInput | number
    patentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPrice?: IntFieldUpdateOperationsInput | number
    soldBy?: IntFieldUpdateOperationsInput | number
  }

  export type SellingMonthlyComprobantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    patentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPrice?: IntFieldUpdateOperationsInput | number
    soldBy?: IntFieldUpdateOperationsInput | number
  }

  export type SellingMonthlyComprobantCreateManyInput = {
    id?: number
    dni: number
    patentId: string
    createdAt?: Date | string
    finishedAt?: Date | string | null
    totalPrice: number
    soldBy: number
  }

  export type SellingMonthlyComprobantUpdateManyMutationInput = {
    dni?: IntFieldUpdateOperationsInput | number
    patentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPrice?: IntFieldUpdateOperationsInput | number
    soldBy?: IntFieldUpdateOperationsInput | number
  }

  export type SellingMonthlyComprobantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    patentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPrice?: IntFieldUpdateOperationsInput | number
    soldBy?: IntFieldUpdateOperationsInput | number
  }

  export type MovieCreateInput = {
    id?: string
    title: string
    description: string
    durationMinutes: number
    language: string
    format: $Enums.Format
    posterUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    showings?: ShowingCreateNestedManyWithoutMovieInput
  }

  export type MovieUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    durationMinutes: number
    language: string
    format: $Enums.Format
    posterUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    showings?: ShowingUncheckedCreateNestedManyWithoutMovieInput
  }

  export type MovieUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    format?: EnumFormatFieldUpdateOperationsInput | $Enums.Format
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    showings?: ShowingUpdateManyWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    format?: EnumFormatFieldUpdateOperationsInput | $Enums.Format
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    showings?: ShowingUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type MovieCreateManyInput = {
    id?: string
    title: string
    description: string
    durationMinutes: number
    language: string
    format: $Enums.Format
    posterUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MovieUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    format?: EnumFormatFieldUpdateOperationsInput | $Enums.Format
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    format?: EnumFormatFieldUpdateOperationsInput | $Enums.Format
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShowingCreateInput = {
    id?: string
    startTime: Date | string
    priceCents: number
    rows: number
    seatsPerRow: number
    totalSeats: number
    status?: $Enums.ShowingStatus
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    movie: MovieCreateNestedOneWithoutShowingsInput
    seats?: SeatCreateNestedManyWithoutShowingInput
    seatHolds?: SeatHoldCreateNestedManyWithoutShowingInput
    credits?: CinemaCreditCreateNestedManyWithoutShowingInput
  }

  export type ShowingUncheckedCreateInput = {
    id?: string
    movieId: string
    startTime: Date | string
    priceCents: number
    rows: number
    seatsPerRow: number
    totalSeats: number
    status?: $Enums.ShowingStatus
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    seats?: SeatUncheckedCreateNestedManyWithoutShowingInput
    seatHolds?: SeatHoldUncheckedCreateNestedManyWithoutShowingInput
    credits?: CinemaCreditUncheckedCreateNestedManyWithoutShowingInput
  }

  export type ShowingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    priceCents?: IntFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    seatsPerRow?: IntFieldUpdateOperationsInput | number
    totalSeats?: IntFieldUpdateOperationsInput | number
    status?: EnumShowingStatusFieldUpdateOperationsInput | $Enums.ShowingStatus
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movie?: MovieUpdateOneRequiredWithoutShowingsNestedInput
    seats?: SeatUpdateManyWithoutShowingNestedInput
    seatHolds?: SeatHoldUpdateManyWithoutShowingNestedInput
    credits?: CinemaCreditUpdateManyWithoutShowingNestedInput
  }

  export type ShowingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    priceCents?: IntFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    seatsPerRow?: IntFieldUpdateOperationsInput | number
    totalSeats?: IntFieldUpdateOperationsInput | number
    status?: EnumShowingStatusFieldUpdateOperationsInput | $Enums.ShowingStatus
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seats?: SeatUncheckedUpdateManyWithoutShowingNestedInput
    seatHolds?: SeatHoldUncheckedUpdateManyWithoutShowingNestedInput
    credits?: CinemaCreditUncheckedUpdateManyWithoutShowingNestedInput
  }

  export type ShowingCreateManyInput = {
    id?: string
    movieId: string
    startTime: Date | string
    priceCents: number
    rows: number
    seatsPerRow: number
    totalSeats: number
    status?: $Enums.ShowingStatus
    cancelledAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ShowingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    priceCents?: IntFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    seatsPerRow?: IntFieldUpdateOperationsInput | number
    totalSeats?: IntFieldUpdateOperationsInput | number
    status?: EnumShowingStatusFieldUpdateOperationsInput | $Enums.ShowingStatus
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShowingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    priceCents?: IntFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    seatsPerRow?: IntFieldUpdateOperationsInput | number
    totalSeats?: IntFieldUpdateOperationsInput | number
    status?: EnumShowingStatusFieldUpdateOperationsInput | $Enums.ShowingStatus
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatCreateInput = {
    id?: string
    rowLabel: string
    number: number
    status?: $Enums.SeatStatus
    createdAt?: Date | string
    showing: ShowingCreateNestedOneWithoutSeatsInput
    tickets?: TicketCreateNestedManyWithoutSeatInput
    hold?: SeatHoldCreateNestedOneWithoutSeatInput
  }

  export type SeatUncheckedCreateInput = {
    id?: string
    showingId: string
    rowLabel: string
    number: number
    status?: $Enums.SeatStatus
    createdAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutSeatInput
    hold?: SeatHoldUncheckedCreateNestedOneWithoutSeatInput
  }

  export type SeatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowLabel?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    showing?: ShowingUpdateOneRequiredWithoutSeatsNestedInput
    tickets?: TicketUpdateManyWithoutSeatNestedInput
    hold?: SeatHoldUpdateOneWithoutSeatNestedInput
  }

  export type SeatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    showingId?: StringFieldUpdateOperationsInput | string
    rowLabel?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutSeatNestedInput
    hold?: SeatHoldUncheckedUpdateOneWithoutSeatNestedInput
  }

  export type SeatCreateManyInput = {
    id?: string
    showingId: string
    rowLabel: string
    number: number
    status?: $Enums.SeatStatus
    createdAt?: Date | string
  }

  export type SeatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowLabel?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    showingId?: StringFieldUpdateOperationsInput | string
    rowLabel?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatHoldCreateInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    seat: SeatCreateNestedOneWithoutHoldInput
    showing: ShowingCreateNestedOneWithoutSeatHoldsInput
    user: UserCreateNestedOneWithoutSeatHoldsInput
  }

  export type SeatHoldUncheckedCreateInput = {
    id?: string
    seatId: string
    showingId: string
    userId: number
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type SeatHoldUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seat?: SeatUpdateOneRequiredWithoutHoldNestedInput
    showing?: ShowingUpdateOneRequiredWithoutSeatHoldsNestedInput
    user?: UserUpdateOneRequiredWithoutSeatHoldsNestedInput
  }

  export type SeatHoldUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatId?: StringFieldUpdateOperationsInput | string
    showingId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatHoldCreateManyInput = {
    id?: string
    seatId: string
    showingId: string
    userId: number
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type SeatHoldUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatHoldUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatId?: StringFieldUpdateOperationsInput | string
    showingId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateInput = {
    id?: string
    createdAt?: Date | string
    status: $Enums.BookingStatus
    channel: $Enums.PurchaseChannel
    totalPriceCents: number
    customerEmail?: string | null
    customer?: UserCreateNestedOneWithoutBookingsInput
    soldBy?: UserCreateNestedOneWithoutSoldBookingsInput
    tickets?: TicketCreateNestedManyWithoutBookingInput
    credits?: CinemaCreditCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    status: $Enums.BookingStatus
    channel: $Enums.PurchaseChannel
    totalPriceCents: number
    customerId?: number | null
    soldById?: number | null
    customerEmail?: string | null
    tickets?: TicketUncheckedCreateNestedManyWithoutBookingInput
    credits?: CinemaCreditUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    channel?: EnumPurchaseChannelFieldUpdateOperationsInput | $Enums.PurchaseChannel
    totalPriceCents?: IntFieldUpdateOperationsInput | number
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: UserUpdateOneWithoutBookingsNestedInput
    soldBy?: UserUpdateOneWithoutSoldBookingsNestedInput
    tickets?: TicketUpdateManyWithoutBookingNestedInput
    credits?: CinemaCreditUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    channel?: EnumPurchaseChannelFieldUpdateOperationsInput | $Enums.PurchaseChannel
    totalPriceCents?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    soldById?: NullableIntFieldUpdateOperationsInput | number | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tickets?: TicketUncheckedUpdateManyWithoutBookingNestedInput
    credits?: CinemaCreditUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateManyInput = {
    id?: string
    createdAt?: Date | string
    status: $Enums.BookingStatus
    channel: $Enums.PurchaseChannel
    totalPriceCents: number
    customerId?: number | null
    soldById?: number | null
    customerEmail?: string | null
  }

  export type BookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    channel?: EnumPurchaseChannelFieldUpdateOperationsInput | $Enums.PurchaseChannel
    totalPriceCents?: IntFieldUpdateOperationsInput | number
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    channel?: EnumPurchaseChannelFieldUpdateOperationsInput | $Enums.PurchaseChannel
    totalPriceCents?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    soldById?: NullableIntFieldUpdateOperationsInput | number | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketCreateInput = {
    id?: string
    qrToken: string
    checkedInAt?: Date | string | null
    createdAt?: Date | string
    booking: BookingCreateNestedOneWithoutTicketsInput
    seat: SeatCreateNestedOneWithoutTicketsInput
  }

  export type TicketUncheckedCreateInput = {
    id?: string
    bookingId: string
    seatId: string
    qrToken: string
    checkedInAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrToken?: StringFieldUpdateOperationsInput | string
    checkedInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutTicketsNestedInput
    seat?: SeatUpdateOneRequiredWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    seatId?: StringFieldUpdateOperationsInput | string
    qrToken?: StringFieldUpdateOperationsInput | string
    checkedInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCreateManyInput = {
    id?: string
    bookingId: string
    seatId: string
    qrToken: string
    checkedInAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrToken?: StringFieldUpdateOperationsInput | string
    checkedInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    seatId?: StringFieldUpdateOperationsInput | string
    qrToken?: StringFieldUpdateOperationsInput | string
    checkedInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CinemaCreditCreateInput = {
    id?: string
    amountCents: number
    remainingCents: number
    reason: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutCinemaCreditsInput
    booking?: BookingCreateNestedOneWithoutCreditsInput
    showing?: ShowingCreateNestedOneWithoutCreditsInput
  }

  export type CinemaCreditUncheckedCreateInput = {
    id?: string
    userId: number
    bookingId?: string | null
    showingId?: string | null
    amountCents: number
    remainingCents: number
    reason: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type CinemaCreditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    remainingCents?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCinemaCreditsNestedInput
    booking?: BookingUpdateOneWithoutCreditsNestedInput
    showing?: ShowingUpdateOneWithoutCreditsNestedInput
  }

  export type CinemaCreditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    showingId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    remainingCents?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CinemaCreditCreateManyInput = {
    id?: string
    userId: number
    bookingId?: string | null
    showingId?: string | null
    amountCents: number
    remainingCents: number
    reason: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type CinemaCreditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    remainingCents?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CinemaCreditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    showingId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    remainingCents?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type PatentListRelationFilter = {
    every?: PatentWhereInput
    some?: PatentWhereInput
    none?: PatentWhereInput
  }

  export type DeletedPatentsListRelationFilter = {
    every?: DeletedPatentsWhereInput
    some?: DeletedPatentsWhereInput
    none?: DeletedPatentsWhereInput
  }

  export type SellPointListRelationFilter = {
    every?: SellPointWhereInput
    some?: SellPointWhereInput
    none?: SellPointWhereInput
  }

  export type SellingHoursReportsListRelationFilter = {
    every?: SellingHoursReportsWhereInput
    some?: SellingHoursReportsWhereInput
    none?: SellingHoursReportsWhereInput
  }

  export type ParkingListRelationFilter = {
    every?: ParkingWhereInput
    some?: ParkingWhereInput
    none?: ParkingWhereInput
  }

  export type UserHoursReportsListRelationFilter = {
    every?: UserHoursReportsWhereInput
    some?: UserHoursReportsWhereInput
    none?: UserHoursReportsWhereInput
  }

  export type UserParkingReportsListRelationFilter = {
    every?: UserParkingReportsWhereInput
    some?: UserParkingReportsWhereInput
    none?: UserParkingReportsWhereInput
  }

  export type InfractionListRelationFilter = {
    every?: InfractionWhereInput
    some?: InfractionWhereInput
    none?: InfractionWhereInput
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type SeatHoldListRelationFilter = {
    every?: SeatHoldWhereInput
    some?: SeatHoldWhereInput
    none?: SeatHoldWhereInput
  }

  export type CinemaCreditListRelationFilter = {
    every?: CinemaCreditWhereInput
    some?: CinemaCreditWhereInput
    none?: CinemaCreditWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PatentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeletedPatentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SellPointOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SellingHoursReportsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParkingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserHoursReportsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserParkingReportsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InfractionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeatHoldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CinemaCreditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    type?: SortOrder
    dni?: SortOrder
    role?: SortOrder
    availableHours?: SortOrder
    availableMinutes?: SortOrder
    usedHours?: SortOrder
    recoveryCode?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    dni?: SortOrder
    availableHours?: SortOrder
    availableMinutes?: SortOrder
    usedHours?: SortOrder
    recoveryCode?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    type?: SortOrder
    dni?: SortOrder
    role?: SortOrder
    availableHours?: SortOrder
    availableMinutes?: SortOrder
    usedHours?: SortOrder
    recoveryCode?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    type?: SortOrder
    dni?: SortOrder
    role?: SortOrder
    availableHours?: SortOrder
    availableMinutes?: SortOrder
    usedHours?: SortOrder
    recoveryCode?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    dni?: SortOrder
    availableHours?: SortOrder
    availableMinutes?: SortOrder
    usedHours?: SortOrder
    recoveryCode?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AssignHoursReportsListRelationFilter = {
    every?: AssignHoursReportsWhereInput
    some?: AssignHoursReportsWhereInput
    none?: AssignHoursReportsWhereInput
  }

  export type AssignPatentHoursReportsListRelationFilter = {
    every?: AssignPatentHoursReportsWhereInput
    some?: AssignPatentHoursReportsWhereInput
    none?: AssignPatentHoursReportsWhereInput
  }

  export type AssignHoursReportsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssignPatentHoursReportsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SellPointCountOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    street?: SortOrder
    streetNumber?: SortOrder
    availableHours?: SortOrder
    usedHours?: SortOrder
    pointName?: SortOrder
    dni?: SortOrder
    userId?: SortOrder
    profitPercentage?: SortOrder
  }

  export type SellPointAvgOrderByAggregateInput = {
    id?: SortOrder
    streetNumber?: SortOrder
    availableHours?: SortOrder
    usedHours?: SortOrder
    dni?: SortOrder
    userId?: SortOrder
    profitPercentage?: SortOrder
  }

  export type SellPointMaxOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    street?: SortOrder
    streetNumber?: SortOrder
    availableHours?: SortOrder
    usedHours?: SortOrder
    pointName?: SortOrder
    dni?: SortOrder
    userId?: SortOrder
    profitPercentage?: SortOrder
  }

  export type SellPointMinOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    street?: SortOrder
    streetNumber?: SortOrder
    availableHours?: SortOrder
    usedHours?: SortOrder
    pointName?: SortOrder
    dni?: SortOrder
    userId?: SortOrder
    profitPercentage?: SortOrder
  }

  export type SellPointSumOrderByAggregateInput = {
    id?: SortOrder
    streetNumber?: SortOrder
    availableHours?: SortOrder
    usedHours?: SortOrder
    dni?: SortOrder
    userId?: SortOrder
    profitPercentage?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PatentCountOrderByAggregateInput = {
    id?: SortOrder
    patentId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    hasSingleHours?: SortOrder
    singleHours?: SortOrder
    dni?: SortOrder
    isAllowed?: SortOrder
    canShow?: SortOrder
    isAllowedIn?: SortOrder
    houseType?: SortOrder
  }

  export type PatentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    singleHours?: SortOrder
    dni?: SortOrder
  }

  export type PatentMaxOrderByAggregateInput = {
    id?: SortOrder
    patentId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    hasSingleHours?: SortOrder
    singleHours?: SortOrder
    dni?: SortOrder
    isAllowed?: SortOrder
    canShow?: SortOrder
    isAllowedIn?: SortOrder
    houseType?: SortOrder
  }

  export type PatentMinOrderByAggregateInput = {
    id?: SortOrder
    patentId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    hasSingleHours?: SortOrder
    singleHours?: SortOrder
    dni?: SortOrder
    isAllowed?: SortOrder
    canShow?: SortOrder
    isAllowedIn?: SortOrder
    houseType?: SortOrder
  }

  export type PatentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    singleHours?: SortOrder
    dni?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type PatentValidationCountOrderByAggregateInput = {
    id?: SortOrder
    patentId?: SortOrder
    validationsToday?: SortOrder
    validatedAt?: SortOrder
  }

  export type PatentValidationAvgOrderByAggregateInput = {
    id?: SortOrder
    validationsToday?: SortOrder
  }

  export type PatentValidationMaxOrderByAggregateInput = {
    id?: SortOrder
    patentId?: SortOrder
    validationsToday?: SortOrder
    validatedAt?: SortOrder
  }

  export type PatentValidationMinOrderByAggregateInput = {
    id?: SortOrder
    patentId?: SortOrder
    validationsToday?: SortOrder
    validatedAt?: SortOrder
  }

  export type PatentValidationSumOrderByAggregateInput = {
    id?: SortOrder
    validationsToday?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type DeletedPatentsCountOrderByAggregateInput = {
    id?: SortOrder
    patentId?: SortOrder
    userId?: SortOrder
    deletedAt?: SortOrder
  }

  export type DeletedPatentsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DeletedPatentsMaxOrderByAggregateInput = {
    id?: SortOrder
    patentId?: SortOrder
    userId?: SortOrder
    deletedAt?: SortOrder
  }

  export type DeletedPatentsMinOrderByAggregateInput = {
    id?: SortOrder
    patentId?: SortOrder
    userId?: SortOrder
    deletedAt?: SortOrder
  }

  export type DeletedPatentsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type SellPointRelationFilter = {
    is?: SellPointWhereInput
    isNot?: SellPointWhereInput
  }

  export type AssignHoursReportsCountOrderByAggregateInput = {
    id?: SortOrder
    hoursAdded?: SortOrder
    addedAt?: SortOrder
    sellPointId?: SortOrder
    hourPrice?: SortOrder
    soldBy?: SortOrder
  }

  export type AssignHoursReportsAvgOrderByAggregateInput = {
    hoursAdded?: SortOrder
    sellPointId?: SortOrder
    hourPrice?: SortOrder
    soldBy?: SortOrder
  }

  export type AssignHoursReportsMaxOrderByAggregateInput = {
    id?: SortOrder
    hoursAdded?: SortOrder
    addedAt?: SortOrder
    sellPointId?: SortOrder
    hourPrice?: SortOrder
    soldBy?: SortOrder
  }

  export type AssignHoursReportsMinOrderByAggregateInput = {
    id?: SortOrder
    hoursAdded?: SortOrder
    addedAt?: SortOrder
    sellPointId?: SortOrder
    hourPrice?: SortOrder
    soldBy?: SortOrder
  }

  export type AssignHoursReportsSumOrderByAggregateInput = {
    hoursAdded?: SortOrder
    sellPointId?: SortOrder
    hourPrice?: SortOrder
    soldBy?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type SellPointNullableRelationFilter = {
    is?: SellPointWhereInput | null
    isNot?: SellPointWhereInput | null
  }

  export type AssignPatentHoursReportsCountOrderByAggregateInput = {
    id?: SortOrder
    hoursAdded?: SortOrder
    addedAt?: SortOrder
    sellPointId?: SortOrder
    hourPrice?: SortOrder
    patentId?: SortOrder
    dni?: SortOrder
    soldBy?: SortOrder
  }

  export type AssignPatentHoursReportsAvgOrderByAggregateInput = {
    hoursAdded?: SortOrder
    sellPointId?: SortOrder
    hourPrice?: SortOrder
    dni?: SortOrder
    soldBy?: SortOrder
  }

  export type AssignPatentHoursReportsMaxOrderByAggregateInput = {
    id?: SortOrder
    hoursAdded?: SortOrder
    addedAt?: SortOrder
    sellPointId?: SortOrder
    hourPrice?: SortOrder
    patentId?: SortOrder
    dni?: SortOrder
    soldBy?: SortOrder
  }

  export type AssignPatentHoursReportsMinOrderByAggregateInput = {
    id?: SortOrder
    hoursAdded?: SortOrder
    addedAt?: SortOrder
    sellPointId?: SortOrder
    hourPrice?: SortOrder
    patentId?: SortOrder
    dni?: SortOrder
    soldBy?: SortOrder
  }

  export type AssignPatentHoursReportsSumOrderByAggregateInput = {
    hoursAdded?: SortOrder
    sellPointId?: SortOrder
    hourPrice?: SortOrder
    dni?: SortOrder
    soldBy?: SortOrder
  }

  export type SellingHoursReportsCountOrderByAggregateInput = {
    id?: SortOrder
    hoursAdded?: SortOrder
    addedAt?: SortOrder
    userId?: SortOrder
    hourPrice?: SortOrder
    soldBy?: SortOrder
    targetUserId?: SortOrder
  }

  export type SellingHoursReportsAvgOrderByAggregateInput = {
    hoursAdded?: SortOrder
    userId?: SortOrder
    hourPrice?: SortOrder
    soldBy?: SortOrder
    targetUserId?: SortOrder
  }

  export type SellingHoursReportsMaxOrderByAggregateInput = {
    id?: SortOrder
    hoursAdded?: SortOrder
    addedAt?: SortOrder
    userId?: SortOrder
    hourPrice?: SortOrder
    soldBy?: SortOrder
    targetUserId?: SortOrder
  }

  export type SellingHoursReportsMinOrderByAggregateInput = {
    id?: SortOrder
    hoursAdded?: SortOrder
    addedAt?: SortOrder
    userId?: SortOrder
    hourPrice?: SortOrder
    soldBy?: SortOrder
    targetUserId?: SortOrder
  }

  export type SellingHoursReportsSumOrderByAggregateInput = {
    hoursAdded?: SortOrder
    userId?: SortOrder
    hourPrice?: SortOrder
    soldBy?: SortOrder
    targetUserId?: SortOrder
  }

  export type UserHoursReportsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    hoursBought?: SortOrder
    boughtAt?: SortOrder
    hourPrice?: SortOrder
    soldBy?: SortOrder
  }

  export type UserHoursReportsAvgOrderByAggregateInput = {
    userId?: SortOrder
    hoursBought?: SortOrder
    hourPrice?: SortOrder
    soldBy?: SortOrder
  }

  export type UserHoursReportsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    hoursBought?: SortOrder
    boughtAt?: SortOrder
    hourPrice?: SortOrder
    soldBy?: SortOrder
  }

  export type UserHoursReportsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    hoursBought?: SortOrder
    boughtAt?: SortOrder
    hourPrice?: SortOrder
    soldBy?: SortOrder
  }

  export type UserHoursReportsSumOrderByAggregateInput = {
    userId?: SortOrder
    hoursBought?: SortOrder
    hourPrice?: SortOrder
    soldBy?: SortOrder
  }

  export type UserParkingReportsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    patentId?: SortOrder
    totalHours?: SortOrder
    hourPrice?: SortOrder
  }

  export type UserParkingReportsAvgOrderByAggregateInput = {
    userId?: SortOrder
    totalHours?: SortOrder
    hourPrice?: SortOrder
  }

  export type UserParkingReportsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    patentId?: SortOrder
    totalHours?: SortOrder
    hourPrice?: SortOrder
  }

  export type UserParkingReportsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    patentId?: SortOrder
    totalHours?: SortOrder
    hourPrice?: SortOrder
  }

  export type UserParkingReportsSumOrderByAggregateInput = {
    userId?: SortOrder
    totalHours?: SortOrder
    hourPrice?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type HoursPricesCountOrderByAggregateInput = {
    id?: SortOrder
    currency?: SortOrder
    hourPrice?: SortOrder
    createdAt?: SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrder
    dayPrice?: SortOrder
    weekPrice?: SortOrder
  }

  export type HoursPricesAvgOrderByAggregateInput = {
    id?: SortOrder
    hourPrice?: SortOrder
    dayPrice?: SortOrder
    weekPrice?: SortOrder
  }

  export type HoursPricesMaxOrderByAggregateInput = {
    id?: SortOrder
    currency?: SortOrder
    hourPrice?: SortOrder
    createdAt?: SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrder
    dayPrice?: SortOrder
    weekPrice?: SortOrder
  }

  export type HoursPricesMinOrderByAggregateInput = {
    id?: SortOrder
    currency?: SortOrder
    hourPrice?: SortOrder
    createdAt?: SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrder
    dayPrice?: SortOrder
    weekPrice?: SortOrder
  }

  export type HoursPricesSumOrderByAggregateInput = {
    id?: SortOrder
    hourPrice?: SortOrder
    dayPrice?: SortOrder
    weekPrice?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ParkingCountOrderByAggregateInput = {
    id?: SortOrder
    hours?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    patentId?: SortOrder
    userId?: SortOrder
    isMonthly?: SortOrder
  }

  export type ParkingAvgOrderByAggregateInput = {
    hours?: SortOrder
    userId?: SortOrder
  }

  export type ParkingMaxOrderByAggregateInput = {
    id?: SortOrder
    hours?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    patentId?: SortOrder
    userId?: SortOrder
    isMonthly?: SortOrder
  }

  export type ParkingMinOrderByAggregateInput = {
    id?: SortOrder
    hours?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    patentId?: SortOrder
    userId?: SortOrder
    isMonthly?: SortOrder
  }

  export type ParkingSumOrderByAggregateInput = {
    hours?: SortOrder
    userId?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type InfractionImageListRelationFilter = {
    every?: InfractionImageWhereInput
    some?: InfractionImageWhereInput
    none?: InfractionImageWhereInput
  }

  export type InfractionImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InfractionCountOrderByAggregateInput = {
    id?: SortOrder
    numberId?: SortOrder
    createdAt?: SortOrder
    cancelled?: SortOrder
    cancelledAt?: SortOrder
    cancelledReason?: SortOrder
    patentId?: SortOrder
    street?: SortOrder
    payed?: SortOrder
    payedAt?: SortOrder
    isEnableToPay?: SortOrder
    paymentMethod?: SortOrder
    payedByUserId?: SortOrder
  }

  export type InfractionAvgOrderByAggregateInput = {
    numberId?: SortOrder
    payedByUserId?: SortOrder
  }

  export type InfractionMaxOrderByAggregateInput = {
    id?: SortOrder
    numberId?: SortOrder
    createdAt?: SortOrder
    cancelled?: SortOrder
    cancelledAt?: SortOrder
    cancelledReason?: SortOrder
    patentId?: SortOrder
    street?: SortOrder
    payed?: SortOrder
    payedAt?: SortOrder
    isEnableToPay?: SortOrder
    paymentMethod?: SortOrder
    payedByUserId?: SortOrder
  }

  export type InfractionMinOrderByAggregateInput = {
    id?: SortOrder
    numberId?: SortOrder
    createdAt?: SortOrder
    cancelled?: SortOrder
    cancelledAt?: SortOrder
    cancelledReason?: SortOrder
    patentId?: SortOrder
    street?: SortOrder
    payed?: SortOrder
    payedAt?: SortOrder
    isEnableToPay?: SortOrder
    paymentMethod?: SortOrder
    payedByUserId?: SortOrder
  }

  export type InfractionSumOrderByAggregateInput = {
    numberId?: SortOrder
    payedByUserId?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type InfractionRelationFilter = {
    is?: InfractionWhereInput
    isNot?: InfractionWhereInput
  }

  export type InfractionImageCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    infractionId?: SortOrder
    createdAt?: SortOrder
  }

  export type InfractionImageMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    infractionId?: SortOrder
    createdAt?: SortOrder
  }

  export type InfractionImageMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    infractionId?: SortOrder
    createdAt?: SortOrder
  }

  export type SingleParkingComprobantCountOrderByAggregateInput = {
    id?: SortOrder
    patentId?: SortOrder
    dni?: SortOrder
    hours?: SortOrder
    sellingPoint?: SortOrder
    createdAt?: SortOrder
  }

  export type SingleParkingComprobantAvgOrderByAggregateInput = {
    id?: SortOrder
    dni?: SortOrder
    hours?: SortOrder
  }

  export type SingleParkingComprobantMaxOrderByAggregateInput = {
    id?: SortOrder
    patentId?: SortOrder
    dni?: SortOrder
    hours?: SortOrder
    sellingPoint?: SortOrder
    createdAt?: SortOrder
  }

  export type SingleParkingComprobantMinOrderByAggregateInput = {
    id?: SortOrder
    patentId?: SortOrder
    dni?: SortOrder
    hours?: SortOrder
    sellingPoint?: SortOrder
    createdAt?: SortOrder
  }

  export type SingleParkingComprobantSumOrderByAggregateInput = {
    id?: SortOrder
    dni?: SortOrder
    hours?: SortOrder
  }

  export type SellingHoursComprobantCountOrderByAggregateInput = {
    id?: SortOrder
    dni?: SortOrder
    hours?: SortOrder
    sellingPoint?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type SellingHoursComprobantAvgOrderByAggregateInput = {
    id?: SortOrder
    dni?: SortOrder
    hours?: SortOrder
    price?: SortOrder
  }

  export type SellingHoursComprobantMaxOrderByAggregateInput = {
    id?: SortOrder
    dni?: SortOrder
    hours?: SortOrder
    sellingPoint?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type SellingHoursComprobantMinOrderByAggregateInput = {
    id?: SortOrder
    dni?: SortOrder
    hours?: SortOrder
    sellingPoint?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type SellingHoursComprobantSumOrderByAggregateInput = {
    id?: SortOrder
    dni?: SortOrder
    hours?: SortOrder
    price?: SortOrder
  }

  export type HolidayCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    name?: SortOrder
    type?: SortOrder
    infoUrl?: SortOrder
    day?: SortOrder
    month?: SortOrder
    original?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HolidayAvgOrderByAggregateInput = {
    id?: SortOrder
    day?: SortOrder
    month?: SortOrder
  }

  export type HolidayMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    name?: SortOrder
    type?: SortOrder
    infoUrl?: SortOrder
    day?: SortOrder
    month?: SortOrder
    original?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HolidayMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    name?: SortOrder
    type?: SortOrder
    infoUrl?: SortOrder
    day?: SortOrder
    month?: SortOrder
    original?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HolidaySumOrderByAggregateInput = {
    id?: SortOrder
    day?: SortOrder
    month?: SortOrder
  }

  export type SellingPointHoursComprobantCountOrderByAggregateInput = {
    id?: SortOrder
    dni?: SortOrder
    hours?: SortOrder
    sellingPoint?: SortOrder
    sellerName?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type SellingPointHoursComprobantAvgOrderByAggregateInput = {
    id?: SortOrder
    dni?: SortOrder
    hours?: SortOrder
    price?: SortOrder
  }

  export type SellingPointHoursComprobantMaxOrderByAggregateInput = {
    id?: SortOrder
    dni?: SortOrder
    hours?: SortOrder
    sellingPoint?: SortOrder
    sellerName?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type SellingPointHoursComprobantMinOrderByAggregateInput = {
    id?: SortOrder
    dni?: SortOrder
    hours?: SortOrder
    sellingPoint?: SortOrder
    sellerName?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type SellingPointHoursComprobantSumOrderByAggregateInput = {
    id?: SortOrder
    dni?: SortOrder
    hours?: SortOrder
    price?: SortOrder
  }

  export type SellingMonthlyComprobantCountOrderByAggregateInput = {
    id?: SortOrder
    dni?: SortOrder
    patentId?: SortOrder
    createdAt?: SortOrder
    finishedAt?: SortOrder
    totalPrice?: SortOrder
    soldBy?: SortOrder
  }

  export type SellingMonthlyComprobantAvgOrderByAggregateInput = {
    id?: SortOrder
    dni?: SortOrder
    totalPrice?: SortOrder
    soldBy?: SortOrder
  }

  export type SellingMonthlyComprobantMaxOrderByAggregateInput = {
    id?: SortOrder
    dni?: SortOrder
    patentId?: SortOrder
    createdAt?: SortOrder
    finishedAt?: SortOrder
    totalPrice?: SortOrder
    soldBy?: SortOrder
  }

  export type SellingMonthlyComprobantMinOrderByAggregateInput = {
    id?: SortOrder
    dni?: SortOrder
    patentId?: SortOrder
    createdAt?: SortOrder
    finishedAt?: SortOrder
    totalPrice?: SortOrder
    soldBy?: SortOrder
  }

  export type SellingMonthlyComprobantSumOrderByAggregateInput = {
    id?: SortOrder
    dni?: SortOrder
    totalPrice?: SortOrder
    soldBy?: SortOrder
  }

  export type EnumFormatFilter<$PrismaModel = never> = {
    equals?: $Enums.Format | EnumFormatFieldRefInput<$PrismaModel>
    in?: $Enums.Format[] | ListEnumFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.Format[] | ListEnumFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumFormatFilter<$PrismaModel> | $Enums.Format
  }

  export type ShowingListRelationFilter = {
    every?: ShowingWhereInput
    some?: ShowingWhereInput
    none?: ShowingWhereInput
  }

  export type ShowingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MovieCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    durationMinutes?: SortOrder
    language?: SortOrder
    format?: SortOrder
    posterUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovieAvgOrderByAggregateInput = {
    durationMinutes?: SortOrder
  }

  export type MovieMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    durationMinutes?: SortOrder
    language?: SortOrder
    format?: SortOrder
    posterUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovieMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    durationMinutes?: SortOrder
    language?: SortOrder
    format?: SortOrder
    posterUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovieSumOrderByAggregateInput = {
    durationMinutes?: SortOrder
  }

  export type EnumFormatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Format | EnumFormatFieldRefInput<$PrismaModel>
    in?: $Enums.Format[] | ListEnumFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.Format[] | ListEnumFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumFormatWithAggregatesFilter<$PrismaModel> | $Enums.Format
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFormatFilter<$PrismaModel>
    _max?: NestedEnumFormatFilter<$PrismaModel>
  }

  export type EnumShowingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ShowingStatus | EnumShowingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShowingStatus[] | ListEnumShowingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShowingStatus[] | ListEnumShowingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShowingStatusFilter<$PrismaModel> | $Enums.ShowingStatus
  }

  export type MovieRelationFilter = {
    is?: MovieWhereInput
    isNot?: MovieWhereInput
  }

  export type SeatListRelationFilter = {
    every?: SeatWhereInput
    some?: SeatWhereInput
    none?: SeatWhereInput
  }

  export type SeatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShowingCountOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    startTime?: SortOrder
    priceCents?: SortOrder
    rows?: SortOrder
    seatsPerRow?: SortOrder
    totalSeats?: SortOrder
    status?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ShowingAvgOrderByAggregateInput = {
    priceCents?: SortOrder
    rows?: SortOrder
    seatsPerRow?: SortOrder
    totalSeats?: SortOrder
  }

  export type ShowingMaxOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    startTime?: SortOrder
    priceCents?: SortOrder
    rows?: SortOrder
    seatsPerRow?: SortOrder
    totalSeats?: SortOrder
    status?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ShowingMinOrderByAggregateInput = {
    id?: SortOrder
    movieId?: SortOrder
    startTime?: SortOrder
    priceCents?: SortOrder
    rows?: SortOrder
    seatsPerRow?: SortOrder
    totalSeats?: SortOrder
    status?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ShowingSumOrderByAggregateInput = {
    priceCents?: SortOrder
    rows?: SortOrder
    seatsPerRow?: SortOrder
    totalSeats?: SortOrder
  }

  export type EnumShowingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShowingStatus | EnumShowingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShowingStatus[] | ListEnumShowingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShowingStatus[] | ListEnumShowingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShowingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ShowingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShowingStatusFilter<$PrismaModel>
    _max?: NestedEnumShowingStatusFilter<$PrismaModel>
  }

  export type EnumSeatStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SeatStatus | EnumSeatStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SeatStatus[] | ListEnumSeatStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SeatStatus[] | ListEnumSeatStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSeatStatusFilter<$PrismaModel> | $Enums.SeatStatus
  }

  export type ShowingRelationFilter = {
    is?: ShowingWhereInput
    isNot?: ShowingWhereInput
  }

  export type TicketListRelationFilter = {
    every?: TicketWhereInput
    some?: TicketWhereInput
    none?: TicketWhereInput
  }

  export type SeatHoldNullableRelationFilter = {
    is?: SeatHoldWhereInput | null
    isNot?: SeatHoldWhereInput | null
  }

  export type TicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeatShowingIdRowLabelNumberCompoundUniqueInput = {
    showingId: string
    rowLabel: string
    number: number
  }

  export type SeatCountOrderByAggregateInput = {
    id?: SortOrder
    showingId?: SortOrder
    rowLabel?: SortOrder
    number?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type SeatAvgOrderByAggregateInput = {
    number?: SortOrder
  }

  export type SeatMaxOrderByAggregateInput = {
    id?: SortOrder
    showingId?: SortOrder
    rowLabel?: SortOrder
    number?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type SeatMinOrderByAggregateInput = {
    id?: SortOrder
    showingId?: SortOrder
    rowLabel?: SortOrder
    number?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type SeatSumOrderByAggregateInput = {
    number?: SortOrder
  }

  export type EnumSeatStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SeatStatus | EnumSeatStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SeatStatus[] | ListEnumSeatStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SeatStatus[] | ListEnumSeatStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSeatStatusWithAggregatesFilter<$PrismaModel> | $Enums.SeatStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSeatStatusFilter<$PrismaModel>
    _max?: NestedEnumSeatStatusFilter<$PrismaModel>
  }

  export type SeatRelationFilter = {
    is?: SeatWhereInput
    isNot?: SeatWhereInput
  }

  export type SeatHoldCountOrderByAggregateInput = {
    id?: SortOrder
    seatId?: SortOrder
    showingId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type SeatHoldAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type SeatHoldMaxOrderByAggregateInput = {
    id?: SortOrder
    seatId?: SortOrder
    showingId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type SeatHoldMinOrderByAggregateInput = {
    id?: SortOrder
    seatId?: SortOrder
    showingId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type SeatHoldSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type EnumPurchaseChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseChannel | EnumPurchaseChannelFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseChannel[] | ListEnumPurchaseChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseChannel[] | ListEnumPurchaseChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseChannelFilter<$PrismaModel> | $Enums.PurchaseChannel
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    channel?: SortOrder
    totalPriceCents?: SortOrder
    customerId?: SortOrder
    soldById?: SortOrder
    customerEmail?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    totalPriceCents?: SortOrder
    customerId?: SortOrder
    soldById?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    channel?: SortOrder
    totalPriceCents?: SortOrder
    customerId?: SortOrder
    soldById?: SortOrder
    customerEmail?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    channel?: SortOrder
    totalPriceCents?: SortOrder
    customerId?: SortOrder
    soldById?: SortOrder
    customerEmail?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    totalPriceCents?: SortOrder
    customerId?: SortOrder
    soldById?: SortOrder
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type EnumPurchaseChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseChannel | EnumPurchaseChannelFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseChannel[] | ListEnumPurchaseChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseChannel[] | ListEnumPurchaseChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseChannelWithAggregatesFilter<$PrismaModel> | $Enums.PurchaseChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPurchaseChannelFilter<$PrismaModel>
    _max?: NestedEnumPurchaseChannelFilter<$PrismaModel>
  }

  export type BookingRelationFilter = {
    is?: BookingWhereInput
    isNot?: BookingWhereInput
  }

  export type TicketCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    seatId?: SortOrder
    qrToken?: SortOrder
    checkedInAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    seatId?: SortOrder
    qrToken?: SortOrder
    checkedInAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    seatId?: SortOrder
    qrToken?: SortOrder
    checkedInAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingNullableRelationFilter = {
    is?: BookingWhereInput | null
    isNot?: BookingWhereInput | null
  }

  export type ShowingNullableRelationFilter = {
    is?: ShowingWhereInput | null
    isNot?: ShowingWhereInput | null
  }

  export type CinemaCreditCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
    showingId?: SortOrder
    amountCents?: SortOrder
    remainingCents?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type CinemaCreditAvgOrderByAggregateInput = {
    userId?: SortOrder
    amountCents?: SortOrder
    remainingCents?: SortOrder
  }

  export type CinemaCreditMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
    showingId?: SortOrder
    amountCents?: SortOrder
    remainingCents?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type CinemaCreditMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
    showingId?: SortOrder
    amountCents?: SortOrder
    remainingCents?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type CinemaCreditSumOrderByAggregateInput = {
    userId?: SortOrder
    amountCents?: SortOrder
    remainingCents?: SortOrder
  }

  export type PatentCreateNestedManyWithoutUserInput = {
    create?: XOR<PatentCreateWithoutUserInput, PatentUncheckedCreateWithoutUserInput> | PatentCreateWithoutUserInput[] | PatentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PatentCreateOrConnectWithoutUserInput | PatentCreateOrConnectWithoutUserInput[]
    createMany?: PatentCreateManyUserInputEnvelope
    connect?: PatentWhereUniqueInput | PatentWhereUniqueInput[]
  }

  export type DeletedPatentsCreateNestedManyWithoutUserInput = {
    create?: XOR<DeletedPatentsCreateWithoutUserInput, DeletedPatentsUncheckedCreateWithoutUserInput> | DeletedPatentsCreateWithoutUserInput[] | DeletedPatentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeletedPatentsCreateOrConnectWithoutUserInput | DeletedPatentsCreateOrConnectWithoutUserInput[]
    createMany?: DeletedPatentsCreateManyUserInputEnvelope
    connect?: DeletedPatentsWhereUniqueInput | DeletedPatentsWhereUniqueInput[]
  }

  export type SellPointCreateNestedManyWithoutUserInput = {
    create?: XOR<SellPointCreateWithoutUserInput, SellPointUncheckedCreateWithoutUserInput> | SellPointCreateWithoutUserInput[] | SellPointUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SellPointCreateOrConnectWithoutUserInput | SellPointCreateOrConnectWithoutUserInput[]
    createMany?: SellPointCreateManyUserInputEnvelope
    connect?: SellPointWhereUniqueInput | SellPointWhereUniqueInput[]
  }

  export type SellingHoursReportsCreateNestedManyWithoutUserInput = {
    create?: XOR<SellingHoursReportsCreateWithoutUserInput, SellingHoursReportsUncheckedCreateWithoutUserInput> | SellingHoursReportsCreateWithoutUserInput[] | SellingHoursReportsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SellingHoursReportsCreateOrConnectWithoutUserInput | SellingHoursReportsCreateOrConnectWithoutUserInput[]
    createMany?: SellingHoursReportsCreateManyUserInputEnvelope
    connect?: SellingHoursReportsWhereUniqueInput | SellingHoursReportsWhereUniqueInput[]
  }

  export type ParkingCreateNestedManyWithoutUserInput = {
    create?: XOR<ParkingCreateWithoutUserInput, ParkingUncheckedCreateWithoutUserInput> | ParkingCreateWithoutUserInput[] | ParkingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ParkingCreateOrConnectWithoutUserInput | ParkingCreateOrConnectWithoutUserInput[]
    createMany?: ParkingCreateManyUserInputEnvelope
    connect?: ParkingWhereUniqueInput | ParkingWhereUniqueInput[]
  }

  export type UserHoursReportsCreateNestedManyWithoutUserInput = {
    create?: XOR<UserHoursReportsCreateWithoutUserInput, UserHoursReportsUncheckedCreateWithoutUserInput> | UserHoursReportsCreateWithoutUserInput[] | UserHoursReportsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserHoursReportsCreateOrConnectWithoutUserInput | UserHoursReportsCreateOrConnectWithoutUserInput[]
    createMany?: UserHoursReportsCreateManyUserInputEnvelope
    connect?: UserHoursReportsWhereUniqueInput | UserHoursReportsWhereUniqueInput[]
  }

  export type UserParkingReportsCreateNestedManyWithoutUserInput = {
    create?: XOR<UserParkingReportsCreateWithoutUserInput, UserParkingReportsUncheckedCreateWithoutUserInput> | UserParkingReportsCreateWithoutUserInput[] | UserParkingReportsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserParkingReportsCreateOrConnectWithoutUserInput | UserParkingReportsCreateOrConnectWithoutUserInput[]
    createMany?: UserParkingReportsCreateManyUserInputEnvelope
    connect?: UserParkingReportsWhereUniqueInput | UserParkingReportsWhereUniqueInput[]
  }

  export type InfractionCreateNestedManyWithoutPayedByUserInput = {
    create?: XOR<InfractionCreateWithoutPayedByUserInput, InfractionUncheckedCreateWithoutPayedByUserInput> | InfractionCreateWithoutPayedByUserInput[] | InfractionUncheckedCreateWithoutPayedByUserInput[]
    connectOrCreate?: InfractionCreateOrConnectWithoutPayedByUserInput | InfractionCreateOrConnectWithoutPayedByUserInput[]
    createMany?: InfractionCreateManyPayedByUserInputEnvelope
    connect?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
  }

  export type SellingHoursReportsCreateNestedManyWithoutTargetUserInput = {
    create?: XOR<SellingHoursReportsCreateWithoutTargetUserInput, SellingHoursReportsUncheckedCreateWithoutTargetUserInput> | SellingHoursReportsCreateWithoutTargetUserInput[] | SellingHoursReportsUncheckedCreateWithoutTargetUserInput[]
    connectOrCreate?: SellingHoursReportsCreateOrConnectWithoutTargetUserInput | SellingHoursReportsCreateOrConnectWithoutTargetUserInput[]
    createMany?: SellingHoursReportsCreateManyTargetUserInputEnvelope
    connect?: SellingHoursReportsWhereUniqueInput | SellingHoursReportsWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutCustomerInput = {
    create?: XOR<BookingCreateWithoutCustomerInput, BookingUncheckedCreateWithoutCustomerInput> | BookingCreateWithoutCustomerInput[] | BookingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutCustomerInput | BookingCreateOrConnectWithoutCustomerInput[]
    createMany?: BookingCreateManyCustomerInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutSoldByInput = {
    create?: XOR<BookingCreateWithoutSoldByInput, BookingUncheckedCreateWithoutSoldByInput> | BookingCreateWithoutSoldByInput[] | BookingUncheckedCreateWithoutSoldByInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutSoldByInput | BookingCreateOrConnectWithoutSoldByInput[]
    createMany?: BookingCreateManySoldByInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type SeatHoldCreateNestedManyWithoutUserInput = {
    create?: XOR<SeatHoldCreateWithoutUserInput, SeatHoldUncheckedCreateWithoutUserInput> | SeatHoldCreateWithoutUserInput[] | SeatHoldUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SeatHoldCreateOrConnectWithoutUserInput | SeatHoldCreateOrConnectWithoutUserInput[]
    createMany?: SeatHoldCreateManyUserInputEnvelope
    connect?: SeatHoldWhereUniqueInput | SeatHoldWhereUniqueInput[]
  }

  export type CinemaCreditCreateNestedManyWithoutUserInput = {
    create?: XOR<CinemaCreditCreateWithoutUserInput, CinemaCreditUncheckedCreateWithoutUserInput> | CinemaCreditCreateWithoutUserInput[] | CinemaCreditUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CinemaCreditCreateOrConnectWithoutUserInput | CinemaCreditCreateOrConnectWithoutUserInput[]
    createMany?: CinemaCreditCreateManyUserInputEnvelope
    connect?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
  }

  export type PatentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PatentCreateWithoutUserInput, PatentUncheckedCreateWithoutUserInput> | PatentCreateWithoutUserInput[] | PatentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PatentCreateOrConnectWithoutUserInput | PatentCreateOrConnectWithoutUserInput[]
    createMany?: PatentCreateManyUserInputEnvelope
    connect?: PatentWhereUniqueInput | PatentWhereUniqueInput[]
  }

  export type DeletedPatentsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DeletedPatentsCreateWithoutUserInput, DeletedPatentsUncheckedCreateWithoutUserInput> | DeletedPatentsCreateWithoutUserInput[] | DeletedPatentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeletedPatentsCreateOrConnectWithoutUserInput | DeletedPatentsCreateOrConnectWithoutUserInput[]
    createMany?: DeletedPatentsCreateManyUserInputEnvelope
    connect?: DeletedPatentsWhereUniqueInput | DeletedPatentsWhereUniqueInput[]
  }

  export type SellPointUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SellPointCreateWithoutUserInput, SellPointUncheckedCreateWithoutUserInput> | SellPointCreateWithoutUserInput[] | SellPointUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SellPointCreateOrConnectWithoutUserInput | SellPointCreateOrConnectWithoutUserInput[]
    createMany?: SellPointCreateManyUserInputEnvelope
    connect?: SellPointWhereUniqueInput | SellPointWhereUniqueInput[]
  }

  export type SellingHoursReportsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SellingHoursReportsCreateWithoutUserInput, SellingHoursReportsUncheckedCreateWithoutUserInput> | SellingHoursReportsCreateWithoutUserInput[] | SellingHoursReportsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SellingHoursReportsCreateOrConnectWithoutUserInput | SellingHoursReportsCreateOrConnectWithoutUserInput[]
    createMany?: SellingHoursReportsCreateManyUserInputEnvelope
    connect?: SellingHoursReportsWhereUniqueInput | SellingHoursReportsWhereUniqueInput[]
  }

  export type ParkingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ParkingCreateWithoutUserInput, ParkingUncheckedCreateWithoutUserInput> | ParkingCreateWithoutUserInput[] | ParkingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ParkingCreateOrConnectWithoutUserInput | ParkingCreateOrConnectWithoutUserInput[]
    createMany?: ParkingCreateManyUserInputEnvelope
    connect?: ParkingWhereUniqueInput | ParkingWhereUniqueInput[]
  }

  export type UserHoursReportsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserHoursReportsCreateWithoutUserInput, UserHoursReportsUncheckedCreateWithoutUserInput> | UserHoursReportsCreateWithoutUserInput[] | UserHoursReportsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserHoursReportsCreateOrConnectWithoutUserInput | UserHoursReportsCreateOrConnectWithoutUserInput[]
    createMany?: UserHoursReportsCreateManyUserInputEnvelope
    connect?: UserHoursReportsWhereUniqueInput | UserHoursReportsWhereUniqueInput[]
  }

  export type UserParkingReportsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserParkingReportsCreateWithoutUserInput, UserParkingReportsUncheckedCreateWithoutUserInput> | UserParkingReportsCreateWithoutUserInput[] | UserParkingReportsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserParkingReportsCreateOrConnectWithoutUserInput | UserParkingReportsCreateOrConnectWithoutUserInput[]
    createMany?: UserParkingReportsCreateManyUserInputEnvelope
    connect?: UserParkingReportsWhereUniqueInput | UserParkingReportsWhereUniqueInput[]
  }

  export type InfractionUncheckedCreateNestedManyWithoutPayedByUserInput = {
    create?: XOR<InfractionCreateWithoutPayedByUserInput, InfractionUncheckedCreateWithoutPayedByUserInput> | InfractionCreateWithoutPayedByUserInput[] | InfractionUncheckedCreateWithoutPayedByUserInput[]
    connectOrCreate?: InfractionCreateOrConnectWithoutPayedByUserInput | InfractionCreateOrConnectWithoutPayedByUserInput[]
    createMany?: InfractionCreateManyPayedByUserInputEnvelope
    connect?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
  }

  export type SellingHoursReportsUncheckedCreateNestedManyWithoutTargetUserInput = {
    create?: XOR<SellingHoursReportsCreateWithoutTargetUserInput, SellingHoursReportsUncheckedCreateWithoutTargetUserInput> | SellingHoursReportsCreateWithoutTargetUserInput[] | SellingHoursReportsUncheckedCreateWithoutTargetUserInput[]
    connectOrCreate?: SellingHoursReportsCreateOrConnectWithoutTargetUserInput | SellingHoursReportsCreateOrConnectWithoutTargetUserInput[]
    createMany?: SellingHoursReportsCreateManyTargetUserInputEnvelope
    connect?: SellingHoursReportsWhereUniqueInput | SellingHoursReportsWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<BookingCreateWithoutCustomerInput, BookingUncheckedCreateWithoutCustomerInput> | BookingCreateWithoutCustomerInput[] | BookingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutCustomerInput | BookingCreateOrConnectWithoutCustomerInput[]
    createMany?: BookingCreateManyCustomerInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutSoldByInput = {
    create?: XOR<BookingCreateWithoutSoldByInput, BookingUncheckedCreateWithoutSoldByInput> | BookingCreateWithoutSoldByInput[] | BookingUncheckedCreateWithoutSoldByInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutSoldByInput | BookingCreateOrConnectWithoutSoldByInput[]
    createMany?: BookingCreateManySoldByInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type SeatHoldUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SeatHoldCreateWithoutUserInput, SeatHoldUncheckedCreateWithoutUserInput> | SeatHoldCreateWithoutUserInput[] | SeatHoldUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SeatHoldCreateOrConnectWithoutUserInput | SeatHoldCreateOrConnectWithoutUserInput[]
    createMany?: SeatHoldCreateManyUserInputEnvelope
    connect?: SeatHoldWhereUniqueInput | SeatHoldWhereUniqueInput[]
  }

  export type CinemaCreditUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CinemaCreditCreateWithoutUserInput, CinemaCreditUncheckedCreateWithoutUserInput> | CinemaCreditCreateWithoutUserInput[] | CinemaCreditUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CinemaCreditCreateOrConnectWithoutUserInput | CinemaCreditCreateOrConnectWithoutUserInput[]
    createMany?: CinemaCreditCreateManyUserInputEnvelope
    connect?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PatentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PatentCreateWithoutUserInput, PatentUncheckedCreateWithoutUserInput> | PatentCreateWithoutUserInput[] | PatentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PatentCreateOrConnectWithoutUserInput | PatentCreateOrConnectWithoutUserInput[]
    upsert?: PatentUpsertWithWhereUniqueWithoutUserInput | PatentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PatentCreateManyUserInputEnvelope
    set?: PatentWhereUniqueInput | PatentWhereUniqueInput[]
    disconnect?: PatentWhereUniqueInput | PatentWhereUniqueInput[]
    delete?: PatentWhereUniqueInput | PatentWhereUniqueInput[]
    connect?: PatentWhereUniqueInput | PatentWhereUniqueInput[]
    update?: PatentUpdateWithWhereUniqueWithoutUserInput | PatentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PatentUpdateManyWithWhereWithoutUserInput | PatentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PatentScalarWhereInput | PatentScalarWhereInput[]
  }

  export type DeletedPatentsUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeletedPatentsCreateWithoutUserInput, DeletedPatentsUncheckedCreateWithoutUserInput> | DeletedPatentsCreateWithoutUserInput[] | DeletedPatentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeletedPatentsCreateOrConnectWithoutUserInput | DeletedPatentsCreateOrConnectWithoutUserInput[]
    upsert?: DeletedPatentsUpsertWithWhereUniqueWithoutUserInput | DeletedPatentsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeletedPatentsCreateManyUserInputEnvelope
    set?: DeletedPatentsWhereUniqueInput | DeletedPatentsWhereUniqueInput[]
    disconnect?: DeletedPatentsWhereUniqueInput | DeletedPatentsWhereUniqueInput[]
    delete?: DeletedPatentsWhereUniqueInput | DeletedPatentsWhereUniqueInput[]
    connect?: DeletedPatentsWhereUniqueInput | DeletedPatentsWhereUniqueInput[]
    update?: DeletedPatentsUpdateWithWhereUniqueWithoutUserInput | DeletedPatentsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeletedPatentsUpdateManyWithWhereWithoutUserInput | DeletedPatentsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeletedPatentsScalarWhereInput | DeletedPatentsScalarWhereInput[]
  }

  export type SellPointUpdateManyWithoutUserNestedInput = {
    create?: XOR<SellPointCreateWithoutUserInput, SellPointUncheckedCreateWithoutUserInput> | SellPointCreateWithoutUserInput[] | SellPointUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SellPointCreateOrConnectWithoutUserInput | SellPointCreateOrConnectWithoutUserInput[]
    upsert?: SellPointUpsertWithWhereUniqueWithoutUserInput | SellPointUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SellPointCreateManyUserInputEnvelope
    set?: SellPointWhereUniqueInput | SellPointWhereUniqueInput[]
    disconnect?: SellPointWhereUniqueInput | SellPointWhereUniqueInput[]
    delete?: SellPointWhereUniqueInput | SellPointWhereUniqueInput[]
    connect?: SellPointWhereUniqueInput | SellPointWhereUniqueInput[]
    update?: SellPointUpdateWithWhereUniqueWithoutUserInput | SellPointUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SellPointUpdateManyWithWhereWithoutUserInput | SellPointUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SellPointScalarWhereInput | SellPointScalarWhereInput[]
  }

  export type SellingHoursReportsUpdateManyWithoutUserNestedInput = {
    create?: XOR<SellingHoursReportsCreateWithoutUserInput, SellingHoursReportsUncheckedCreateWithoutUserInput> | SellingHoursReportsCreateWithoutUserInput[] | SellingHoursReportsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SellingHoursReportsCreateOrConnectWithoutUserInput | SellingHoursReportsCreateOrConnectWithoutUserInput[]
    upsert?: SellingHoursReportsUpsertWithWhereUniqueWithoutUserInput | SellingHoursReportsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SellingHoursReportsCreateManyUserInputEnvelope
    set?: SellingHoursReportsWhereUniqueInput | SellingHoursReportsWhereUniqueInput[]
    disconnect?: SellingHoursReportsWhereUniqueInput | SellingHoursReportsWhereUniqueInput[]
    delete?: SellingHoursReportsWhereUniqueInput | SellingHoursReportsWhereUniqueInput[]
    connect?: SellingHoursReportsWhereUniqueInput | SellingHoursReportsWhereUniqueInput[]
    update?: SellingHoursReportsUpdateWithWhereUniqueWithoutUserInput | SellingHoursReportsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SellingHoursReportsUpdateManyWithWhereWithoutUserInput | SellingHoursReportsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SellingHoursReportsScalarWhereInput | SellingHoursReportsScalarWhereInput[]
  }

  export type ParkingUpdateManyWithoutUserNestedInput = {
    create?: XOR<ParkingCreateWithoutUserInput, ParkingUncheckedCreateWithoutUserInput> | ParkingCreateWithoutUserInput[] | ParkingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ParkingCreateOrConnectWithoutUserInput | ParkingCreateOrConnectWithoutUserInput[]
    upsert?: ParkingUpsertWithWhereUniqueWithoutUserInput | ParkingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ParkingCreateManyUserInputEnvelope
    set?: ParkingWhereUniqueInput | ParkingWhereUniqueInput[]
    disconnect?: ParkingWhereUniqueInput | ParkingWhereUniqueInput[]
    delete?: ParkingWhereUniqueInput | ParkingWhereUniqueInput[]
    connect?: ParkingWhereUniqueInput | ParkingWhereUniqueInput[]
    update?: ParkingUpdateWithWhereUniqueWithoutUserInput | ParkingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ParkingUpdateManyWithWhereWithoutUserInput | ParkingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ParkingScalarWhereInput | ParkingScalarWhereInput[]
  }

  export type UserHoursReportsUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserHoursReportsCreateWithoutUserInput, UserHoursReportsUncheckedCreateWithoutUserInput> | UserHoursReportsCreateWithoutUserInput[] | UserHoursReportsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserHoursReportsCreateOrConnectWithoutUserInput | UserHoursReportsCreateOrConnectWithoutUserInput[]
    upsert?: UserHoursReportsUpsertWithWhereUniqueWithoutUserInput | UserHoursReportsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserHoursReportsCreateManyUserInputEnvelope
    set?: UserHoursReportsWhereUniqueInput | UserHoursReportsWhereUniqueInput[]
    disconnect?: UserHoursReportsWhereUniqueInput | UserHoursReportsWhereUniqueInput[]
    delete?: UserHoursReportsWhereUniqueInput | UserHoursReportsWhereUniqueInput[]
    connect?: UserHoursReportsWhereUniqueInput | UserHoursReportsWhereUniqueInput[]
    update?: UserHoursReportsUpdateWithWhereUniqueWithoutUserInput | UserHoursReportsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserHoursReportsUpdateManyWithWhereWithoutUserInput | UserHoursReportsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserHoursReportsScalarWhereInput | UserHoursReportsScalarWhereInput[]
  }

  export type UserParkingReportsUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserParkingReportsCreateWithoutUserInput, UserParkingReportsUncheckedCreateWithoutUserInput> | UserParkingReportsCreateWithoutUserInput[] | UserParkingReportsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserParkingReportsCreateOrConnectWithoutUserInput | UserParkingReportsCreateOrConnectWithoutUserInput[]
    upsert?: UserParkingReportsUpsertWithWhereUniqueWithoutUserInput | UserParkingReportsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserParkingReportsCreateManyUserInputEnvelope
    set?: UserParkingReportsWhereUniqueInput | UserParkingReportsWhereUniqueInput[]
    disconnect?: UserParkingReportsWhereUniqueInput | UserParkingReportsWhereUniqueInput[]
    delete?: UserParkingReportsWhereUniqueInput | UserParkingReportsWhereUniqueInput[]
    connect?: UserParkingReportsWhereUniqueInput | UserParkingReportsWhereUniqueInput[]
    update?: UserParkingReportsUpdateWithWhereUniqueWithoutUserInput | UserParkingReportsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserParkingReportsUpdateManyWithWhereWithoutUserInput | UserParkingReportsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserParkingReportsScalarWhereInput | UserParkingReportsScalarWhereInput[]
  }

  export type InfractionUpdateManyWithoutPayedByUserNestedInput = {
    create?: XOR<InfractionCreateWithoutPayedByUserInput, InfractionUncheckedCreateWithoutPayedByUserInput> | InfractionCreateWithoutPayedByUserInput[] | InfractionUncheckedCreateWithoutPayedByUserInput[]
    connectOrCreate?: InfractionCreateOrConnectWithoutPayedByUserInput | InfractionCreateOrConnectWithoutPayedByUserInput[]
    upsert?: InfractionUpsertWithWhereUniqueWithoutPayedByUserInput | InfractionUpsertWithWhereUniqueWithoutPayedByUserInput[]
    createMany?: InfractionCreateManyPayedByUserInputEnvelope
    set?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    disconnect?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    delete?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    connect?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    update?: InfractionUpdateWithWhereUniqueWithoutPayedByUserInput | InfractionUpdateWithWhereUniqueWithoutPayedByUserInput[]
    updateMany?: InfractionUpdateManyWithWhereWithoutPayedByUserInput | InfractionUpdateManyWithWhereWithoutPayedByUserInput[]
    deleteMany?: InfractionScalarWhereInput | InfractionScalarWhereInput[]
  }

  export type SellingHoursReportsUpdateManyWithoutTargetUserNestedInput = {
    create?: XOR<SellingHoursReportsCreateWithoutTargetUserInput, SellingHoursReportsUncheckedCreateWithoutTargetUserInput> | SellingHoursReportsCreateWithoutTargetUserInput[] | SellingHoursReportsUncheckedCreateWithoutTargetUserInput[]
    connectOrCreate?: SellingHoursReportsCreateOrConnectWithoutTargetUserInput | SellingHoursReportsCreateOrConnectWithoutTargetUserInput[]
    upsert?: SellingHoursReportsUpsertWithWhereUniqueWithoutTargetUserInput | SellingHoursReportsUpsertWithWhereUniqueWithoutTargetUserInput[]
    createMany?: SellingHoursReportsCreateManyTargetUserInputEnvelope
    set?: SellingHoursReportsWhereUniqueInput | SellingHoursReportsWhereUniqueInput[]
    disconnect?: SellingHoursReportsWhereUniqueInput | SellingHoursReportsWhereUniqueInput[]
    delete?: SellingHoursReportsWhereUniqueInput | SellingHoursReportsWhereUniqueInput[]
    connect?: SellingHoursReportsWhereUniqueInput | SellingHoursReportsWhereUniqueInput[]
    update?: SellingHoursReportsUpdateWithWhereUniqueWithoutTargetUserInput | SellingHoursReportsUpdateWithWhereUniqueWithoutTargetUserInput[]
    updateMany?: SellingHoursReportsUpdateManyWithWhereWithoutTargetUserInput | SellingHoursReportsUpdateManyWithWhereWithoutTargetUserInput[]
    deleteMany?: SellingHoursReportsScalarWhereInput | SellingHoursReportsScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<BookingCreateWithoutCustomerInput, BookingUncheckedCreateWithoutCustomerInput> | BookingCreateWithoutCustomerInput[] | BookingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutCustomerInput | BookingCreateOrConnectWithoutCustomerInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutCustomerInput | BookingUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: BookingCreateManyCustomerInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutCustomerInput | BookingUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutCustomerInput | BookingUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutSoldByNestedInput = {
    create?: XOR<BookingCreateWithoutSoldByInput, BookingUncheckedCreateWithoutSoldByInput> | BookingCreateWithoutSoldByInput[] | BookingUncheckedCreateWithoutSoldByInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutSoldByInput | BookingCreateOrConnectWithoutSoldByInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutSoldByInput | BookingUpsertWithWhereUniqueWithoutSoldByInput[]
    createMany?: BookingCreateManySoldByInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutSoldByInput | BookingUpdateWithWhereUniqueWithoutSoldByInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutSoldByInput | BookingUpdateManyWithWhereWithoutSoldByInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type SeatHoldUpdateManyWithoutUserNestedInput = {
    create?: XOR<SeatHoldCreateWithoutUserInput, SeatHoldUncheckedCreateWithoutUserInput> | SeatHoldCreateWithoutUserInput[] | SeatHoldUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SeatHoldCreateOrConnectWithoutUserInput | SeatHoldCreateOrConnectWithoutUserInput[]
    upsert?: SeatHoldUpsertWithWhereUniqueWithoutUserInput | SeatHoldUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SeatHoldCreateManyUserInputEnvelope
    set?: SeatHoldWhereUniqueInput | SeatHoldWhereUniqueInput[]
    disconnect?: SeatHoldWhereUniqueInput | SeatHoldWhereUniqueInput[]
    delete?: SeatHoldWhereUniqueInput | SeatHoldWhereUniqueInput[]
    connect?: SeatHoldWhereUniqueInput | SeatHoldWhereUniqueInput[]
    update?: SeatHoldUpdateWithWhereUniqueWithoutUserInput | SeatHoldUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SeatHoldUpdateManyWithWhereWithoutUserInput | SeatHoldUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SeatHoldScalarWhereInput | SeatHoldScalarWhereInput[]
  }

  export type CinemaCreditUpdateManyWithoutUserNestedInput = {
    create?: XOR<CinemaCreditCreateWithoutUserInput, CinemaCreditUncheckedCreateWithoutUserInput> | CinemaCreditCreateWithoutUserInput[] | CinemaCreditUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CinemaCreditCreateOrConnectWithoutUserInput | CinemaCreditCreateOrConnectWithoutUserInput[]
    upsert?: CinemaCreditUpsertWithWhereUniqueWithoutUserInput | CinemaCreditUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CinemaCreditCreateManyUserInputEnvelope
    set?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
    disconnect?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
    delete?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
    connect?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
    update?: CinemaCreditUpdateWithWhereUniqueWithoutUserInput | CinemaCreditUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CinemaCreditUpdateManyWithWhereWithoutUserInput | CinemaCreditUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CinemaCreditScalarWhereInput | CinemaCreditScalarWhereInput[]
  }

  export type PatentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PatentCreateWithoutUserInput, PatentUncheckedCreateWithoutUserInput> | PatentCreateWithoutUserInput[] | PatentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PatentCreateOrConnectWithoutUserInput | PatentCreateOrConnectWithoutUserInput[]
    upsert?: PatentUpsertWithWhereUniqueWithoutUserInput | PatentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PatentCreateManyUserInputEnvelope
    set?: PatentWhereUniqueInput | PatentWhereUniqueInput[]
    disconnect?: PatentWhereUniqueInput | PatentWhereUniqueInput[]
    delete?: PatentWhereUniqueInput | PatentWhereUniqueInput[]
    connect?: PatentWhereUniqueInput | PatentWhereUniqueInput[]
    update?: PatentUpdateWithWhereUniqueWithoutUserInput | PatentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PatentUpdateManyWithWhereWithoutUserInput | PatentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PatentScalarWhereInput | PatentScalarWhereInput[]
  }

  export type DeletedPatentsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeletedPatentsCreateWithoutUserInput, DeletedPatentsUncheckedCreateWithoutUserInput> | DeletedPatentsCreateWithoutUserInput[] | DeletedPatentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeletedPatentsCreateOrConnectWithoutUserInput | DeletedPatentsCreateOrConnectWithoutUserInput[]
    upsert?: DeletedPatentsUpsertWithWhereUniqueWithoutUserInput | DeletedPatentsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeletedPatentsCreateManyUserInputEnvelope
    set?: DeletedPatentsWhereUniqueInput | DeletedPatentsWhereUniqueInput[]
    disconnect?: DeletedPatentsWhereUniqueInput | DeletedPatentsWhereUniqueInput[]
    delete?: DeletedPatentsWhereUniqueInput | DeletedPatentsWhereUniqueInput[]
    connect?: DeletedPatentsWhereUniqueInput | DeletedPatentsWhereUniqueInput[]
    update?: DeletedPatentsUpdateWithWhereUniqueWithoutUserInput | DeletedPatentsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeletedPatentsUpdateManyWithWhereWithoutUserInput | DeletedPatentsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeletedPatentsScalarWhereInput | DeletedPatentsScalarWhereInput[]
  }

  export type SellPointUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SellPointCreateWithoutUserInput, SellPointUncheckedCreateWithoutUserInput> | SellPointCreateWithoutUserInput[] | SellPointUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SellPointCreateOrConnectWithoutUserInput | SellPointCreateOrConnectWithoutUserInput[]
    upsert?: SellPointUpsertWithWhereUniqueWithoutUserInput | SellPointUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SellPointCreateManyUserInputEnvelope
    set?: SellPointWhereUniqueInput | SellPointWhereUniqueInput[]
    disconnect?: SellPointWhereUniqueInput | SellPointWhereUniqueInput[]
    delete?: SellPointWhereUniqueInput | SellPointWhereUniqueInput[]
    connect?: SellPointWhereUniqueInput | SellPointWhereUniqueInput[]
    update?: SellPointUpdateWithWhereUniqueWithoutUserInput | SellPointUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SellPointUpdateManyWithWhereWithoutUserInput | SellPointUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SellPointScalarWhereInput | SellPointScalarWhereInput[]
  }

  export type SellingHoursReportsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SellingHoursReportsCreateWithoutUserInput, SellingHoursReportsUncheckedCreateWithoutUserInput> | SellingHoursReportsCreateWithoutUserInput[] | SellingHoursReportsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SellingHoursReportsCreateOrConnectWithoutUserInput | SellingHoursReportsCreateOrConnectWithoutUserInput[]
    upsert?: SellingHoursReportsUpsertWithWhereUniqueWithoutUserInput | SellingHoursReportsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SellingHoursReportsCreateManyUserInputEnvelope
    set?: SellingHoursReportsWhereUniqueInput | SellingHoursReportsWhereUniqueInput[]
    disconnect?: SellingHoursReportsWhereUniqueInput | SellingHoursReportsWhereUniqueInput[]
    delete?: SellingHoursReportsWhereUniqueInput | SellingHoursReportsWhereUniqueInput[]
    connect?: SellingHoursReportsWhereUniqueInput | SellingHoursReportsWhereUniqueInput[]
    update?: SellingHoursReportsUpdateWithWhereUniqueWithoutUserInput | SellingHoursReportsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SellingHoursReportsUpdateManyWithWhereWithoutUserInput | SellingHoursReportsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SellingHoursReportsScalarWhereInput | SellingHoursReportsScalarWhereInput[]
  }

  export type ParkingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ParkingCreateWithoutUserInput, ParkingUncheckedCreateWithoutUserInput> | ParkingCreateWithoutUserInput[] | ParkingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ParkingCreateOrConnectWithoutUserInput | ParkingCreateOrConnectWithoutUserInput[]
    upsert?: ParkingUpsertWithWhereUniqueWithoutUserInput | ParkingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ParkingCreateManyUserInputEnvelope
    set?: ParkingWhereUniqueInput | ParkingWhereUniqueInput[]
    disconnect?: ParkingWhereUniqueInput | ParkingWhereUniqueInput[]
    delete?: ParkingWhereUniqueInput | ParkingWhereUniqueInput[]
    connect?: ParkingWhereUniqueInput | ParkingWhereUniqueInput[]
    update?: ParkingUpdateWithWhereUniqueWithoutUserInput | ParkingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ParkingUpdateManyWithWhereWithoutUserInput | ParkingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ParkingScalarWhereInput | ParkingScalarWhereInput[]
  }

  export type UserHoursReportsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserHoursReportsCreateWithoutUserInput, UserHoursReportsUncheckedCreateWithoutUserInput> | UserHoursReportsCreateWithoutUserInput[] | UserHoursReportsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserHoursReportsCreateOrConnectWithoutUserInput | UserHoursReportsCreateOrConnectWithoutUserInput[]
    upsert?: UserHoursReportsUpsertWithWhereUniqueWithoutUserInput | UserHoursReportsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserHoursReportsCreateManyUserInputEnvelope
    set?: UserHoursReportsWhereUniqueInput | UserHoursReportsWhereUniqueInput[]
    disconnect?: UserHoursReportsWhereUniqueInput | UserHoursReportsWhereUniqueInput[]
    delete?: UserHoursReportsWhereUniqueInput | UserHoursReportsWhereUniqueInput[]
    connect?: UserHoursReportsWhereUniqueInput | UserHoursReportsWhereUniqueInput[]
    update?: UserHoursReportsUpdateWithWhereUniqueWithoutUserInput | UserHoursReportsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserHoursReportsUpdateManyWithWhereWithoutUserInput | UserHoursReportsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserHoursReportsScalarWhereInput | UserHoursReportsScalarWhereInput[]
  }

  export type UserParkingReportsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserParkingReportsCreateWithoutUserInput, UserParkingReportsUncheckedCreateWithoutUserInput> | UserParkingReportsCreateWithoutUserInput[] | UserParkingReportsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserParkingReportsCreateOrConnectWithoutUserInput | UserParkingReportsCreateOrConnectWithoutUserInput[]
    upsert?: UserParkingReportsUpsertWithWhereUniqueWithoutUserInput | UserParkingReportsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserParkingReportsCreateManyUserInputEnvelope
    set?: UserParkingReportsWhereUniqueInput | UserParkingReportsWhereUniqueInput[]
    disconnect?: UserParkingReportsWhereUniqueInput | UserParkingReportsWhereUniqueInput[]
    delete?: UserParkingReportsWhereUniqueInput | UserParkingReportsWhereUniqueInput[]
    connect?: UserParkingReportsWhereUniqueInput | UserParkingReportsWhereUniqueInput[]
    update?: UserParkingReportsUpdateWithWhereUniqueWithoutUserInput | UserParkingReportsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserParkingReportsUpdateManyWithWhereWithoutUserInput | UserParkingReportsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserParkingReportsScalarWhereInput | UserParkingReportsScalarWhereInput[]
  }

  export type InfractionUncheckedUpdateManyWithoutPayedByUserNestedInput = {
    create?: XOR<InfractionCreateWithoutPayedByUserInput, InfractionUncheckedCreateWithoutPayedByUserInput> | InfractionCreateWithoutPayedByUserInput[] | InfractionUncheckedCreateWithoutPayedByUserInput[]
    connectOrCreate?: InfractionCreateOrConnectWithoutPayedByUserInput | InfractionCreateOrConnectWithoutPayedByUserInput[]
    upsert?: InfractionUpsertWithWhereUniqueWithoutPayedByUserInput | InfractionUpsertWithWhereUniqueWithoutPayedByUserInput[]
    createMany?: InfractionCreateManyPayedByUserInputEnvelope
    set?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    disconnect?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    delete?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    connect?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    update?: InfractionUpdateWithWhereUniqueWithoutPayedByUserInput | InfractionUpdateWithWhereUniqueWithoutPayedByUserInput[]
    updateMany?: InfractionUpdateManyWithWhereWithoutPayedByUserInput | InfractionUpdateManyWithWhereWithoutPayedByUserInput[]
    deleteMany?: InfractionScalarWhereInput | InfractionScalarWhereInput[]
  }

  export type SellingHoursReportsUncheckedUpdateManyWithoutTargetUserNestedInput = {
    create?: XOR<SellingHoursReportsCreateWithoutTargetUserInput, SellingHoursReportsUncheckedCreateWithoutTargetUserInput> | SellingHoursReportsCreateWithoutTargetUserInput[] | SellingHoursReportsUncheckedCreateWithoutTargetUserInput[]
    connectOrCreate?: SellingHoursReportsCreateOrConnectWithoutTargetUserInput | SellingHoursReportsCreateOrConnectWithoutTargetUserInput[]
    upsert?: SellingHoursReportsUpsertWithWhereUniqueWithoutTargetUserInput | SellingHoursReportsUpsertWithWhereUniqueWithoutTargetUserInput[]
    createMany?: SellingHoursReportsCreateManyTargetUserInputEnvelope
    set?: SellingHoursReportsWhereUniqueInput | SellingHoursReportsWhereUniqueInput[]
    disconnect?: SellingHoursReportsWhereUniqueInput | SellingHoursReportsWhereUniqueInput[]
    delete?: SellingHoursReportsWhereUniqueInput | SellingHoursReportsWhereUniqueInput[]
    connect?: SellingHoursReportsWhereUniqueInput | SellingHoursReportsWhereUniqueInput[]
    update?: SellingHoursReportsUpdateWithWhereUniqueWithoutTargetUserInput | SellingHoursReportsUpdateWithWhereUniqueWithoutTargetUserInput[]
    updateMany?: SellingHoursReportsUpdateManyWithWhereWithoutTargetUserInput | SellingHoursReportsUpdateManyWithWhereWithoutTargetUserInput[]
    deleteMany?: SellingHoursReportsScalarWhereInput | SellingHoursReportsScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<BookingCreateWithoutCustomerInput, BookingUncheckedCreateWithoutCustomerInput> | BookingCreateWithoutCustomerInput[] | BookingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutCustomerInput | BookingCreateOrConnectWithoutCustomerInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutCustomerInput | BookingUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: BookingCreateManyCustomerInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutCustomerInput | BookingUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutCustomerInput | BookingUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutSoldByNestedInput = {
    create?: XOR<BookingCreateWithoutSoldByInput, BookingUncheckedCreateWithoutSoldByInput> | BookingCreateWithoutSoldByInput[] | BookingUncheckedCreateWithoutSoldByInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutSoldByInput | BookingCreateOrConnectWithoutSoldByInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutSoldByInput | BookingUpsertWithWhereUniqueWithoutSoldByInput[]
    createMany?: BookingCreateManySoldByInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutSoldByInput | BookingUpdateWithWhereUniqueWithoutSoldByInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutSoldByInput | BookingUpdateManyWithWhereWithoutSoldByInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type SeatHoldUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SeatHoldCreateWithoutUserInput, SeatHoldUncheckedCreateWithoutUserInput> | SeatHoldCreateWithoutUserInput[] | SeatHoldUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SeatHoldCreateOrConnectWithoutUserInput | SeatHoldCreateOrConnectWithoutUserInput[]
    upsert?: SeatHoldUpsertWithWhereUniqueWithoutUserInput | SeatHoldUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SeatHoldCreateManyUserInputEnvelope
    set?: SeatHoldWhereUniqueInput | SeatHoldWhereUniqueInput[]
    disconnect?: SeatHoldWhereUniqueInput | SeatHoldWhereUniqueInput[]
    delete?: SeatHoldWhereUniqueInput | SeatHoldWhereUniqueInput[]
    connect?: SeatHoldWhereUniqueInput | SeatHoldWhereUniqueInput[]
    update?: SeatHoldUpdateWithWhereUniqueWithoutUserInput | SeatHoldUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SeatHoldUpdateManyWithWhereWithoutUserInput | SeatHoldUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SeatHoldScalarWhereInput | SeatHoldScalarWhereInput[]
  }

  export type CinemaCreditUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CinemaCreditCreateWithoutUserInput, CinemaCreditUncheckedCreateWithoutUserInput> | CinemaCreditCreateWithoutUserInput[] | CinemaCreditUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CinemaCreditCreateOrConnectWithoutUserInput | CinemaCreditCreateOrConnectWithoutUserInput[]
    upsert?: CinemaCreditUpsertWithWhereUniqueWithoutUserInput | CinemaCreditUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CinemaCreditCreateManyUserInputEnvelope
    set?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
    disconnect?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
    delete?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
    connect?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
    update?: CinemaCreditUpdateWithWhereUniqueWithoutUserInput | CinemaCreditUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CinemaCreditUpdateManyWithWhereWithoutUserInput | CinemaCreditUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CinemaCreditScalarWhereInput | CinemaCreditScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSellPointInput = {
    create?: XOR<UserCreateWithoutSellPointInput, UserUncheckedCreateWithoutSellPointInput>
    connectOrCreate?: UserCreateOrConnectWithoutSellPointInput
    connect?: UserWhereUniqueInput
  }

  export type AssignHoursReportsCreateNestedManyWithoutSellPointInput = {
    create?: XOR<AssignHoursReportsCreateWithoutSellPointInput, AssignHoursReportsUncheckedCreateWithoutSellPointInput> | AssignHoursReportsCreateWithoutSellPointInput[] | AssignHoursReportsUncheckedCreateWithoutSellPointInput[]
    connectOrCreate?: AssignHoursReportsCreateOrConnectWithoutSellPointInput | AssignHoursReportsCreateOrConnectWithoutSellPointInput[]
    createMany?: AssignHoursReportsCreateManySellPointInputEnvelope
    connect?: AssignHoursReportsWhereUniqueInput | AssignHoursReportsWhereUniqueInput[]
  }

  export type AssignPatentHoursReportsCreateNestedManyWithoutSellPointInput = {
    create?: XOR<AssignPatentHoursReportsCreateWithoutSellPointInput, AssignPatentHoursReportsUncheckedCreateWithoutSellPointInput> | AssignPatentHoursReportsCreateWithoutSellPointInput[] | AssignPatentHoursReportsUncheckedCreateWithoutSellPointInput[]
    connectOrCreate?: AssignPatentHoursReportsCreateOrConnectWithoutSellPointInput | AssignPatentHoursReportsCreateOrConnectWithoutSellPointInput[]
    createMany?: AssignPatentHoursReportsCreateManySellPointInputEnvelope
    connect?: AssignPatentHoursReportsWhereUniqueInput | AssignPatentHoursReportsWhereUniqueInput[]
  }

  export type AssignHoursReportsUncheckedCreateNestedManyWithoutSellPointInput = {
    create?: XOR<AssignHoursReportsCreateWithoutSellPointInput, AssignHoursReportsUncheckedCreateWithoutSellPointInput> | AssignHoursReportsCreateWithoutSellPointInput[] | AssignHoursReportsUncheckedCreateWithoutSellPointInput[]
    connectOrCreate?: AssignHoursReportsCreateOrConnectWithoutSellPointInput | AssignHoursReportsCreateOrConnectWithoutSellPointInput[]
    createMany?: AssignHoursReportsCreateManySellPointInputEnvelope
    connect?: AssignHoursReportsWhereUniqueInput | AssignHoursReportsWhereUniqueInput[]
  }

  export type AssignPatentHoursReportsUncheckedCreateNestedManyWithoutSellPointInput = {
    create?: XOR<AssignPatentHoursReportsCreateWithoutSellPointInput, AssignPatentHoursReportsUncheckedCreateWithoutSellPointInput> | AssignPatentHoursReportsCreateWithoutSellPointInput[] | AssignPatentHoursReportsUncheckedCreateWithoutSellPointInput[]
    connectOrCreate?: AssignPatentHoursReportsCreateOrConnectWithoutSellPointInput | AssignPatentHoursReportsCreateOrConnectWithoutSellPointInput[]
    createMany?: AssignPatentHoursReportsCreateManySellPointInputEnvelope
    connect?: AssignPatentHoursReportsWhereUniqueInput | AssignPatentHoursReportsWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdateOneWithoutSellPointNestedInput = {
    create?: XOR<UserCreateWithoutSellPointInput, UserUncheckedCreateWithoutSellPointInput>
    connectOrCreate?: UserCreateOrConnectWithoutSellPointInput
    upsert?: UserUpsertWithoutSellPointInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSellPointInput, UserUpdateWithoutSellPointInput>, UserUncheckedUpdateWithoutSellPointInput>
  }

  export type AssignHoursReportsUpdateManyWithoutSellPointNestedInput = {
    create?: XOR<AssignHoursReportsCreateWithoutSellPointInput, AssignHoursReportsUncheckedCreateWithoutSellPointInput> | AssignHoursReportsCreateWithoutSellPointInput[] | AssignHoursReportsUncheckedCreateWithoutSellPointInput[]
    connectOrCreate?: AssignHoursReportsCreateOrConnectWithoutSellPointInput | AssignHoursReportsCreateOrConnectWithoutSellPointInput[]
    upsert?: AssignHoursReportsUpsertWithWhereUniqueWithoutSellPointInput | AssignHoursReportsUpsertWithWhereUniqueWithoutSellPointInput[]
    createMany?: AssignHoursReportsCreateManySellPointInputEnvelope
    set?: AssignHoursReportsWhereUniqueInput | AssignHoursReportsWhereUniqueInput[]
    disconnect?: AssignHoursReportsWhereUniqueInput | AssignHoursReportsWhereUniqueInput[]
    delete?: AssignHoursReportsWhereUniqueInput | AssignHoursReportsWhereUniqueInput[]
    connect?: AssignHoursReportsWhereUniqueInput | AssignHoursReportsWhereUniqueInput[]
    update?: AssignHoursReportsUpdateWithWhereUniqueWithoutSellPointInput | AssignHoursReportsUpdateWithWhereUniqueWithoutSellPointInput[]
    updateMany?: AssignHoursReportsUpdateManyWithWhereWithoutSellPointInput | AssignHoursReportsUpdateManyWithWhereWithoutSellPointInput[]
    deleteMany?: AssignHoursReportsScalarWhereInput | AssignHoursReportsScalarWhereInput[]
  }

  export type AssignPatentHoursReportsUpdateManyWithoutSellPointNestedInput = {
    create?: XOR<AssignPatentHoursReportsCreateWithoutSellPointInput, AssignPatentHoursReportsUncheckedCreateWithoutSellPointInput> | AssignPatentHoursReportsCreateWithoutSellPointInput[] | AssignPatentHoursReportsUncheckedCreateWithoutSellPointInput[]
    connectOrCreate?: AssignPatentHoursReportsCreateOrConnectWithoutSellPointInput | AssignPatentHoursReportsCreateOrConnectWithoutSellPointInput[]
    upsert?: AssignPatentHoursReportsUpsertWithWhereUniqueWithoutSellPointInput | AssignPatentHoursReportsUpsertWithWhereUniqueWithoutSellPointInput[]
    createMany?: AssignPatentHoursReportsCreateManySellPointInputEnvelope
    set?: AssignPatentHoursReportsWhereUniqueInput | AssignPatentHoursReportsWhereUniqueInput[]
    disconnect?: AssignPatentHoursReportsWhereUniqueInput | AssignPatentHoursReportsWhereUniqueInput[]
    delete?: AssignPatentHoursReportsWhereUniqueInput | AssignPatentHoursReportsWhereUniqueInput[]
    connect?: AssignPatentHoursReportsWhereUniqueInput | AssignPatentHoursReportsWhereUniqueInput[]
    update?: AssignPatentHoursReportsUpdateWithWhereUniqueWithoutSellPointInput | AssignPatentHoursReportsUpdateWithWhereUniqueWithoutSellPointInput[]
    updateMany?: AssignPatentHoursReportsUpdateManyWithWhereWithoutSellPointInput | AssignPatentHoursReportsUpdateManyWithWhereWithoutSellPointInput[]
    deleteMany?: AssignPatentHoursReportsScalarWhereInput | AssignPatentHoursReportsScalarWhereInput[]
  }

  export type AssignHoursReportsUncheckedUpdateManyWithoutSellPointNestedInput = {
    create?: XOR<AssignHoursReportsCreateWithoutSellPointInput, AssignHoursReportsUncheckedCreateWithoutSellPointInput> | AssignHoursReportsCreateWithoutSellPointInput[] | AssignHoursReportsUncheckedCreateWithoutSellPointInput[]
    connectOrCreate?: AssignHoursReportsCreateOrConnectWithoutSellPointInput | AssignHoursReportsCreateOrConnectWithoutSellPointInput[]
    upsert?: AssignHoursReportsUpsertWithWhereUniqueWithoutSellPointInput | AssignHoursReportsUpsertWithWhereUniqueWithoutSellPointInput[]
    createMany?: AssignHoursReportsCreateManySellPointInputEnvelope
    set?: AssignHoursReportsWhereUniqueInput | AssignHoursReportsWhereUniqueInput[]
    disconnect?: AssignHoursReportsWhereUniqueInput | AssignHoursReportsWhereUniqueInput[]
    delete?: AssignHoursReportsWhereUniqueInput | AssignHoursReportsWhereUniqueInput[]
    connect?: AssignHoursReportsWhereUniqueInput | AssignHoursReportsWhereUniqueInput[]
    update?: AssignHoursReportsUpdateWithWhereUniqueWithoutSellPointInput | AssignHoursReportsUpdateWithWhereUniqueWithoutSellPointInput[]
    updateMany?: AssignHoursReportsUpdateManyWithWhereWithoutSellPointInput | AssignHoursReportsUpdateManyWithWhereWithoutSellPointInput[]
    deleteMany?: AssignHoursReportsScalarWhereInput | AssignHoursReportsScalarWhereInput[]
  }

  export type AssignPatentHoursReportsUncheckedUpdateManyWithoutSellPointNestedInput = {
    create?: XOR<AssignPatentHoursReportsCreateWithoutSellPointInput, AssignPatentHoursReportsUncheckedCreateWithoutSellPointInput> | AssignPatentHoursReportsCreateWithoutSellPointInput[] | AssignPatentHoursReportsUncheckedCreateWithoutSellPointInput[]
    connectOrCreate?: AssignPatentHoursReportsCreateOrConnectWithoutSellPointInput | AssignPatentHoursReportsCreateOrConnectWithoutSellPointInput[]
    upsert?: AssignPatentHoursReportsUpsertWithWhereUniqueWithoutSellPointInput | AssignPatentHoursReportsUpsertWithWhereUniqueWithoutSellPointInput[]
    createMany?: AssignPatentHoursReportsCreateManySellPointInputEnvelope
    set?: AssignPatentHoursReportsWhereUniqueInput | AssignPatentHoursReportsWhereUniqueInput[]
    disconnect?: AssignPatentHoursReportsWhereUniqueInput | AssignPatentHoursReportsWhereUniqueInput[]
    delete?: AssignPatentHoursReportsWhereUniqueInput | AssignPatentHoursReportsWhereUniqueInput[]
    connect?: AssignPatentHoursReportsWhereUniqueInput | AssignPatentHoursReportsWhereUniqueInput[]
    update?: AssignPatentHoursReportsUpdateWithWhereUniqueWithoutSellPointInput | AssignPatentHoursReportsUpdateWithWhereUniqueWithoutSellPointInput[]
    updateMany?: AssignPatentHoursReportsUpdateManyWithWhereWithoutSellPointInput | AssignPatentHoursReportsUpdateManyWithWhereWithoutSellPointInput[]
    deleteMany?: AssignPatentHoursReportsScalarWhereInput | AssignPatentHoursReportsScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPatentsInput = {
    create?: XOR<UserCreateWithoutPatentsInput, UserUncheckedCreateWithoutPatentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPatentsInput
    connect?: UserWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneWithoutPatentsNestedInput = {
    create?: XOR<UserCreateWithoutPatentsInput, UserUncheckedCreateWithoutPatentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPatentsInput
    upsert?: UserUpsertWithoutPatentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPatentsInput, UserUpdateWithoutPatentsInput>, UserUncheckedUpdateWithoutPatentsInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserCreateNestedOneWithoutDeletedPatentInput = {
    create?: XOR<UserCreateWithoutDeletedPatentInput, UserUncheckedCreateWithoutDeletedPatentInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeletedPatentInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDeletedPatentNestedInput = {
    create?: XOR<UserCreateWithoutDeletedPatentInput, UserUncheckedCreateWithoutDeletedPatentInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeletedPatentInput
    upsert?: UserUpsertWithoutDeletedPatentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeletedPatentInput, UserUpdateWithoutDeletedPatentInput>, UserUncheckedUpdateWithoutDeletedPatentInput>
  }

  export type SellPointCreateNestedOneWithoutReportsInput = {
    create?: XOR<SellPointCreateWithoutReportsInput, SellPointUncheckedCreateWithoutReportsInput>
    connectOrCreate?: SellPointCreateOrConnectWithoutReportsInput
    connect?: SellPointWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SellPointUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<SellPointCreateWithoutReportsInput, SellPointUncheckedCreateWithoutReportsInput>
    connectOrCreate?: SellPointCreateOrConnectWithoutReportsInput
    upsert?: SellPointUpsertWithoutReportsInput
    connect?: SellPointWhereUniqueInput
    update?: XOR<XOR<SellPointUpdateToOneWithWhereWithoutReportsInput, SellPointUpdateWithoutReportsInput>, SellPointUncheckedUpdateWithoutReportsInput>
  }

  export type SellPointCreateNestedOneWithoutPatentReportsInput = {
    create?: XOR<SellPointCreateWithoutPatentReportsInput, SellPointUncheckedCreateWithoutPatentReportsInput>
    connectOrCreate?: SellPointCreateOrConnectWithoutPatentReportsInput
    connect?: SellPointWhereUniqueInput
  }

  export type SellPointUpdateOneWithoutPatentReportsNestedInput = {
    create?: XOR<SellPointCreateWithoutPatentReportsInput, SellPointUncheckedCreateWithoutPatentReportsInput>
    connectOrCreate?: SellPointCreateOrConnectWithoutPatentReportsInput
    upsert?: SellPointUpsertWithoutPatentReportsInput
    disconnect?: SellPointWhereInput | boolean
    delete?: SellPointWhereInput | boolean
    connect?: SellPointWhereUniqueInput
    update?: XOR<XOR<SellPointUpdateToOneWithWhereWithoutPatentReportsInput, SellPointUpdateWithoutPatentReportsInput>, SellPointUncheckedUpdateWithoutPatentReportsInput>
  }

  export type UserCreateNestedOneWithoutSellingHoursReportsInput = {
    create?: XOR<UserCreateWithoutSellingHoursReportsInput, UserUncheckedCreateWithoutSellingHoursReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSellingHoursReportsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedHoursSalesInput = {
    create?: XOR<UserCreateWithoutReceivedHoursSalesInput, UserUncheckedCreateWithoutReceivedHoursSalesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedHoursSalesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSellingHoursReportsNestedInput = {
    create?: XOR<UserCreateWithoutSellingHoursReportsInput, UserUncheckedCreateWithoutSellingHoursReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSellingHoursReportsInput
    upsert?: UserUpsertWithoutSellingHoursReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSellingHoursReportsInput, UserUpdateWithoutSellingHoursReportsInput>, UserUncheckedUpdateWithoutSellingHoursReportsInput>
  }

  export type UserUpdateOneWithoutReceivedHoursSalesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedHoursSalesInput, UserUncheckedCreateWithoutReceivedHoursSalesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedHoursSalesInput
    upsert?: UserUpsertWithoutReceivedHoursSalesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedHoursSalesInput, UserUpdateWithoutReceivedHoursSalesInput>, UserUncheckedUpdateWithoutReceivedHoursSalesInput>
  }

  export type UserCreateNestedOneWithoutUserReportsInput = {
    create?: XOR<UserCreateWithoutUserReportsInput, UserUncheckedCreateWithoutUserReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserReportsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserReportsNestedInput = {
    create?: XOR<UserCreateWithoutUserReportsInput, UserUncheckedCreateWithoutUserReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserReportsInput
    upsert?: UserUpsertWithoutUserReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserReportsInput, UserUpdateWithoutUserReportsInput>, UserUncheckedUpdateWithoutUserReportsInput>
  }

  export type UserCreateNestedOneWithoutUserParkingReportsInput = {
    create?: XOR<UserCreateWithoutUserParkingReportsInput, UserUncheckedCreateWithoutUserParkingReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserParkingReportsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserParkingReportsNestedInput = {
    create?: XOR<UserCreateWithoutUserParkingReportsInput, UserUncheckedCreateWithoutUserParkingReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserParkingReportsInput
    upsert?: UserUpsertWithoutUserParkingReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserParkingReportsInput, UserUpdateWithoutUserParkingReportsInput>, UserUncheckedUpdateWithoutUserParkingReportsInput>
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutParkingInput = {
    create?: XOR<UserCreateWithoutParkingInput, UserUncheckedCreateWithoutParkingInput>
    connectOrCreate?: UserCreateOrConnectWithoutParkingInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutParkingNestedInput = {
    create?: XOR<UserCreateWithoutParkingInput, UserUncheckedCreateWithoutParkingInput>
    connectOrCreate?: UserCreateOrConnectWithoutParkingInput
    upsert?: UserUpsertWithoutParkingInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutParkingInput, UserUpdateWithoutParkingInput>, UserUncheckedUpdateWithoutParkingInput>
  }

  export type InfractionImageCreateNestedManyWithoutInfractionInput = {
    create?: XOR<InfractionImageCreateWithoutInfractionInput, InfractionImageUncheckedCreateWithoutInfractionInput> | InfractionImageCreateWithoutInfractionInput[] | InfractionImageUncheckedCreateWithoutInfractionInput[]
    connectOrCreate?: InfractionImageCreateOrConnectWithoutInfractionInput | InfractionImageCreateOrConnectWithoutInfractionInput[]
    createMany?: InfractionImageCreateManyInfractionInputEnvelope
    connect?: InfractionImageWhereUniqueInput | InfractionImageWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutPaidInfractionsInput = {
    create?: XOR<UserCreateWithoutPaidInfractionsInput, UserUncheckedCreateWithoutPaidInfractionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaidInfractionsInput
    connect?: UserWhereUniqueInput
  }

  export type InfractionImageUncheckedCreateNestedManyWithoutInfractionInput = {
    create?: XOR<InfractionImageCreateWithoutInfractionInput, InfractionImageUncheckedCreateWithoutInfractionInput> | InfractionImageCreateWithoutInfractionInput[] | InfractionImageUncheckedCreateWithoutInfractionInput[]
    connectOrCreate?: InfractionImageCreateOrConnectWithoutInfractionInput | InfractionImageCreateOrConnectWithoutInfractionInput[]
    createMany?: InfractionImageCreateManyInfractionInputEnvelope
    connect?: InfractionImageWhereUniqueInput | InfractionImageWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type InfractionImageUpdateManyWithoutInfractionNestedInput = {
    create?: XOR<InfractionImageCreateWithoutInfractionInput, InfractionImageUncheckedCreateWithoutInfractionInput> | InfractionImageCreateWithoutInfractionInput[] | InfractionImageUncheckedCreateWithoutInfractionInput[]
    connectOrCreate?: InfractionImageCreateOrConnectWithoutInfractionInput | InfractionImageCreateOrConnectWithoutInfractionInput[]
    upsert?: InfractionImageUpsertWithWhereUniqueWithoutInfractionInput | InfractionImageUpsertWithWhereUniqueWithoutInfractionInput[]
    createMany?: InfractionImageCreateManyInfractionInputEnvelope
    set?: InfractionImageWhereUniqueInput | InfractionImageWhereUniqueInput[]
    disconnect?: InfractionImageWhereUniqueInput | InfractionImageWhereUniqueInput[]
    delete?: InfractionImageWhereUniqueInput | InfractionImageWhereUniqueInput[]
    connect?: InfractionImageWhereUniqueInput | InfractionImageWhereUniqueInput[]
    update?: InfractionImageUpdateWithWhereUniqueWithoutInfractionInput | InfractionImageUpdateWithWhereUniqueWithoutInfractionInput[]
    updateMany?: InfractionImageUpdateManyWithWhereWithoutInfractionInput | InfractionImageUpdateManyWithWhereWithoutInfractionInput[]
    deleteMany?: InfractionImageScalarWhereInput | InfractionImageScalarWhereInput[]
  }

  export type UserUpdateOneWithoutPaidInfractionsNestedInput = {
    create?: XOR<UserCreateWithoutPaidInfractionsInput, UserUncheckedCreateWithoutPaidInfractionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaidInfractionsInput
    upsert?: UserUpsertWithoutPaidInfractionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaidInfractionsInput, UserUpdateWithoutPaidInfractionsInput>, UserUncheckedUpdateWithoutPaidInfractionsInput>
  }

  export type InfractionImageUncheckedUpdateManyWithoutInfractionNestedInput = {
    create?: XOR<InfractionImageCreateWithoutInfractionInput, InfractionImageUncheckedCreateWithoutInfractionInput> | InfractionImageCreateWithoutInfractionInput[] | InfractionImageUncheckedCreateWithoutInfractionInput[]
    connectOrCreate?: InfractionImageCreateOrConnectWithoutInfractionInput | InfractionImageCreateOrConnectWithoutInfractionInput[]
    upsert?: InfractionImageUpsertWithWhereUniqueWithoutInfractionInput | InfractionImageUpsertWithWhereUniqueWithoutInfractionInput[]
    createMany?: InfractionImageCreateManyInfractionInputEnvelope
    set?: InfractionImageWhereUniqueInput | InfractionImageWhereUniqueInput[]
    disconnect?: InfractionImageWhereUniqueInput | InfractionImageWhereUniqueInput[]
    delete?: InfractionImageWhereUniqueInput | InfractionImageWhereUniqueInput[]
    connect?: InfractionImageWhereUniqueInput | InfractionImageWhereUniqueInput[]
    update?: InfractionImageUpdateWithWhereUniqueWithoutInfractionInput | InfractionImageUpdateWithWhereUniqueWithoutInfractionInput[]
    updateMany?: InfractionImageUpdateManyWithWhereWithoutInfractionInput | InfractionImageUpdateManyWithWhereWithoutInfractionInput[]
    deleteMany?: InfractionImageScalarWhereInput | InfractionImageScalarWhereInput[]
  }

  export type InfractionCreateNestedOneWithoutImagesInput = {
    create?: XOR<InfractionCreateWithoutImagesInput, InfractionUncheckedCreateWithoutImagesInput>
    connectOrCreate?: InfractionCreateOrConnectWithoutImagesInput
    connect?: InfractionWhereUniqueInput
  }

  export type InfractionUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<InfractionCreateWithoutImagesInput, InfractionUncheckedCreateWithoutImagesInput>
    connectOrCreate?: InfractionCreateOrConnectWithoutImagesInput
    upsert?: InfractionUpsertWithoutImagesInput
    connect?: InfractionWhereUniqueInput
    update?: XOR<XOR<InfractionUpdateToOneWithWhereWithoutImagesInput, InfractionUpdateWithoutImagesInput>, InfractionUncheckedUpdateWithoutImagesInput>
  }

  export type ShowingCreateNestedManyWithoutMovieInput = {
    create?: XOR<ShowingCreateWithoutMovieInput, ShowingUncheckedCreateWithoutMovieInput> | ShowingCreateWithoutMovieInput[] | ShowingUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: ShowingCreateOrConnectWithoutMovieInput | ShowingCreateOrConnectWithoutMovieInput[]
    createMany?: ShowingCreateManyMovieInputEnvelope
    connect?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
  }

  export type ShowingUncheckedCreateNestedManyWithoutMovieInput = {
    create?: XOR<ShowingCreateWithoutMovieInput, ShowingUncheckedCreateWithoutMovieInput> | ShowingCreateWithoutMovieInput[] | ShowingUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: ShowingCreateOrConnectWithoutMovieInput | ShowingCreateOrConnectWithoutMovieInput[]
    createMany?: ShowingCreateManyMovieInputEnvelope
    connect?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
  }

  export type EnumFormatFieldUpdateOperationsInput = {
    set?: $Enums.Format
  }

  export type ShowingUpdateManyWithoutMovieNestedInput = {
    create?: XOR<ShowingCreateWithoutMovieInput, ShowingUncheckedCreateWithoutMovieInput> | ShowingCreateWithoutMovieInput[] | ShowingUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: ShowingCreateOrConnectWithoutMovieInput | ShowingCreateOrConnectWithoutMovieInput[]
    upsert?: ShowingUpsertWithWhereUniqueWithoutMovieInput | ShowingUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: ShowingCreateManyMovieInputEnvelope
    set?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
    disconnect?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
    delete?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
    connect?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
    update?: ShowingUpdateWithWhereUniqueWithoutMovieInput | ShowingUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: ShowingUpdateManyWithWhereWithoutMovieInput | ShowingUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: ShowingScalarWhereInput | ShowingScalarWhereInput[]
  }

  export type ShowingUncheckedUpdateManyWithoutMovieNestedInput = {
    create?: XOR<ShowingCreateWithoutMovieInput, ShowingUncheckedCreateWithoutMovieInput> | ShowingCreateWithoutMovieInput[] | ShowingUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: ShowingCreateOrConnectWithoutMovieInput | ShowingCreateOrConnectWithoutMovieInput[]
    upsert?: ShowingUpsertWithWhereUniqueWithoutMovieInput | ShowingUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: ShowingCreateManyMovieInputEnvelope
    set?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
    disconnect?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
    delete?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
    connect?: ShowingWhereUniqueInput | ShowingWhereUniqueInput[]
    update?: ShowingUpdateWithWhereUniqueWithoutMovieInput | ShowingUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: ShowingUpdateManyWithWhereWithoutMovieInput | ShowingUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: ShowingScalarWhereInput | ShowingScalarWhereInput[]
  }

  export type MovieCreateNestedOneWithoutShowingsInput = {
    create?: XOR<MovieCreateWithoutShowingsInput, MovieUncheckedCreateWithoutShowingsInput>
    connectOrCreate?: MovieCreateOrConnectWithoutShowingsInput
    connect?: MovieWhereUniqueInput
  }

  export type SeatCreateNestedManyWithoutShowingInput = {
    create?: XOR<SeatCreateWithoutShowingInput, SeatUncheckedCreateWithoutShowingInput> | SeatCreateWithoutShowingInput[] | SeatUncheckedCreateWithoutShowingInput[]
    connectOrCreate?: SeatCreateOrConnectWithoutShowingInput | SeatCreateOrConnectWithoutShowingInput[]
    createMany?: SeatCreateManyShowingInputEnvelope
    connect?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
  }

  export type SeatHoldCreateNestedManyWithoutShowingInput = {
    create?: XOR<SeatHoldCreateWithoutShowingInput, SeatHoldUncheckedCreateWithoutShowingInput> | SeatHoldCreateWithoutShowingInput[] | SeatHoldUncheckedCreateWithoutShowingInput[]
    connectOrCreate?: SeatHoldCreateOrConnectWithoutShowingInput | SeatHoldCreateOrConnectWithoutShowingInput[]
    createMany?: SeatHoldCreateManyShowingInputEnvelope
    connect?: SeatHoldWhereUniqueInput | SeatHoldWhereUniqueInput[]
  }

  export type CinemaCreditCreateNestedManyWithoutShowingInput = {
    create?: XOR<CinemaCreditCreateWithoutShowingInput, CinemaCreditUncheckedCreateWithoutShowingInput> | CinemaCreditCreateWithoutShowingInput[] | CinemaCreditUncheckedCreateWithoutShowingInput[]
    connectOrCreate?: CinemaCreditCreateOrConnectWithoutShowingInput | CinemaCreditCreateOrConnectWithoutShowingInput[]
    createMany?: CinemaCreditCreateManyShowingInputEnvelope
    connect?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
  }

  export type SeatUncheckedCreateNestedManyWithoutShowingInput = {
    create?: XOR<SeatCreateWithoutShowingInput, SeatUncheckedCreateWithoutShowingInput> | SeatCreateWithoutShowingInput[] | SeatUncheckedCreateWithoutShowingInput[]
    connectOrCreate?: SeatCreateOrConnectWithoutShowingInput | SeatCreateOrConnectWithoutShowingInput[]
    createMany?: SeatCreateManyShowingInputEnvelope
    connect?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
  }

  export type SeatHoldUncheckedCreateNestedManyWithoutShowingInput = {
    create?: XOR<SeatHoldCreateWithoutShowingInput, SeatHoldUncheckedCreateWithoutShowingInput> | SeatHoldCreateWithoutShowingInput[] | SeatHoldUncheckedCreateWithoutShowingInput[]
    connectOrCreate?: SeatHoldCreateOrConnectWithoutShowingInput | SeatHoldCreateOrConnectWithoutShowingInput[]
    createMany?: SeatHoldCreateManyShowingInputEnvelope
    connect?: SeatHoldWhereUniqueInput | SeatHoldWhereUniqueInput[]
  }

  export type CinemaCreditUncheckedCreateNestedManyWithoutShowingInput = {
    create?: XOR<CinemaCreditCreateWithoutShowingInput, CinemaCreditUncheckedCreateWithoutShowingInput> | CinemaCreditCreateWithoutShowingInput[] | CinemaCreditUncheckedCreateWithoutShowingInput[]
    connectOrCreate?: CinemaCreditCreateOrConnectWithoutShowingInput | CinemaCreditCreateOrConnectWithoutShowingInput[]
    createMany?: CinemaCreditCreateManyShowingInputEnvelope
    connect?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
  }

  export type EnumShowingStatusFieldUpdateOperationsInput = {
    set?: $Enums.ShowingStatus
  }

  export type MovieUpdateOneRequiredWithoutShowingsNestedInput = {
    create?: XOR<MovieCreateWithoutShowingsInput, MovieUncheckedCreateWithoutShowingsInput>
    connectOrCreate?: MovieCreateOrConnectWithoutShowingsInput
    upsert?: MovieUpsertWithoutShowingsInput
    connect?: MovieWhereUniqueInput
    update?: XOR<XOR<MovieUpdateToOneWithWhereWithoutShowingsInput, MovieUpdateWithoutShowingsInput>, MovieUncheckedUpdateWithoutShowingsInput>
  }

  export type SeatUpdateManyWithoutShowingNestedInput = {
    create?: XOR<SeatCreateWithoutShowingInput, SeatUncheckedCreateWithoutShowingInput> | SeatCreateWithoutShowingInput[] | SeatUncheckedCreateWithoutShowingInput[]
    connectOrCreate?: SeatCreateOrConnectWithoutShowingInput | SeatCreateOrConnectWithoutShowingInput[]
    upsert?: SeatUpsertWithWhereUniqueWithoutShowingInput | SeatUpsertWithWhereUniqueWithoutShowingInput[]
    createMany?: SeatCreateManyShowingInputEnvelope
    set?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    disconnect?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    delete?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    connect?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    update?: SeatUpdateWithWhereUniqueWithoutShowingInput | SeatUpdateWithWhereUniqueWithoutShowingInput[]
    updateMany?: SeatUpdateManyWithWhereWithoutShowingInput | SeatUpdateManyWithWhereWithoutShowingInput[]
    deleteMany?: SeatScalarWhereInput | SeatScalarWhereInput[]
  }

  export type SeatHoldUpdateManyWithoutShowingNestedInput = {
    create?: XOR<SeatHoldCreateWithoutShowingInput, SeatHoldUncheckedCreateWithoutShowingInput> | SeatHoldCreateWithoutShowingInput[] | SeatHoldUncheckedCreateWithoutShowingInput[]
    connectOrCreate?: SeatHoldCreateOrConnectWithoutShowingInput | SeatHoldCreateOrConnectWithoutShowingInput[]
    upsert?: SeatHoldUpsertWithWhereUniqueWithoutShowingInput | SeatHoldUpsertWithWhereUniqueWithoutShowingInput[]
    createMany?: SeatHoldCreateManyShowingInputEnvelope
    set?: SeatHoldWhereUniqueInput | SeatHoldWhereUniqueInput[]
    disconnect?: SeatHoldWhereUniqueInput | SeatHoldWhereUniqueInput[]
    delete?: SeatHoldWhereUniqueInput | SeatHoldWhereUniqueInput[]
    connect?: SeatHoldWhereUniqueInput | SeatHoldWhereUniqueInput[]
    update?: SeatHoldUpdateWithWhereUniqueWithoutShowingInput | SeatHoldUpdateWithWhereUniqueWithoutShowingInput[]
    updateMany?: SeatHoldUpdateManyWithWhereWithoutShowingInput | SeatHoldUpdateManyWithWhereWithoutShowingInput[]
    deleteMany?: SeatHoldScalarWhereInput | SeatHoldScalarWhereInput[]
  }

  export type CinemaCreditUpdateManyWithoutShowingNestedInput = {
    create?: XOR<CinemaCreditCreateWithoutShowingInput, CinemaCreditUncheckedCreateWithoutShowingInput> | CinemaCreditCreateWithoutShowingInput[] | CinemaCreditUncheckedCreateWithoutShowingInput[]
    connectOrCreate?: CinemaCreditCreateOrConnectWithoutShowingInput | CinemaCreditCreateOrConnectWithoutShowingInput[]
    upsert?: CinemaCreditUpsertWithWhereUniqueWithoutShowingInput | CinemaCreditUpsertWithWhereUniqueWithoutShowingInput[]
    createMany?: CinemaCreditCreateManyShowingInputEnvelope
    set?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
    disconnect?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
    delete?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
    connect?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
    update?: CinemaCreditUpdateWithWhereUniqueWithoutShowingInput | CinemaCreditUpdateWithWhereUniqueWithoutShowingInput[]
    updateMany?: CinemaCreditUpdateManyWithWhereWithoutShowingInput | CinemaCreditUpdateManyWithWhereWithoutShowingInput[]
    deleteMany?: CinemaCreditScalarWhereInput | CinemaCreditScalarWhereInput[]
  }

  export type SeatUncheckedUpdateManyWithoutShowingNestedInput = {
    create?: XOR<SeatCreateWithoutShowingInput, SeatUncheckedCreateWithoutShowingInput> | SeatCreateWithoutShowingInput[] | SeatUncheckedCreateWithoutShowingInput[]
    connectOrCreate?: SeatCreateOrConnectWithoutShowingInput | SeatCreateOrConnectWithoutShowingInput[]
    upsert?: SeatUpsertWithWhereUniqueWithoutShowingInput | SeatUpsertWithWhereUniqueWithoutShowingInput[]
    createMany?: SeatCreateManyShowingInputEnvelope
    set?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    disconnect?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    delete?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    connect?: SeatWhereUniqueInput | SeatWhereUniqueInput[]
    update?: SeatUpdateWithWhereUniqueWithoutShowingInput | SeatUpdateWithWhereUniqueWithoutShowingInput[]
    updateMany?: SeatUpdateManyWithWhereWithoutShowingInput | SeatUpdateManyWithWhereWithoutShowingInput[]
    deleteMany?: SeatScalarWhereInput | SeatScalarWhereInput[]
  }

  export type SeatHoldUncheckedUpdateManyWithoutShowingNestedInput = {
    create?: XOR<SeatHoldCreateWithoutShowingInput, SeatHoldUncheckedCreateWithoutShowingInput> | SeatHoldCreateWithoutShowingInput[] | SeatHoldUncheckedCreateWithoutShowingInput[]
    connectOrCreate?: SeatHoldCreateOrConnectWithoutShowingInput | SeatHoldCreateOrConnectWithoutShowingInput[]
    upsert?: SeatHoldUpsertWithWhereUniqueWithoutShowingInput | SeatHoldUpsertWithWhereUniqueWithoutShowingInput[]
    createMany?: SeatHoldCreateManyShowingInputEnvelope
    set?: SeatHoldWhereUniqueInput | SeatHoldWhereUniqueInput[]
    disconnect?: SeatHoldWhereUniqueInput | SeatHoldWhereUniqueInput[]
    delete?: SeatHoldWhereUniqueInput | SeatHoldWhereUniqueInput[]
    connect?: SeatHoldWhereUniqueInput | SeatHoldWhereUniqueInput[]
    update?: SeatHoldUpdateWithWhereUniqueWithoutShowingInput | SeatHoldUpdateWithWhereUniqueWithoutShowingInput[]
    updateMany?: SeatHoldUpdateManyWithWhereWithoutShowingInput | SeatHoldUpdateManyWithWhereWithoutShowingInput[]
    deleteMany?: SeatHoldScalarWhereInput | SeatHoldScalarWhereInput[]
  }

  export type CinemaCreditUncheckedUpdateManyWithoutShowingNestedInput = {
    create?: XOR<CinemaCreditCreateWithoutShowingInput, CinemaCreditUncheckedCreateWithoutShowingInput> | CinemaCreditCreateWithoutShowingInput[] | CinemaCreditUncheckedCreateWithoutShowingInput[]
    connectOrCreate?: CinemaCreditCreateOrConnectWithoutShowingInput | CinemaCreditCreateOrConnectWithoutShowingInput[]
    upsert?: CinemaCreditUpsertWithWhereUniqueWithoutShowingInput | CinemaCreditUpsertWithWhereUniqueWithoutShowingInput[]
    createMany?: CinemaCreditCreateManyShowingInputEnvelope
    set?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
    disconnect?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
    delete?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
    connect?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
    update?: CinemaCreditUpdateWithWhereUniqueWithoutShowingInput | CinemaCreditUpdateWithWhereUniqueWithoutShowingInput[]
    updateMany?: CinemaCreditUpdateManyWithWhereWithoutShowingInput | CinemaCreditUpdateManyWithWhereWithoutShowingInput[]
    deleteMany?: CinemaCreditScalarWhereInput | CinemaCreditScalarWhereInput[]
  }

  export type ShowingCreateNestedOneWithoutSeatsInput = {
    create?: XOR<ShowingCreateWithoutSeatsInput, ShowingUncheckedCreateWithoutSeatsInput>
    connectOrCreate?: ShowingCreateOrConnectWithoutSeatsInput
    connect?: ShowingWhereUniqueInput
  }

  export type TicketCreateNestedManyWithoutSeatInput = {
    create?: XOR<TicketCreateWithoutSeatInput, TicketUncheckedCreateWithoutSeatInput> | TicketCreateWithoutSeatInput[] | TicketUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutSeatInput | TicketCreateOrConnectWithoutSeatInput[]
    createMany?: TicketCreateManySeatInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type SeatHoldCreateNestedOneWithoutSeatInput = {
    create?: XOR<SeatHoldCreateWithoutSeatInput, SeatHoldUncheckedCreateWithoutSeatInput>
    connectOrCreate?: SeatHoldCreateOrConnectWithoutSeatInput
    connect?: SeatHoldWhereUniqueInput
  }

  export type TicketUncheckedCreateNestedManyWithoutSeatInput = {
    create?: XOR<TicketCreateWithoutSeatInput, TicketUncheckedCreateWithoutSeatInput> | TicketCreateWithoutSeatInput[] | TicketUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutSeatInput | TicketCreateOrConnectWithoutSeatInput[]
    createMany?: TicketCreateManySeatInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type SeatHoldUncheckedCreateNestedOneWithoutSeatInput = {
    create?: XOR<SeatHoldCreateWithoutSeatInput, SeatHoldUncheckedCreateWithoutSeatInput>
    connectOrCreate?: SeatHoldCreateOrConnectWithoutSeatInput
    connect?: SeatHoldWhereUniqueInput
  }

  export type EnumSeatStatusFieldUpdateOperationsInput = {
    set?: $Enums.SeatStatus
  }

  export type ShowingUpdateOneRequiredWithoutSeatsNestedInput = {
    create?: XOR<ShowingCreateWithoutSeatsInput, ShowingUncheckedCreateWithoutSeatsInput>
    connectOrCreate?: ShowingCreateOrConnectWithoutSeatsInput
    upsert?: ShowingUpsertWithoutSeatsInput
    connect?: ShowingWhereUniqueInput
    update?: XOR<XOR<ShowingUpdateToOneWithWhereWithoutSeatsInput, ShowingUpdateWithoutSeatsInput>, ShowingUncheckedUpdateWithoutSeatsInput>
  }

  export type TicketUpdateManyWithoutSeatNestedInput = {
    create?: XOR<TicketCreateWithoutSeatInput, TicketUncheckedCreateWithoutSeatInput> | TicketCreateWithoutSeatInput[] | TicketUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutSeatInput | TicketCreateOrConnectWithoutSeatInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutSeatInput | TicketUpsertWithWhereUniqueWithoutSeatInput[]
    createMany?: TicketCreateManySeatInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutSeatInput | TicketUpdateWithWhereUniqueWithoutSeatInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutSeatInput | TicketUpdateManyWithWhereWithoutSeatInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type SeatHoldUpdateOneWithoutSeatNestedInput = {
    create?: XOR<SeatHoldCreateWithoutSeatInput, SeatHoldUncheckedCreateWithoutSeatInput>
    connectOrCreate?: SeatHoldCreateOrConnectWithoutSeatInput
    upsert?: SeatHoldUpsertWithoutSeatInput
    disconnect?: SeatHoldWhereInput | boolean
    delete?: SeatHoldWhereInput | boolean
    connect?: SeatHoldWhereUniqueInput
    update?: XOR<XOR<SeatHoldUpdateToOneWithWhereWithoutSeatInput, SeatHoldUpdateWithoutSeatInput>, SeatHoldUncheckedUpdateWithoutSeatInput>
  }

  export type TicketUncheckedUpdateManyWithoutSeatNestedInput = {
    create?: XOR<TicketCreateWithoutSeatInput, TicketUncheckedCreateWithoutSeatInput> | TicketCreateWithoutSeatInput[] | TicketUncheckedCreateWithoutSeatInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutSeatInput | TicketCreateOrConnectWithoutSeatInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutSeatInput | TicketUpsertWithWhereUniqueWithoutSeatInput[]
    createMany?: TicketCreateManySeatInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutSeatInput | TicketUpdateWithWhereUniqueWithoutSeatInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutSeatInput | TicketUpdateManyWithWhereWithoutSeatInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type SeatHoldUncheckedUpdateOneWithoutSeatNestedInput = {
    create?: XOR<SeatHoldCreateWithoutSeatInput, SeatHoldUncheckedCreateWithoutSeatInput>
    connectOrCreate?: SeatHoldCreateOrConnectWithoutSeatInput
    upsert?: SeatHoldUpsertWithoutSeatInput
    disconnect?: SeatHoldWhereInput | boolean
    delete?: SeatHoldWhereInput | boolean
    connect?: SeatHoldWhereUniqueInput
    update?: XOR<XOR<SeatHoldUpdateToOneWithWhereWithoutSeatInput, SeatHoldUpdateWithoutSeatInput>, SeatHoldUncheckedUpdateWithoutSeatInput>
  }

  export type SeatCreateNestedOneWithoutHoldInput = {
    create?: XOR<SeatCreateWithoutHoldInput, SeatUncheckedCreateWithoutHoldInput>
    connectOrCreate?: SeatCreateOrConnectWithoutHoldInput
    connect?: SeatWhereUniqueInput
  }

  export type ShowingCreateNestedOneWithoutSeatHoldsInput = {
    create?: XOR<ShowingCreateWithoutSeatHoldsInput, ShowingUncheckedCreateWithoutSeatHoldsInput>
    connectOrCreate?: ShowingCreateOrConnectWithoutSeatHoldsInput
    connect?: ShowingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSeatHoldsInput = {
    create?: XOR<UserCreateWithoutSeatHoldsInput, UserUncheckedCreateWithoutSeatHoldsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSeatHoldsInput
    connect?: UserWhereUniqueInput
  }

  export type SeatUpdateOneRequiredWithoutHoldNestedInput = {
    create?: XOR<SeatCreateWithoutHoldInput, SeatUncheckedCreateWithoutHoldInput>
    connectOrCreate?: SeatCreateOrConnectWithoutHoldInput
    upsert?: SeatUpsertWithoutHoldInput
    connect?: SeatWhereUniqueInput
    update?: XOR<XOR<SeatUpdateToOneWithWhereWithoutHoldInput, SeatUpdateWithoutHoldInput>, SeatUncheckedUpdateWithoutHoldInput>
  }

  export type ShowingUpdateOneRequiredWithoutSeatHoldsNestedInput = {
    create?: XOR<ShowingCreateWithoutSeatHoldsInput, ShowingUncheckedCreateWithoutSeatHoldsInput>
    connectOrCreate?: ShowingCreateOrConnectWithoutSeatHoldsInput
    upsert?: ShowingUpsertWithoutSeatHoldsInput
    connect?: ShowingWhereUniqueInput
    update?: XOR<XOR<ShowingUpdateToOneWithWhereWithoutSeatHoldsInput, ShowingUpdateWithoutSeatHoldsInput>, ShowingUncheckedUpdateWithoutSeatHoldsInput>
  }

  export type UserUpdateOneRequiredWithoutSeatHoldsNestedInput = {
    create?: XOR<UserCreateWithoutSeatHoldsInput, UserUncheckedCreateWithoutSeatHoldsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSeatHoldsInput
    upsert?: UserUpsertWithoutSeatHoldsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSeatHoldsInput, UserUpdateWithoutSeatHoldsInput>, UserUncheckedUpdateWithoutSeatHoldsInput>
  }

  export type UserCreateNestedOneWithoutBookingsInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSoldBookingsInput = {
    create?: XOR<UserCreateWithoutSoldBookingsInput, UserUncheckedCreateWithoutSoldBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSoldBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type TicketCreateNestedManyWithoutBookingInput = {
    create?: XOR<TicketCreateWithoutBookingInput, TicketUncheckedCreateWithoutBookingInput> | TicketCreateWithoutBookingInput[] | TicketUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutBookingInput | TicketCreateOrConnectWithoutBookingInput[]
    createMany?: TicketCreateManyBookingInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type CinemaCreditCreateNestedManyWithoutBookingInput = {
    create?: XOR<CinemaCreditCreateWithoutBookingInput, CinemaCreditUncheckedCreateWithoutBookingInput> | CinemaCreditCreateWithoutBookingInput[] | CinemaCreditUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: CinemaCreditCreateOrConnectWithoutBookingInput | CinemaCreditCreateOrConnectWithoutBookingInput[]
    createMany?: CinemaCreditCreateManyBookingInputEnvelope
    connect?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<TicketCreateWithoutBookingInput, TicketUncheckedCreateWithoutBookingInput> | TicketCreateWithoutBookingInput[] | TicketUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutBookingInput | TicketCreateOrConnectWithoutBookingInput[]
    createMany?: TicketCreateManyBookingInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type CinemaCreditUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<CinemaCreditCreateWithoutBookingInput, CinemaCreditUncheckedCreateWithoutBookingInput> | CinemaCreditCreateWithoutBookingInput[] | CinemaCreditUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: CinemaCreditCreateOrConnectWithoutBookingInput | CinemaCreditCreateOrConnectWithoutBookingInput[]
    createMany?: CinemaCreditCreateManyBookingInputEnvelope
    connect?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type EnumPurchaseChannelFieldUpdateOperationsInput = {
    set?: $Enums.PurchaseChannel
  }

  export type UserUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    upsert?: UserUpsertWithoutBookingsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsInput, UserUpdateWithoutBookingsInput>, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateOneWithoutSoldBookingsNestedInput = {
    create?: XOR<UserCreateWithoutSoldBookingsInput, UserUncheckedCreateWithoutSoldBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSoldBookingsInput
    upsert?: UserUpsertWithoutSoldBookingsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSoldBookingsInput, UserUpdateWithoutSoldBookingsInput>, UserUncheckedUpdateWithoutSoldBookingsInput>
  }

  export type TicketUpdateManyWithoutBookingNestedInput = {
    create?: XOR<TicketCreateWithoutBookingInput, TicketUncheckedCreateWithoutBookingInput> | TicketCreateWithoutBookingInput[] | TicketUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutBookingInput | TicketCreateOrConnectWithoutBookingInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutBookingInput | TicketUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: TicketCreateManyBookingInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutBookingInput | TicketUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutBookingInput | TicketUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type CinemaCreditUpdateManyWithoutBookingNestedInput = {
    create?: XOR<CinemaCreditCreateWithoutBookingInput, CinemaCreditUncheckedCreateWithoutBookingInput> | CinemaCreditCreateWithoutBookingInput[] | CinemaCreditUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: CinemaCreditCreateOrConnectWithoutBookingInput | CinemaCreditCreateOrConnectWithoutBookingInput[]
    upsert?: CinemaCreditUpsertWithWhereUniqueWithoutBookingInput | CinemaCreditUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: CinemaCreditCreateManyBookingInputEnvelope
    set?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
    disconnect?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
    delete?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
    connect?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
    update?: CinemaCreditUpdateWithWhereUniqueWithoutBookingInput | CinemaCreditUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: CinemaCreditUpdateManyWithWhereWithoutBookingInput | CinemaCreditUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: CinemaCreditScalarWhereInput | CinemaCreditScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<TicketCreateWithoutBookingInput, TicketUncheckedCreateWithoutBookingInput> | TicketCreateWithoutBookingInput[] | TicketUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutBookingInput | TicketCreateOrConnectWithoutBookingInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutBookingInput | TicketUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: TicketCreateManyBookingInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutBookingInput | TicketUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutBookingInput | TicketUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type CinemaCreditUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<CinemaCreditCreateWithoutBookingInput, CinemaCreditUncheckedCreateWithoutBookingInput> | CinemaCreditCreateWithoutBookingInput[] | CinemaCreditUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: CinemaCreditCreateOrConnectWithoutBookingInput | CinemaCreditCreateOrConnectWithoutBookingInput[]
    upsert?: CinemaCreditUpsertWithWhereUniqueWithoutBookingInput | CinemaCreditUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: CinemaCreditCreateManyBookingInputEnvelope
    set?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
    disconnect?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
    delete?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
    connect?: CinemaCreditWhereUniqueInput | CinemaCreditWhereUniqueInput[]
    update?: CinemaCreditUpdateWithWhereUniqueWithoutBookingInput | CinemaCreditUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: CinemaCreditUpdateManyWithWhereWithoutBookingInput | CinemaCreditUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: CinemaCreditScalarWhereInput | CinemaCreditScalarWhereInput[]
  }

  export type BookingCreateNestedOneWithoutTicketsInput = {
    create?: XOR<BookingCreateWithoutTicketsInput, BookingUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutTicketsInput
    connect?: BookingWhereUniqueInput
  }

  export type SeatCreateNestedOneWithoutTicketsInput = {
    create?: XOR<SeatCreateWithoutTicketsInput, SeatUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: SeatCreateOrConnectWithoutTicketsInput
    connect?: SeatWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<BookingCreateWithoutTicketsInput, BookingUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutTicketsInput
    upsert?: BookingUpsertWithoutTicketsInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutTicketsInput, BookingUpdateWithoutTicketsInput>, BookingUncheckedUpdateWithoutTicketsInput>
  }

  export type SeatUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<SeatCreateWithoutTicketsInput, SeatUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: SeatCreateOrConnectWithoutTicketsInput
    upsert?: SeatUpsertWithoutTicketsInput
    connect?: SeatWhereUniqueInput
    update?: XOR<XOR<SeatUpdateToOneWithWhereWithoutTicketsInput, SeatUpdateWithoutTicketsInput>, SeatUncheckedUpdateWithoutTicketsInput>
  }

  export type UserCreateNestedOneWithoutCinemaCreditsInput = {
    create?: XOR<UserCreateWithoutCinemaCreditsInput, UserUncheckedCreateWithoutCinemaCreditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCinemaCreditsInput
    connect?: UserWhereUniqueInput
  }

  export type BookingCreateNestedOneWithoutCreditsInput = {
    create?: XOR<BookingCreateWithoutCreditsInput, BookingUncheckedCreateWithoutCreditsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutCreditsInput
    connect?: BookingWhereUniqueInput
  }

  export type ShowingCreateNestedOneWithoutCreditsInput = {
    create?: XOR<ShowingCreateWithoutCreditsInput, ShowingUncheckedCreateWithoutCreditsInput>
    connectOrCreate?: ShowingCreateOrConnectWithoutCreditsInput
    connect?: ShowingWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCinemaCreditsNestedInput = {
    create?: XOR<UserCreateWithoutCinemaCreditsInput, UserUncheckedCreateWithoutCinemaCreditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCinemaCreditsInput
    upsert?: UserUpsertWithoutCinemaCreditsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCinemaCreditsInput, UserUpdateWithoutCinemaCreditsInput>, UserUncheckedUpdateWithoutCinemaCreditsInput>
  }

  export type BookingUpdateOneWithoutCreditsNestedInput = {
    create?: XOR<BookingCreateWithoutCreditsInput, BookingUncheckedCreateWithoutCreditsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutCreditsInput
    upsert?: BookingUpsertWithoutCreditsInput
    disconnect?: BookingWhereInput | boolean
    delete?: BookingWhereInput | boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutCreditsInput, BookingUpdateWithoutCreditsInput>, BookingUncheckedUpdateWithoutCreditsInput>
  }

  export type ShowingUpdateOneWithoutCreditsNestedInput = {
    create?: XOR<ShowingCreateWithoutCreditsInput, ShowingUncheckedCreateWithoutCreditsInput>
    connectOrCreate?: ShowingCreateOrConnectWithoutCreditsInput
    upsert?: ShowingUpsertWithoutCreditsInput
    disconnect?: ShowingWhereInput | boolean
    delete?: ShowingWhereInput | boolean
    connect?: ShowingWhereUniqueInput
    update?: XOR<XOR<ShowingUpdateToOneWithWhereWithoutCreditsInput, ShowingUpdateWithoutCreditsInput>, ShowingUncheckedUpdateWithoutCreditsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumFormatFilter<$PrismaModel = never> = {
    equals?: $Enums.Format | EnumFormatFieldRefInput<$PrismaModel>
    in?: $Enums.Format[] | ListEnumFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.Format[] | ListEnumFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumFormatFilter<$PrismaModel> | $Enums.Format
  }

  export type NestedEnumFormatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Format | EnumFormatFieldRefInput<$PrismaModel>
    in?: $Enums.Format[] | ListEnumFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.Format[] | ListEnumFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumFormatWithAggregatesFilter<$PrismaModel> | $Enums.Format
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFormatFilter<$PrismaModel>
    _max?: NestedEnumFormatFilter<$PrismaModel>
  }

  export type NestedEnumShowingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ShowingStatus | EnumShowingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShowingStatus[] | ListEnumShowingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShowingStatus[] | ListEnumShowingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShowingStatusFilter<$PrismaModel> | $Enums.ShowingStatus
  }

  export type NestedEnumShowingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShowingStatus | EnumShowingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShowingStatus[] | ListEnumShowingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShowingStatus[] | ListEnumShowingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShowingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ShowingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShowingStatusFilter<$PrismaModel>
    _max?: NestedEnumShowingStatusFilter<$PrismaModel>
  }

  export type NestedEnumSeatStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SeatStatus | EnumSeatStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SeatStatus[] | ListEnumSeatStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SeatStatus[] | ListEnumSeatStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSeatStatusFilter<$PrismaModel> | $Enums.SeatStatus
  }

  export type NestedEnumSeatStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SeatStatus | EnumSeatStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SeatStatus[] | ListEnumSeatStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SeatStatus[] | ListEnumSeatStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSeatStatusWithAggregatesFilter<$PrismaModel> | $Enums.SeatStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSeatStatusFilter<$PrismaModel>
    _max?: NestedEnumSeatStatusFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedEnumPurchaseChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseChannel | EnumPurchaseChannelFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseChannel[] | ListEnumPurchaseChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseChannel[] | ListEnumPurchaseChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseChannelFilter<$PrismaModel> | $Enums.PurchaseChannel
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedEnumPurchaseChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseChannel | EnumPurchaseChannelFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseChannel[] | ListEnumPurchaseChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseChannel[] | ListEnumPurchaseChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseChannelWithAggregatesFilter<$PrismaModel> | $Enums.PurchaseChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPurchaseChannelFilter<$PrismaModel>
    _max?: NestedEnumPurchaseChannelFilter<$PrismaModel>
  }

  export type PatentCreateWithoutUserInput = {
    patentId: string
    createdAt?: Date | string
    hasSingleHours?: boolean
    singleHours?: number
    dni?: number | null
    isAllowed?: boolean
    canShow?: boolean
    isAllowedIn?: string | null
    houseType?: string | null
  }

  export type PatentUncheckedCreateWithoutUserInput = {
    id?: number
    patentId: string
    createdAt?: Date | string
    hasSingleHours?: boolean
    singleHours?: number
    dni?: number | null
    isAllowed?: boolean
    canShow?: boolean
    isAllowedIn?: string | null
    houseType?: string | null
  }

  export type PatentCreateOrConnectWithoutUserInput = {
    where: PatentWhereUniqueInput
    create: XOR<PatentCreateWithoutUserInput, PatentUncheckedCreateWithoutUserInput>
  }

  export type PatentCreateManyUserInputEnvelope = {
    data: PatentCreateManyUserInput | PatentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DeletedPatentsCreateWithoutUserInput = {
    patentId: string
    deletedAt?: Date | string | null
  }

  export type DeletedPatentsUncheckedCreateWithoutUserInput = {
    id?: number
    patentId: string
    deletedAt?: Date | string | null
  }

  export type DeletedPatentsCreateOrConnectWithoutUserInput = {
    where: DeletedPatentsWhereUniqueInput
    create: XOR<DeletedPatentsCreateWithoutUserInput, DeletedPatentsUncheckedCreateWithoutUserInput>
  }

  export type DeletedPatentsCreateManyUserInputEnvelope = {
    data: DeletedPatentsCreateManyUserInput | DeletedPatentsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SellPointCreateWithoutUserInput = {
    address: string
    street?: string | null
    streetNumber?: number | null
    availableHours?: number
    usedHours?: number
    pointName: string
    dni?: number | null
    profitPercentage: number
    reports?: AssignHoursReportsCreateNestedManyWithoutSellPointInput
    patentReports?: AssignPatentHoursReportsCreateNestedManyWithoutSellPointInput
  }

  export type SellPointUncheckedCreateWithoutUserInput = {
    id?: number
    address: string
    street?: string | null
    streetNumber?: number | null
    availableHours?: number
    usedHours?: number
    pointName: string
    dni?: number | null
    profitPercentage: number
    reports?: AssignHoursReportsUncheckedCreateNestedManyWithoutSellPointInput
    patentReports?: AssignPatentHoursReportsUncheckedCreateNestedManyWithoutSellPointInput
  }

  export type SellPointCreateOrConnectWithoutUserInput = {
    where: SellPointWhereUniqueInput
    create: XOR<SellPointCreateWithoutUserInput, SellPointUncheckedCreateWithoutUserInput>
  }

  export type SellPointCreateManyUserInputEnvelope = {
    data: SellPointCreateManyUserInput | SellPointCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SellingHoursReportsCreateWithoutUserInput = {
    id?: string
    hoursAdded: number
    addedAt: Date | string
    hourPrice: number
    soldBy?: number | null
    targetUser?: UserCreateNestedOneWithoutReceivedHoursSalesInput
  }

  export type SellingHoursReportsUncheckedCreateWithoutUserInput = {
    id?: string
    hoursAdded: number
    addedAt: Date | string
    hourPrice: number
    soldBy?: number | null
    targetUserId?: number | null
  }

  export type SellingHoursReportsCreateOrConnectWithoutUserInput = {
    where: SellingHoursReportsWhereUniqueInput
    create: XOR<SellingHoursReportsCreateWithoutUserInput, SellingHoursReportsUncheckedCreateWithoutUserInput>
  }

  export type SellingHoursReportsCreateManyUserInputEnvelope = {
    data: SellingHoursReportsCreateManyUserInput | SellingHoursReportsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ParkingCreateWithoutUserInput = {
    id?: string
    hours: number
    startedAt?: Date | string
    finishedAt?: Date | string | null
    patentId: string
    isMonthly?: boolean
  }

  export type ParkingUncheckedCreateWithoutUserInput = {
    id?: string
    hours: number
    startedAt?: Date | string
    finishedAt?: Date | string | null
    patentId: string
    isMonthly?: boolean
  }

  export type ParkingCreateOrConnectWithoutUserInput = {
    where: ParkingWhereUniqueInput
    create: XOR<ParkingCreateWithoutUserInput, ParkingUncheckedCreateWithoutUserInput>
  }

  export type ParkingCreateManyUserInputEnvelope = {
    data: ParkingCreateManyUserInput | ParkingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserHoursReportsCreateWithoutUserInput = {
    id?: string
    hoursBought: number
    boughtAt: Date | string
    hourPrice: number
    soldBy: number
  }

  export type UserHoursReportsUncheckedCreateWithoutUserInput = {
    id?: string
    hoursBought: number
    boughtAt: Date | string
    hourPrice: number
    soldBy: number
  }

  export type UserHoursReportsCreateOrConnectWithoutUserInput = {
    where: UserHoursReportsWhereUniqueInput
    create: XOR<UserHoursReportsCreateWithoutUserInput, UserHoursReportsUncheckedCreateWithoutUserInput>
  }

  export type UserHoursReportsCreateManyUserInputEnvelope = {
    data: UserHoursReportsCreateManyUserInput | UserHoursReportsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserParkingReportsCreateWithoutUserInput = {
    id?: string
    startedAt: Date | string
    finishedAt: Date | string
    patentId: string
    totalHours: number
    hourPrice: number
  }

  export type UserParkingReportsUncheckedCreateWithoutUserInput = {
    id?: string
    startedAt: Date | string
    finishedAt: Date | string
    patentId: string
    totalHours: number
    hourPrice: number
  }

  export type UserParkingReportsCreateOrConnectWithoutUserInput = {
    where: UserParkingReportsWhereUniqueInput
    create: XOR<UserParkingReportsCreateWithoutUserInput, UserParkingReportsUncheckedCreateWithoutUserInput>
  }

  export type UserParkingReportsCreateManyUserInputEnvelope = {
    data: UserParkingReportsCreateManyUserInput | UserParkingReportsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InfractionCreateWithoutPayedByUserInput = {
    id?: string
    numberId?: number
    createdAt: Date | string
    cancelled?: boolean
    cancelledAt?: Date | string | null
    cancelledReason?: string | null
    patentId: string
    street?: string | null
    payed: boolean
    payedAt?: Date | string | null
    isEnableToPay?: boolean | null
    paymentMethod?: string | null
    images?: InfractionImageCreateNestedManyWithoutInfractionInput
  }

  export type InfractionUncheckedCreateWithoutPayedByUserInput = {
    id?: string
    numberId?: number
    createdAt: Date | string
    cancelled?: boolean
    cancelledAt?: Date | string | null
    cancelledReason?: string | null
    patentId: string
    street?: string | null
    payed: boolean
    payedAt?: Date | string | null
    isEnableToPay?: boolean | null
    paymentMethod?: string | null
    images?: InfractionImageUncheckedCreateNestedManyWithoutInfractionInput
  }

  export type InfractionCreateOrConnectWithoutPayedByUserInput = {
    where: InfractionWhereUniqueInput
    create: XOR<InfractionCreateWithoutPayedByUserInput, InfractionUncheckedCreateWithoutPayedByUserInput>
  }

  export type InfractionCreateManyPayedByUserInputEnvelope = {
    data: InfractionCreateManyPayedByUserInput | InfractionCreateManyPayedByUserInput[]
    skipDuplicates?: boolean
  }

  export type SellingHoursReportsCreateWithoutTargetUserInput = {
    id?: string
    hoursAdded: number
    addedAt: Date | string
    hourPrice: number
    soldBy?: number | null
    user: UserCreateNestedOneWithoutSellingHoursReportsInput
  }

  export type SellingHoursReportsUncheckedCreateWithoutTargetUserInput = {
    id?: string
    hoursAdded: number
    addedAt: Date | string
    userId: number
    hourPrice: number
    soldBy?: number | null
  }

  export type SellingHoursReportsCreateOrConnectWithoutTargetUserInput = {
    where: SellingHoursReportsWhereUniqueInput
    create: XOR<SellingHoursReportsCreateWithoutTargetUserInput, SellingHoursReportsUncheckedCreateWithoutTargetUserInput>
  }

  export type SellingHoursReportsCreateManyTargetUserInputEnvelope = {
    data: SellingHoursReportsCreateManyTargetUserInput | SellingHoursReportsCreateManyTargetUserInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutCustomerInput = {
    id?: string
    createdAt?: Date | string
    status: $Enums.BookingStatus
    channel: $Enums.PurchaseChannel
    totalPriceCents: number
    customerEmail?: string | null
    soldBy?: UserCreateNestedOneWithoutSoldBookingsInput
    tickets?: TicketCreateNestedManyWithoutBookingInput
    credits?: CinemaCreditCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutCustomerInput = {
    id?: string
    createdAt?: Date | string
    status: $Enums.BookingStatus
    channel: $Enums.PurchaseChannel
    totalPriceCents: number
    soldById?: number | null
    customerEmail?: string | null
    tickets?: TicketUncheckedCreateNestedManyWithoutBookingInput
    credits?: CinemaCreditUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutCustomerInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutCustomerInput, BookingUncheckedCreateWithoutCustomerInput>
  }

  export type BookingCreateManyCustomerInputEnvelope = {
    data: BookingCreateManyCustomerInput | BookingCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutSoldByInput = {
    id?: string
    createdAt?: Date | string
    status: $Enums.BookingStatus
    channel: $Enums.PurchaseChannel
    totalPriceCents: number
    customerEmail?: string | null
    customer?: UserCreateNestedOneWithoutBookingsInput
    tickets?: TicketCreateNestedManyWithoutBookingInput
    credits?: CinemaCreditCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutSoldByInput = {
    id?: string
    createdAt?: Date | string
    status: $Enums.BookingStatus
    channel: $Enums.PurchaseChannel
    totalPriceCents: number
    customerId?: number | null
    customerEmail?: string | null
    tickets?: TicketUncheckedCreateNestedManyWithoutBookingInput
    credits?: CinemaCreditUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutSoldByInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutSoldByInput, BookingUncheckedCreateWithoutSoldByInput>
  }

  export type BookingCreateManySoldByInputEnvelope = {
    data: BookingCreateManySoldByInput | BookingCreateManySoldByInput[]
    skipDuplicates?: boolean
  }

  export type SeatHoldCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    seat: SeatCreateNestedOneWithoutHoldInput
    showing: ShowingCreateNestedOneWithoutSeatHoldsInput
  }

  export type SeatHoldUncheckedCreateWithoutUserInput = {
    id?: string
    seatId: string
    showingId: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type SeatHoldCreateOrConnectWithoutUserInput = {
    where: SeatHoldWhereUniqueInput
    create: XOR<SeatHoldCreateWithoutUserInput, SeatHoldUncheckedCreateWithoutUserInput>
  }

  export type SeatHoldCreateManyUserInputEnvelope = {
    data: SeatHoldCreateManyUserInput | SeatHoldCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CinemaCreditCreateWithoutUserInput = {
    id?: string
    amountCents: number
    remainingCents: number
    reason: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
    booking?: BookingCreateNestedOneWithoutCreditsInput
    showing?: ShowingCreateNestedOneWithoutCreditsInput
  }

  export type CinemaCreditUncheckedCreateWithoutUserInput = {
    id?: string
    bookingId?: string | null
    showingId?: string | null
    amountCents: number
    remainingCents: number
    reason: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type CinemaCreditCreateOrConnectWithoutUserInput = {
    where: CinemaCreditWhereUniqueInput
    create: XOR<CinemaCreditCreateWithoutUserInput, CinemaCreditUncheckedCreateWithoutUserInput>
  }

  export type CinemaCreditCreateManyUserInputEnvelope = {
    data: CinemaCreditCreateManyUserInput | CinemaCreditCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PatentUpsertWithWhereUniqueWithoutUserInput = {
    where: PatentWhereUniqueInput
    update: XOR<PatentUpdateWithoutUserInput, PatentUncheckedUpdateWithoutUserInput>
    create: XOR<PatentCreateWithoutUserInput, PatentUncheckedCreateWithoutUserInput>
  }

  export type PatentUpdateWithWhereUniqueWithoutUserInput = {
    where: PatentWhereUniqueInput
    data: XOR<PatentUpdateWithoutUserInput, PatentUncheckedUpdateWithoutUserInput>
  }

  export type PatentUpdateManyWithWhereWithoutUserInput = {
    where: PatentScalarWhereInput
    data: XOR<PatentUpdateManyMutationInput, PatentUncheckedUpdateManyWithoutUserInput>
  }

  export type PatentScalarWhereInput = {
    AND?: PatentScalarWhereInput | PatentScalarWhereInput[]
    OR?: PatentScalarWhereInput[]
    NOT?: PatentScalarWhereInput | PatentScalarWhereInput[]
    id?: IntFilter<"Patent"> | number
    patentId?: StringFilter<"Patent"> | string
    userId?: IntNullableFilter<"Patent"> | number | null
    createdAt?: DateTimeFilter<"Patent"> | Date | string
    hasSingleHours?: BoolFilter<"Patent"> | boolean
    singleHours?: IntFilter<"Patent"> | number
    dni?: IntNullableFilter<"Patent"> | number | null
    isAllowed?: BoolFilter<"Patent"> | boolean
    canShow?: BoolFilter<"Patent"> | boolean
    isAllowedIn?: StringNullableFilter<"Patent"> | string | null
    houseType?: StringNullableFilter<"Patent"> | string | null
  }

  export type DeletedPatentsUpsertWithWhereUniqueWithoutUserInput = {
    where: DeletedPatentsWhereUniqueInput
    update: XOR<DeletedPatentsUpdateWithoutUserInput, DeletedPatentsUncheckedUpdateWithoutUserInput>
    create: XOR<DeletedPatentsCreateWithoutUserInput, DeletedPatentsUncheckedCreateWithoutUserInput>
  }

  export type DeletedPatentsUpdateWithWhereUniqueWithoutUserInput = {
    where: DeletedPatentsWhereUniqueInput
    data: XOR<DeletedPatentsUpdateWithoutUserInput, DeletedPatentsUncheckedUpdateWithoutUserInput>
  }

  export type DeletedPatentsUpdateManyWithWhereWithoutUserInput = {
    where: DeletedPatentsScalarWhereInput
    data: XOR<DeletedPatentsUpdateManyMutationInput, DeletedPatentsUncheckedUpdateManyWithoutUserInput>
  }

  export type DeletedPatentsScalarWhereInput = {
    AND?: DeletedPatentsScalarWhereInput | DeletedPatentsScalarWhereInput[]
    OR?: DeletedPatentsScalarWhereInput[]
    NOT?: DeletedPatentsScalarWhereInput | DeletedPatentsScalarWhereInput[]
    id?: IntFilter<"DeletedPatents"> | number
    patentId?: StringFilter<"DeletedPatents"> | string
    userId?: IntFilter<"DeletedPatents"> | number
    deletedAt?: DateTimeNullableFilter<"DeletedPatents"> | Date | string | null
  }

  export type SellPointUpsertWithWhereUniqueWithoutUserInput = {
    where: SellPointWhereUniqueInput
    update: XOR<SellPointUpdateWithoutUserInput, SellPointUncheckedUpdateWithoutUserInput>
    create: XOR<SellPointCreateWithoutUserInput, SellPointUncheckedCreateWithoutUserInput>
  }

  export type SellPointUpdateWithWhereUniqueWithoutUserInput = {
    where: SellPointWhereUniqueInput
    data: XOR<SellPointUpdateWithoutUserInput, SellPointUncheckedUpdateWithoutUserInput>
  }

  export type SellPointUpdateManyWithWhereWithoutUserInput = {
    where: SellPointScalarWhereInput
    data: XOR<SellPointUpdateManyMutationInput, SellPointUncheckedUpdateManyWithoutUserInput>
  }

  export type SellPointScalarWhereInput = {
    AND?: SellPointScalarWhereInput | SellPointScalarWhereInput[]
    OR?: SellPointScalarWhereInput[]
    NOT?: SellPointScalarWhereInput | SellPointScalarWhereInput[]
    id?: IntFilter<"SellPoint"> | number
    address?: StringFilter<"SellPoint"> | string
    street?: StringNullableFilter<"SellPoint"> | string | null
    streetNumber?: IntNullableFilter<"SellPoint"> | number | null
    availableHours?: IntFilter<"SellPoint"> | number
    usedHours?: IntFilter<"SellPoint"> | number
    pointName?: StringFilter<"SellPoint"> | string
    dni?: IntNullableFilter<"SellPoint"> | number | null
    userId?: IntNullableFilter<"SellPoint"> | number | null
    profitPercentage?: IntFilter<"SellPoint"> | number
  }

  export type SellingHoursReportsUpsertWithWhereUniqueWithoutUserInput = {
    where: SellingHoursReportsWhereUniqueInput
    update: XOR<SellingHoursReportsUpdateWithoutUserInput, SellingHoursReportsUncheckedUpdateWithoutUserInput>
    create: XOR<SellingHoursReportsCreateWithoutUserInput, SellingHoursReportsUncheckedCreateWithoutUserInput>
  }

  export type SellingHoursReportsUpdateWithWhereUniqueWithoutUserInput = {
    where: SellingHoursReportsWhereUniqueInput
    data: XOR<SellingHoursReportsUpdateWithoutUserInput, SellingHoursReportsUncheckedUpdateWithoutUserInput>
  }

  export type SellingHoursReportsUpdateManyWithWhereWithoutUserInput = {
    where: SellingHoursReportsScalarWhereInput
    data: XOR<SellingHoursReportsUpdateManyMutationInput, SellingHoursReportsUncheckedUpdateManyWithoutUserInput>
  }

  export type SellingHoursReportsScalarWhereInput = {
    AND?: SellingHoursReportsScalarWhereInput | SellingHoursReportsScalarWhereInput[]
    OR?: SellingHoursReportsScalarWhereInput[]
    NOT?: SellingHoursReportsScalarWhereInput | SellingHoursReportsScalarWhereInput[]
    id?: StringFilter<"SellingHoursReports"> | string
    hoursAdded?: IntFilter<"SellingHoursReports"> | number
    addedAt?: DateTimeFilter<"SellingHoursReports"> | Date | string
    userId?: IntFilter<"SellingHoursReports"> | number
    hourPrice?: FloatFilter<"SellingHoursReports"> | number
    soldBy?: IntNullableFilter<"SellingHoursReports"> | number | null
    targetUserId?: IntNullableFilter<"SellingHoursReports"> | number | null
  }

  export type ParkingUpsertWithWhereUniqueWithoutUserInput = {
    where: ParkingWhereUniqueInput
    update: XOR<ParkingUpdateWithoutUserInput, ParkingUncheckedUpdateWithoutUserInput>
    create: XOR<ParkingCreateWithoutUserInput, ParkingUncheckedCreateWithoutUserInput>
  }

  export type ParkingUpdateWithWhereUniqueWithoutUserInput = {
    where: ParkingWhereUniqueInput
    data: XOR<ParkingUpdateWithoutUserInput, ParkingUncheckedUpdateWithoutUserInput>
  }

  export type ParkingUpdateManyWithWhereWithoutUserInput = {
    where: ParkingScalarWhereInput
    data: XOR<ParkingUpdateManyMutationInput, ParkingUncheckedUpdateManyWithoutUserInput>
  }

  export type ParkingScalarWhereInput = {
    AND?: ParkingScalarWhereInput | ParkingScalarWhereInput[]
    OR?: ParkingScalarWhereInput[]
    NOT?: ParkingScalarWhereInput | ParkingScalarWhereInput[]
    id?: StringFilter<"Parking"> | string
    hours?: IntFilter<"Parking"> | number
    startedAt?: DateTimeFilter<"Parking"> | Date | string
    finishedAt?: DateTimeNullableFilter<"Parking"> | Date | string | null
    patentId?: StringFilter<"Parking"> | string
    userId?: IntNullableFilter<"Parking"> | number | null
    isMonthly?: BoolFilter<"Parking"> | boolean
  }

  export type UserHoursReportsUpsertWithWhereUniqueWithoutUserInput = {
    where: UserHoursReportsWhereUniqueInput
    update: XOR<UserHoursReportsUpdateWithoutUserInput, UserHoursReportsUncheckedUpdateWithoutUserInput>
    create: XOR<UserHoursReportsCreateWithoutUserInput, UserHoursReportsUncheckedCreateWithoutUserInput>
  }

  export type UserHoursReportsUpdateWithWhereUniqueWithoutUserInput = {
    where: UserHoursReportsWhereUniqueInput
    data: XOR<UserHoursReportsUpdateWithoutUserInput, UserHoursReportsUncheckedUpdateWithoutUserInput>
  }

  export type UserHoursReportsUpdateManyWithWhereWithoutUserInput = {
    where: UserHoursReportsScalarWhereInput
    data: XOR<UserHoursReportsUpdateManyMutationInput, UserHoursReportsUncheckedUpdateManyWithoutUserInput>
  }

  export type UserHoursReportsScalarWhereInput = {
    AND?: UserHoursReportsScalarWhereInput | UserHoursReportsScalarWhereInput[]
    OR?: UserHoursReportsScalarWhereInput[]
    NOT?: UserHoursReportsScalarWhereInput | UserHoursReportsScalarWhereInput[]
    id?: StringFilter<"UserHoursReports"> | string
    userId?: IntFilter<"UserHoursReports"> | number
    hoursBought?: IntFilter<"UserHoursReports"> | number
    boughtAt?: DateTimeFilter<"UserHoursReports"> | Date | string
    hourPrice?: FloatFilter<"UserHoursReports"> | number
    soldBy?: IntFilter<"UserHoursReports"> | number
  }

  export type UserParkingReportsUpsertWithWhereUniqueWithoutUserInput = {
    where: UserParkingReportsWhereUniqueInput
    update: XOR<UserParkingReportsUpdateWithoutUserInput, UserParkingReportsUncheckedUpdateWithoutUserInput>
    create: XOR<UserParkingReportsCreateWithoutUserInput, UserParkingReportsUncheckedCreateWithoutUserInput>
  }

  export type UserParkingReportsUpdateWithWhereUniqueWithoutUserInput = {
    where: UserParkingReportsWhereUniqueInput
    data: XOR<UserParkingReportsUpdateWithoutUserInput, UserParkingReportsUncheckedUpdateWithoutUserInput>
  }

  export type UserParkingReportsUpdateManyWithWhereWithoutUserInput = {
    where: UserParkingReportsScalarWhereInput
    data: XOR<UserParkingReportsUpdateManyMutationInput, UserParkingReportsUncheckedUpdateManyWithoutUserInput>
  }

  export type UserParkingReportsScalarWhereInput = {
    AND?: UserParkingReportsScalarWhereInput | UserParkingReportsScalarWhereInput[]
    OR?: UserParkingReportsScalarWhereInput[]
    NOT?: UserParkingReportsScalarWhereInput | UserParkingReportsScalarWhereInput[]
    id?: StringFilter<"UserParkingReports"> | string
    userId?: IntFilter<"UserParkingReports"> | number
    startedAt?: DateTimeFilter<"UserParkingReports"> | Date | string
    finishedAt?: DateTimeFilter<"UserParkingReports"> | Date | string
    patentId?: StringFilter<"UserParkingReports"> | string
    totalHours?: IntFilter<"UserParkingReports"> | number
    hourPrice?: FloatFilter<"UserParkingReports"> | number
  }

  export type InfractionUpsertWithWhereUniqueWithoutPayedByUserInput = {
    where: InfractionWhereUniqueInput
    update: XOR<InfractionUpdateWithoutPayedByUserInput, InfractionUncheckedUpdateWithoutPayedByUserInput>
    create: XOR<InfractionCreateWithoutPayedByUserInput, InfractionUncheckedCreateWithoutPayedByUserInput>
  }

  export type InfractionUpdateWithWhereUniqueWithoutPayedByUserInput = {
    where: InfractionWhereUniqueInput
    data: XOR<InfractionUpdateWithoutPayedByUserInput, InfractionUncheckedUpdateWithoutPayedByUserInput>
  }

  export type InfractionUpdateManyWithWhereWithoutPayedByUserInput = {
    where: InfractionScalarWhereInput
    data: XOR<InfractionUpdateManyMutationInput, InfractionUncheckedUpdateManyWithoutPayedByUserInput>
  }

  export type InfractionScalarWhereInput = {
    AND?: InfractionScalarWhereInput | InfractionScalarWhereInput[]
    OR?: InfractionScalarWhereInput[]
    NOT?: InfractionScalarWhereInput | InfractionScalarWhereInput[]
    id?: StringFilter<"Infraction"> | string
    numberId?: IntFilter<"Infraction"> | number
    createdAt?: DateTimeFilter<"Infraction"> | Date | string
    cancelled?: BoolFilter<"Infraction"> | boolean
    cancelledAt?: DateTimeNullableFilter<"Infraction"> | Date | string | null
    cancelledReason?: StringNullableFilter<"Infraction"> | string | null
    patentId?: StringFilter<"Infraction"> | string
    street?: StringNullableFilter<"Infraction"> | string | null
    payed?: BoolFilter<"Infraction"> | boolean
    payedAt?: DateTimeNullableFilter<"Infraction"> | Date | string | null
    isEnableToPay?: BoolNullableFilter<"Infraction"> | boolean | null
    paymentMethod?: StringNullableFilter<"Infraction"> | string | null
    payedByUserId?: IntNullableFilter<"Infraction"> | number | null
  }

  export type SellingHoursReportsUpsertWithWhereUniqueWithoutTargetUserInput = {
    where: SellingHoursReportsWhereUniqueInput
    update: XOR<SellingHoursReportsUpdateWithoutTargetUserInput, SellingHoursReportsUncheckedUpdateWithoutTargetUserInput>
    create: XOR<SellingHoursReportsCreateWithoutTargetUserInput, SellingHoursReportsUncheckedCreateWithoutTargetUserInput>
  }

  export type SellingHoursReportsUpdateWithWhereUniqueWithoutTargetUserInput = {
    where: SellingHoursReportsWhereUniqueInput
    data: XOR<SellingHoursReportsUpdateWithoutTargetUserInput, SellingHoursReportsUncheckedUpdateWithoutTargetUserInput>
  }

  export type SellingHoursReportsUpdateManyWithWhereWithoutTargetUserInput = {
    where: SellingHoursReportsScalarWhereInput
    data: XOR<SellingHoursReportsUpdateManyMutationInput, SellingHoursReportsUncheckedUpdateManyWithoutTargetUserInput>
  }

  export type BookingUpsertWithWhereUniqueWithoutCustomerInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutCustomerInput, BookingUncheckedUpdateWithoutCustomerInput>
    create: XOR<BookingCreateWithoutCustomerInput, BookingUncheckedCreateWithoutCustomerInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutCustomerInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutCustomerInput, BookingUncheckedUpdateWithoutCustomerInput>
  }

  export type BookingUpdateManyWithWhereWithoutCustomerInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutCustomerInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: StringFilter<"Booking"> | string
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    channel?: EnumPurchaseChannelFilter<"Booking"> | $Enums.PurchaseChannel
    totalPriceCents?: IntFilter<"Booking"> | number
    customerId?: IntNullableFilter<"Booking"> | number | null
    soldById?: IntNullableFilter<"Booking"> | number | null
    customerEmail?: StringNullableFilter<"Booking"> | string | null
  }

  export type BookingUpsertWithWhereUniqueWithoutSoldByInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutSoldByInput, BookingUncheckedUpdateWithoutSoldByInput>
    create: XOR<BookingCreateWithoutSoldByInput, BookingUncheckedCreateWithoutSoldByInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutSoldByInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutSoldByInput, BookingUncheckedUpdateWithoutSoldByInput>
  }

  export type BookingUpdateManyWithWhereWithoutSoldByInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutSoldByInput>
  }

  export type SeatHoldUpsertWithWhereUniqueWithoutUserInput = {
    where: SeatHoldWhereUniqueInput
    update: XOR<SeatHoldUpdateWithoutUserInput, SeatHoldUncheckedUpdateWithoutUserInput>
    create: XOR<SeatHoldCreateWithoutUserInput, SeatHoldUncheckedCreateWithoutUserInput>
  }

  export type SeatHoldUpdateWithWhereUniqueWithoutUserInput = {
    where: SeatHoldWhereUniqueInput
    data: XOR<SeatHoldUpdateWithoutUserInput, SeatHoldUncheckedUpdateWithoutUserInput>
  }

  export type SeatHoldUpdateManyWithWhereWithoutUserInput = {
    where: SeatHoldScalarWhereInput
    data: XOR<SeatHoldUpdateManyMutationInput, SeatHoldUncheckedUpdateManyWithoutUserInput>
  }

  export type SeatHoldScalarWhereInput = {
    AND?: SeatHoldScalarWhereInput | SeatHoldScalarWhereInput[]
    OR?: SeatHoldScalarWhereInput[]
    NOT?: SeatHoldScalarWhereInput | SeatHoldScalarWhereInput[]
    id?: StringFilter<"SeatHold"> | string
    seatId?: StringFilter<"SeatHold"> | string
    showingId?: StringFilter<"SeatHold"> | string
    userId?: IntFilter<"SeatHold"> | number
    createdAt?: DateTimeFilter<"SeatHold"> | Date | string
    expiresAt?: DateTimeFilter<"SeatHold"> | Date | string
  }

  export type CinemaCreditUpsertWithWhereUniqueWithoutUserInput = {
    where: CinemaCreditWhereUniqueInput
    update: XOR<CinemaCreditUpdateWithoutUserInput, CinemaCreditUncheckedUpdateWithoutUserInput>
    create: XOR<CinemaCreditCreateWithoutUserInput, CinemaCreditUncheckedCreateWithoutUserInput>
  }

  export type CinemaCreditUpdateWithWhereUniqueWithoutUserInput = {
    where: CinemaCreditWhereUniqueInput
    data: XOR<CinemaCreditUpdateWithoutUserInput, CinemaCreditUncheckedUpdateWithoutUserInput>
  }

  export type CinemaCreditUpdateManyWithWhereWithoutUserInput = {
    where: CinemaCreditScalarWhereInput
    data: XOR<CinemaCreditUpdateManyMutationInput, CinemaCreditUncheckedUpdateManyWithoutUserInput>
  }

  export type CinemaCreditScalarWhereInput = {
    AND?: CinemaCreditScalarWhereInput | CinemaCreditScalarWhereInput[]
    OR?: CinemaCreditScalarWhereInput[]
    NOT?: CinemaCreditScalarWhereInput | CinemaCreditScalarWhereInput[]
    id?: StringFilter<"CinemaCredit"> | string
    userId?: IntFilter<"CinemaCredit"> | number
    bookingId?: StringNullableFilter<"CinemaCredit"> | string | null
    showingId?: StringNullableFilter<"CinemaCredit"> | string | null
    amountCents?: IntFilter<"CinemaCredit"> | number
    remainingCents?: IntFilter<"CinemaCredit"> | number
    reason?: StringFilter<"CinemaCredit"> | string
    createdAt?: DateTimeFilter<"CinemaCredit"> | Date | string
    expiresAt?: DateTimeNullableFilter<"CinemaCredit"> | Date | string | null
  }

  export type UserCreateWithoutSellPointInput = {
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
    patents?: PatentCreateNestedManyWithoutUserInput
    deletedPatent?: DeletedPatentsCreateNestedManyWithoutUserInput
    sellingHoursReports?: SellingHoursReportsCreateNestedManyWithoutUserInput
    parking?: ParkingCreateNestedManyWithoutUserInput
    userReports?: UserHoursReportsCreateNestedManyWithoutUserInput
    userParkingReports?: UserParkingReportsCreateNestedManyWithoutUserInput
    paidInfractions?: InfractionCreateNestedManyWithoutPayedByUserInput
    receivedHoursSales?: SellingHoursReportsCreateNestedManyWithoutTargetUserInput
    bookings?: BookingCreateNestedManyWithoutCustomerInput
    soldBookings?: BookingCreateNestedManyWithoutSoldByInput
    seatHolds?: SeatHoldCreateNestedManyWithoutUserInput
    cinemaCredits?: CinemaCreditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSellPointInput = {
    id?: number
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
    patents?: PatentUncheckedCreateNestedManyWithoutUserInput
    deletedPatent?: DeletedPatentsUncheckedCreateNestedManyWithoutUserInput
    sellingHoursReports?: SellingHoursReportsUncheckedCreateNestedManyWithoutUserInput
    parking?: ParkingUncheckedCreateNestedManyWithoutUserInput
    userReports?: UserHoursReportsUncheckedCreateNestedManyWithoutUserInput
    userParkingReports?: UserParkingReportsUncheckedCreateNestedManyWithoutUserInput
    paidInfractions?: InfractionUncheckedCreateNestedManyWithoutPayedByUserInput
    receivedHoursSales?: SellingHoursReportsUncheckedCreateNestedManyWithoutTargetUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutCustomerInput
    soldBookings?: BookingUncheckedCreateNestedManyWithoutSoldByInput
    seatHolds?: SeatHoldUncheckedCreateNestedManyWithoutUserInput
    cinemaCredits?: CinemaCreditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSellPointInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSellPointInput, UserUncheckedCreateWithoutSellPointInput>
  }

  export type AssignHoursReportsCreateWithoutSellPointInput = {
    id?: string
    hoursAdded: number
    addedAt: Date | string
    hourPrice: number
    soldBy?: number | null
  }

  export type AssignHoursReportsUncheckedCreateWithoutSellPointInput = {
    id?: string
    hoursAdded: number
    addedAt: Date | string
    hourPrice: number
    soldBy?: number | null
  }

  export type AssignHoursReportsCreateOrConnectWithoutSellPointInput = {
    where: AssignHoursReportsWhereUniqueInput
    create: XOR<AssignHoursReportsCreateWithoutSellPointInput, AssignHoursReportsUncheckedCreateWithoutSellPointInput>
  }

  export type AssignHoursReportsCreateManySellPointInputEnvelope = {
    data: AssignHoursReportsCreateManySellPointInput | AssignHoursReportsCreateManySellPointInput[]
    skipDuplicates?: boolean
  }

  export type AssignPatentHoursReportsCreateWithoutSellPointInput = {
    id?: string
    hoursAdded: number
    addedAt: Date | string
    hourPrice: number
    patentId: string
    dni: number
    soldBy?: number | null
  }

  export type AssignPatentHoursReportsUncheckedCreateWithoutSellPointInput = {
    id?: string
    hoursAdded: number
    addedAt: Date | string
    hourPrice: number
    patentId: string
    dni: number
    soldBy?: number | null
  }

  export type AssignPatentHoursReportsCreateOrConnectWithoutSellPointInput = {
    where: AssignPatentHoursReportsWhereUniqueInput
    create: XOR<AssignPatentHoursReportsCreateWithoutSellPointInput, AssignPatentHoursReportsUncheckedCreateWithoutSellPointInput>
  }

  export type AssignPatentHoursReportsCreateManySellPointInputEnvelope = {
    data: AssignPatentHoursReportsCreateManySellPointInput | AssignPatentHoursReportsCreateManySellPointInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSellPointInput = {
    update: XOR<UserUpdateWithoutSellPointInput, UserUncheckedUpdateWithoutSellPointInput>
    create: XOR<UserCreateWithoutSellPointInput, UserUncheckedCreateWithoutSellPointInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSellPointInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSellPointInput, UserUncheckedUpdateWithoutSellPointInput>
  }

  export type UserUpdateWithoutSellPointInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
    patents?: PatentUpdateManyWithoutUserNestedInput
    deletedPatent?: DeletedPatentsUpdateManyWithoutUserNestedInput
    sellingHoursReports?: SellingHoursReportsUpdateManyWithoutUserNestedInput
    parking?: ParkingUpdateManyWithoutUserNestedInput
    userReports?: UserHoursReportsUpdateManyWithoutUserNestedInput
    userParkingReports?: UserParkingReportsUpdateManyWithoutUserNestedInput
    paidInfractions?: InfractionUpdateManyWithoutPayedByUserNestedInput
    receivedHoursSales?: SellingHoursReportsUpdateManyWithoutTargetUserNestedInput
    bookings?: BookingUpdateManyWithoutCustomerNestedInput
    soldBookings?: BookingUpdateManyWithoutSoldByNestedInput
    seatHolds?: SeatHoldUpdateManyWithoutUserNestedInput
    cinemaCredits?: CinemaCreditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSellPointInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
    patents?: PatentUncheckedUpdateManyWithoutUserNestedInput
    deletedPatent?: DeletedPatentsUncheckedUpdateManyWithoutUserNestedInput
    sellingHoursReports?: SellingHoursReportsUncheckedUpdateManyWithoutUserNestedInput
    parking?: ParkingUncheckedUpdateManyWithoutUserNestedInput
    userReports?: UserHoursReportsUncheckedUpdateManyWithoutUserNestedInput
    userParkingReports?: UserParkingReportsUncheckedUpdateManyWithoutUserNestedInput
    paidInfractions?: InfractionUncheckedUpdateManyWithoutPayedByUserNestedInput
    receivedHoursSales?: SellingHoursReportsUncheckedUpdateManyWithoutTargetUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutCustomerNestedInput
    soldBookings?: BookingUncheckedUpdateManyWithoutSoldByNestedInput
    seatHolds?: SeatHoldUncheckedUpdateManyWithoutUserNestedInput
    cinemaCredits?: CinemaCreditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AssignHoursReportsUpsertWithWhereUniqueWithoutSellPointInput = {
    where: AssignHoursReportsWhereUniqueInput
    update: XOR<AssignHoursReportsUpdateWithoutSellPointInput, AssignHoursReportsUncheckedUpdateWithoutSellPointInput>
    create: XOR<AssignHoursReportsCreateWithoutSellPointInput, AssignHoursReportsUncheckedCreateWithoutSellPointInput>
  }

  export type AssignHoursReportsUpdateWithWhereUniqueWithoutSellPointInput = {
    where: AssignHoursReportsWhereUniqueInput
    data: XOR<AssignHoursReportsUpdateWithoutSellPointInput, AssignHoursReportsUncheckedUpdateWithoutSellPointInput>
  }

  export type AssignHoursReportsUpdateManyWithWhereWithoutSellPointInput = {
    where: AssignHoursReportsScalarWhereInput
    data: XOR<AssignHoursReportsUpdateManyMutationInput, AssignHoursReportsUncheckedUpdateManyWithoutSellPointInput>
  }

  export type AssignHoursReportsScalarWhereInput = {
    AND?: AssignHoursReportsScalarWhereInput | AssignHoursReportsScalarWhereInput[]
    OR?: AssignHoursReportsScalarWhereInput[]
    NOT?: AssignHoursReportsScalarWhereInput | AssignHoursReportsScalarWhereInput[]
    id?: StringFilter<"AssignHoursReports"> | string
    hoursAdded?: IntFilter<"AssignHoursReports"> | number
    addedAt?: DateTimeFilter<"AssignHoursReports"> | Date | string
    sellPointId?: IntFilter<"AssignHoursReports"> | number
    hourPrice?: FloatFilter<"AssignHoursReports"> | number
    soldBy?: IntNullableFilter<"AssignHoursReports"> | number | null
  }

  export type AssignPatentHoursReportsUpsertWithWhereUniqueWithoutSellPointInput = {
    where: AssignPatentHoursReportsWhereUniqueInput
    update: XOR<AssignPatentHoursReportsUpdateWithoutSellPointInput, AssignPatentHoursReportsUncheckedUpdateWithoutSellPointInput>
    create: XOR<AssignPatentHoursReportsCreateWithoutSellPointInput, AssignPatentHoursReportsUncheckedCreateWithoutSellPointInput>
  }

  export type AssignPatentHoursReportsUpdateWithWhereUniqueWithoutSellPointInput = {
    where: AssignPatentHoursReportsWhereUniqueInput
    data: XOR<AssignPatentHoursReportsUpdateWithoutSellPointInput, AssignPatentHoursReportsUncheckedUpdateWithoutSellPointInput>
  }

  export type AssignPatentHoursReportsUpdateManyWithWhereWithoutSellPointInput = {
    where: AssignPatentHoursReportsScalarWhereInput
    data: XOR<AssignPatentHoursReportsUpdateManyMutationInput, AssignPatentHoursReportsUncheckedUpdateManyWithoutSellPointInput>
  }

  export type AssignPatentHoursReportsScalarWhereInput = {
    AND?: AssignPatentHoursReportsScalarWhereInput | AssignPatentHoursReportsScalarWhereInput[]
    OR?: AssignPatentHoursReportsScalarWhereInput[]
    NOT?: AssignPatentHoursReportsScalarWhereInput | AssignPatentHoursReportsScalarWhereInput[]
    id?: StringFilter<"AssignPatentHoursReports"> | string
    hoursAdded?: IntFilter<"AssignPatentHoursReports"> | number
    addedAt?: DateTimeFilter<"AssignPatentHoursReports"> | Date | string
    sellPointId?: IntNullableFilter<"AssignPatentHoursReports"> | number | null
    hourPrice?: FloatFilter<"AssignPatentHoursReports"> | number
    patentId?: StringFilter<"AssignPatentHoursReports"> | string
    dni?: IntFilter<"AssignPatentHoursReports"> | number
    soldBy?: IntNullableFilter<"AssignPatentHoursReports"> | number | null
  }

  export type UserCreateWithoutPatentsInput = {
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
    deletedPatent?: DeletedPatentsCreateNestedManyWithoutUserInput
    sellPoint?: SellPointCreateNestedManyWithoutUserInput
    sellingHoursReports?: SellingHoursReportsCreateNestedManyWithoutUserInput
    parking?: ParkingCreateNestedManyWithoutUserInput
    userReports?: UserHoursReportsCreateNestedManyWithoutUserInput
    userParkingReports?: UserParkingReportsCreateNestedManyWithoutUserInput
    paidInfractions?: InfractionCreateNestedManyWithoutPayedByUserInput
    receivedHoursSales?: SellingHoursReportsCreateNestedManyWithoutTargetUserInput
    bookings?: BookingCreateNestedManyWithoutCustomerInput
    soldBookings?: BookingCreateNestedManyWithoutSoldByInput
    seatHolds?: SeatHoldCreateNestedManyWithoutUserInput
    cinemaCredits?: CinemaCreditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPatentsInput = {
    id?: number
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
    deletedPatent?: DeletedPatentsUncheckedCreateNestedManyWithoutUserInput
    sellPoint?: SellPointUncheckedCreateNestedManyWithoutUserInput
    sellingHoursReports?: SellingHoursReportsUncheckedCreateNestedManyWithoutUserInput
    parking?: ParkingUncheckedCreateNestedManyWithoutUserInput
    userReports?: UserHoursReportsUncheckedCreateNestedManyWithoutUserInput
    userParkingReports?: UserParkingReportsUncheckedCreateNestedManyWithoutUserInput
    paidInfractions?: InfractionUncheckedCreateNestedManyWithoutPayedByUserInput
    receivedHoursSales?: SellingHoursReportsUncheckedCreateNestedManyWithoutTargetUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutCustomerInput
    soldBookings?: BookingUncheckedCreateNestedManyWithoutSoldByInput
    seatHolds?: SeatHoldUncheckedCreateNestedManyWithoutUserInput
    cinemaCredits?: CinemaCreditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPatentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPatentsInput, UserUncheckedCreateWithoutPatentsInput>
  }

  export type UserUpsertWithoutPatentsInput = {
    update: XOR<UserUpdateWithoutPatentsInput, UserUncheckedUpdateWithoutPatentsInput>
    create: XOR<UserCreateWithoutPatentsInput, UserUncheckedCreateWithoutPatentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPatentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPatentsInput, UserUncheckedUpdateWithoutPatentsInput>
  }

  export type UserUpdateWithoutPatentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
    deletedPatent?: DeletedPatentsUpdateManyWithoutUserNestedInput
    sellPoint?: SellPointUpdateManyWithoutUserNestedInput
    sellingHoursReports?: SellingHoursReportsUpdateManyWithoutUserNestedInput
    parking?: ParkingUpdateManyWithoutUserNestedInput
    userReports?: UserHoursReportsUpdateManyWithoutUserNestedInput
    userParkingReports?: UserParkingReportsUpdateManyWithoutUserNestedInput
    paidInfractions?: InfractionUpdateManyWithoutPayedByUserNestedInput
    receivedHoursSales?: SellingHoursReportsUpdateManyWithoutTargetUserNestedInput
    bookings?: BookingUpdateManyWithoutCustomerNestedInput
    soldBookings?: BookingUpdateManyWithoutSoldByNestedInput
    seatHolds?: SeatHoldUpdateManyWithoutUserNestedInput
    cinemaCredits?: CinemaCreditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPatentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
    deletedPatent?: DeletedPatentsUncheckedUpdateManyWithoutUserNestedInput
    sellPoint?: SellPointUncheckedUpdateManyWithoutUserNestedInput
    sellingHoursReports?: SellingHoursReportsUncheckedUpdateManyWithoutUserNestedInput
    parking?: ParkingUncheckedUpdateManyWithoutUserNestedInput
    userReports?: UserHoursReportsUncheckedUpdateManyWithoutUserNestedInput
    userParkingReports?: UserParkingReportsUncheckedUpdateManyWithoutUserNestedInput
    paidInfractions?: InfractionUncheckedUpdateManyWithoutPayedByUserNestedInput
    receivedHoursSales?: SellingHoursReportsUncheckedUpdateManyWithoutTargetUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutCustomerNestedInput
    soldBookings?: BookingUncheckedUpdateManyWithoutSoldByNestedInput
    seatHolds?: SeatHoldUncheckedUpdateManyWithoutUserNestedInput
    cinemaCredits?: CinemaCreditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDeletedPatentInput = {
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
    patents?: PatentCreateNestedManyWithoutUserInput
    sellPoint?: SellPointCreateNestedManyWithoutUserInput
    sellingHoursReports?: SellingHoursReportsCreateNestedManyWithoutUserInput
    parking?: ParkingCreateNestedManyWithoutUserInput
    userReports?: UserHoursReportsCreateNestedManyWithoutUserInput
    userParkingReports?: UserParkingReportsCreateNestedManyWithoutUserInput
    paidInfractions?: InfractionCreateNestedManyWithoutPayedByUserInput
    receivedHoursSales?: SellingHoursReportsCreateNestedManyWithoutTargetUserInput
    bookings?: BookingCreateNestedManyWithoutCustomerInput
    soldBookings?: BookingCreateNestedManyWithoutSoldByInput
    seatHolds?: SeatHoldCreateNestedManyWithoutUserInput
    cinemaCredits?: CinemaCreditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDeletedPatentInput = {
    id?: number
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
    patents?: PatentUncheckedCreateNestedManyWithoutUserInput
    sellPoint?: SellPointUncheckedCreateNestedManyWithoutUserInput
    sellingHoursReports?: SellingHoursReportsUncheckedCreateNestedManyWithoutUserInput
    parking?: ParkingUncheckedCreateNestedManyWithoutUserInput
    userReports?: UserHoursReportsUncheckedCreateNestedManyWithoutUserInput
    userParkingReports?: UserParkingReportsUncheckedCreateNestedManyWithoutUserInput
    paidInfractions?: InfractionUncheckedCreateNestedManyWithoutPayedByUserInput
    receivedHoursSales?: SellingHoursReportsUncheckedCreateNestedManyWithoutTargetUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutCustomerInput
    soldBookings?: BookingUncheckedCreateNestedManyWithoutSoldByInput
    seatHolds?: SeatHoldUncheckedCreateNestedManyWithoutUserInput
    cinemaCredits?: CinemaCreditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDeletedPatentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeletedPatentInput, UserUncheckedCreateWithoutDeletedPatentInput>
  }

  export type UserUpsertWithoutDeletedPatentInput = {
    update: XOR<UserUpdateWithoutDeletedPatentInput, UserUncheckedUpdateWithoutDeletedPatentInput>
    create: XOR<UserCreateWithoutDeletedPatentInput, UserUncheckedCreateWithoutDeletedPatentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeletedPatentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeletedPatentInput, UserUncheckedUpdateWithoutDeletedPatentInput>
  }

  export type UserUpdateWithoutDeletedPatentInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
    patents?: PatentUpdateManyWithoutUserNestedInput
    sellPoint?: SellPointUpdateManyWithoutUserNestedInput
    sellingHoursReports?: SellingHoursReportsUpdateManyWithoutUserNestedInput
    parking?: ParkingUpdateManyWithoutUserNestedInput
    userReports?: UserHoursReportsUpdateManyWithoutUserNestedInput
    userParkingReports?: UserParkingReportsUpdateManyWithoutUserNestedInput
    paidInfractions?: InfractionUpdateManyWithoutPayedByUserNestedInput
    receivedHoursSales?: SellingHoursReportsUpdateManyWithoutTargetUserNestedInput
    bookings?: BookingUpdateManyWithoutCustomerNestedInput
    soldBookings?: BookingUpdateManyWithoutSoldByNestedInput
    seatHolds?: SeatHoldUpdateManyWithoutUserNestedInput
    cinemaCredits?: CinemaCreditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDeletedPatentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
    patents?: PatentUncheckedUpdateManyWithoutUserNestedInput
    sellPoint?: SellPointUncheckedUpdateManyWithoutUserNestedInput
    sellingHoursReports?: SellingHoursReportsUncheckedUpdateManyWithoutUserNestedInput
    parking?: ParkingUncheckedUpdateManyWithoutUserNestedInput
    userReports?: UserHoursReportsUncheckedUpdateManyWithoutUserNestedInput
    userParkingReports?: UserParkingReportsUncheckedUpdateManyWithoutUserNestedInput
    paidInfractions?: InfractionUncheckedUpdateManyWithoutPayedByUserNestedInput
    receivedHoursSales?: SellingHoursReportsUncheckedUpdateManyWithoutTargetUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutCustomerNestedInput
    soldBookings?: BookingUncheckedUpdateManyWithoutSoldByNestedInput
    seatHolds?: SeatHoldUncheckedUpdateManyWithoutUserNestedInput
    cinemaCredits?: CinemaCreditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SellPointCreateWithoutReportsInput = {
    address: string
    street?: string | null
    streetNumber?: number | null
    availableHours?: number
    usedHours?: number
    pointName: string
    dni?: number | null
    profitPercentage: number
    user?: UserCreateNestedOneWithoutSellPointInput
    patentReports?: AssignPatentHoursReportsCreateNestedManyWithoutSellPointInput
  }

  export type SellPointUncheckedCreateWithoutReportsInput = {
    id?: number
    address: string
    street?: string | null
    streetNumber?: number | null
    availableHours?: number
    usedHours?: number
    pointName: string
    dni?: number | null
    userId?: number | null
    profitPercentage: number
    patentReports?: AssignPatentHoursReportsUncheckedCreateNestedManyWithoutSellPointInput
  }

  export type SellPointCreateOrConnectWithoutReportsInput = {
    where: SellPointWhereUniqueInput
    create: XOR<SellPointCreateWithoutReportsInput, SellPointUncheckedCreateWithoutReportsInput>
  }

  export type SellPointUpsertWithoutReportsInput = {
    update: XOR<SellPointUpdateWithoutReportsInput, SellPointUncheckedUpdateWithoutReportsInput>
    create: XOR<SellPointCreateWithoutReportsInput, SellPointUncheckedCreateWithoutReportsInput>
    where?: SellPointWhereInput
  }

  export type SellPointUpdateToOneWithWhereWithoutReportsInput = {
    where?: SellPointWhereInput
    data: XOR<SellPointUpdateWithoutReportsInput, SellPointUncheckedUpdateWithoutReportsInput>
  }

  export type SellPointUpdateWithoutReportsInput = {
    address?: StringFieldUpdateOperationsInput | string
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableIntFieldUpdateOperationsInput | number | null
    availableHours?: IntFieldUpdateOperationsInput | number
    usedHours?: IntFieldUpdateOperationsInput | number
    pointName?: StringFieldUpdateOperationsInput | string
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    profitPercentage?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneWithoutSellPointNestedInput
    patentReports?: AssignPatentHoursReportsUpdateManyWithoutSellPointNestedInput
  }

  export type SellPointUncheckedUpdateWithoutReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableIntFieldUpdateOperationsInput | number | null
    availableHours?: IntFieldUpdateOperationsInput | number
    usedHours?: IntFieldUpdateOperationsInput | number
    pointName?: StringFieldUpdateOperationsInput | string
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    profitPercentage?: IntFieldUpdateOperationsInput | number
    patentReports?: AssignPatentHoursReportsUncheckedUpdateManyWithoutSellPointNestedInput
  }

  export type SellPointCreateWithoutPatentReportsInput = {
    address: string
    street?: string | null
    streetNumber?: number | null
    availableHours?: number
    usedHours?: number
    pointName: string
    dni?: number | null
    profitPercentage: number
    user?: UserCreateNestedOneWithoutSellPointInput
    reports?: AssignHoursReportsCreateNestedManyWithoutSellPointInput
  }

  export type SellPointUncheckedCreateWithoutPatentReportsInput = {
    id?: number
    address: string
    street?: string | null
    streetNumber?: number | null
    availableHours?: number
    usedHours?: number
    pointName: string
    dni?: number | null
    userId?: number | null
    profitPercentage: number
    reports?: AssignHoursReportsUncheckedCreateNestedManyWithoutSellPointInput
  }

  export type SellPointCreateOrConnectWithoutPatentReportsInput = {
    where: SellPointWhereUniqueInput
    create: XOR<SellPointCreateWithoutPatentReportsInput, SellPointUncheckedCreateWithoutPatentReportsInput>
  }

  export type SellPointUpsertWithoutPatentReportsInput = {
    update: XOR<SellPointUpdateWithoutPatentReportsInput, SellPointUncheckedUpdateWithoutPatentReportsInput>
    create: XOR<SellPointCreateWithoutPatentReportsInput, SellPointUncheckedCreateWithoutPatentReportsInput>
    where?: SellPointWhereInput
  }

  export type SellPointUpdateToOneWithWhereWithoutPatentReportsInput = {
    where?: SellPointWhereInput
    data: XOR<SellPointUpdateWithoutPatentReportsInput, SellPointUncheckedUpdateWithoutPatentReportsInput>
  }

  export type SellPointUpdateWithoutPatentReportsInput = {
    address?: StringFieldUpdateOperationsInput | string
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableIntFieldUpdateOperationsInput | number | null
    availableHours?: IntFieldUpdateOperationsInput | number
    usedHours?: IntFieldUpdateOperationsInput | number
    pointName?: StringFieldUpdateOperationsInput | string
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    profitPercentage?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneWithoutSellPointNestedInput
    reports?: AssignHoursReportsUpdateManyWithoutSellPointNestedInput
  }

  export type SellPointUncheckedUpdateWithoutPatentReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableIntFieldUpdateOperationsInput | number | null
    availableHours?: IntFieldUpdateOperationsInput | number
    usedHours?: IntFieldUpdateOperationsInput | number
    pointName?: StringFieldUpdateOperationsInput | string
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    profitPercentage?: IntFieldUpdateOperationsInput | number
    reports?: AssignHoursReportsUncheckedUpdateManyWithoutSellPointNestedInput
  }

  export type UserCreateWithoutSellingHoursReportsInput = {
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
    patents?: PatentCreateNestedManyWithoutUserInput
    deletedPatent?: DeletedPatentsCreateNestedManyWithoutUserInput
    sellPoint?: SellPointCreateNestedManyWithoutUserInput
    parking?: ParkingCreateNestedManyWithoutUserInput
    userReports?: UserHoursReportsCreateNestedManyWithoutUserInput
    userParkingReports?: UserParkingReportsCreateNestedManyWithoutUserInput
    paidInfractions?: InfractionCreateNestedManyWithoutPayedByUserInput
    receivedHoursSales?: SellingHoursReportsCreateNestedManyWithoutTargetUserInput
    bookings?: BookingCreateNestedManyWithoutCustomerInput
    soldBookings?: BookingCreateNestedManyWithoutSoldByInput
    seatHolds?: SeatHoldCreateNestedManyWithoutUserInput
    cinemaCredits?: CinemaCreditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSellingHoursReportsInput = {
    id?: number
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
    patents?: PatentUncheckedCreateNestedManyWithoutUserInput
    deletedPatent?: DeletedPatentsUncheckedCreateNestedManyWithoutUserInput
    sellPoint?: SellPointUncheckedCreateNestedManyWithoutUserInput
    parking?: ParkingUncheckedCreateNestedManyWithoutUserInput
    userReports?: UserHoursReportsUncheckedCreateNestedManyWithoutUserInput
    userParkingReports?: UserParkingReportsUncheckedCreateNestedManyWithoutUserInput
    paidInfractions?: InfractionUncheckedCreateNestedManyWithoutPayedByUserInput
    receivedHoursSales?: SellingHoursReportsUncheckedCreateNestedManyWithoutTargetUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutCustomerInput
    soldBookings?: BookingUncheckedCreateNestedManyWithoutSoldByInput
    seatHolds?: SeatHoldUncheckedCreateNestedManyWithoutUserInput
    cinemaCredits?: CinemaCreditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSellingHoursReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSellingHoursReportsInput, UserUncheckedCreateWithoutSellingHoursReportsInput>
  }

  export type UserCreateWithoutReceivedHoursSalesInput = {
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
    patents?: PatentCreateNestedManyWithoutUserInput
    deletedPatent?: DeletedPatentsCreateNestedManyWithoutUserInput
    sellPoint?: SellPointCreateNestedManyWithoutUserInput
    sellingHoursReports?: SellingHoursReportsCreateNestedManyWithoutUserInput
    parking?: ParkingCreateNestedManyWithoutUserInput
    userReports?: UserHoursReportsCreateNestedManyWithoutUserInput
    userParkingReports?: UserParkingReportsCreateNestedManyWithoutUserInput
    paidInfractions?: InfractionCreateNestedManyWithoutPayedByUserInput
    bookings?: BookingCreateNestedManyWithoutCustomerInput
    soldBookings?: BookingCreateNestedManyWithoutSoldByInput
    seatHolds?: SeatHoldCreateNestedManyWithoutUserInput
    cinemaCredits?: CinemaCreditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReceivedHoursSalesInput = {
    id?: number
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
    patents?: PatentUncheckedCreateNestedManyWithoutUserInput
    deletedPatent?: DeletedPatentsUncheckedCreateNestedManyWithoutUserInput
    sellPoint?: SellPointUncheckedCreateNestedManyWithoutUserInput
    sellingHoursReports?: SellingHoursReportsUncheckedCreateNestedManyWithoutUserInput
    parking?: ParkingUncheckedCreateNestedManyWithoutUserInput
    userReports?: UserHoursReportsUncheckedCreateNestedManyWithoutUserInput
    userParkingReports?: UserParkingReportsUncheckedCreateNestedManyWithoutUserInput
    paidInfractions?: InfractionUncheckedCreateNestedManyWithoutPayedByUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutCustomerInput
    soldBookings?: BookingUncheckedCreateNestedManyWithoutSoldByInput
    seatHolds?: SeatHoldUncheckedCreateNestedManyWithoutUserInput
    cinemaCredits?: CinemaCreditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReceivedHoursSalesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedHoursSalesInput, UserUncheckedCreateWithoutReceivedHoursSalesInput>
  }

  export type UserUpsertWithoutSellingHoursReportsInput = {
    update: XOR<UserUpdateWithoutSellingHoursReportsInput, UserUncheckedUpdateWithoutSellingHoursReportsInput>
    create: XOR<UserCreateWithoutSellingHoursReportsInput, UserUncheckedCreateWithoutSellingHoursReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSellingHoursReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSellingHoursReportsInput, UserUncheckedUpdateWithoutSellingHoursReportsInput>
  }

  export type UserUpdateWithoutSellingHoursReportsInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
    patents?: PatentUpdateManyWithoutUserNestedInput
    deletedPatent?: DeletedPatentsUpdateManyWithoutUserNestedInput
    sellPoint?: SellPointUpdateManyWithoutUserNestedInput
    parking?: ParkingUpdateManyWithoutUserNestedInput
    userReports?: UserHoursReportsUpdateManyWithoutUserNestedInput
    userParkingReports?: UserParkingReportsUpdateManyWithoutUserNestedInput
    paidInfractions?: InfractionUpdateManyWithoutPayedByUserNestedInput
    receivedHoursSales?: SellingHoursReportsUpdateManyWithoutTargetUserNestedInput
    bookings?: BookingUpdateManyWithoutCustomerNestedInput
    soldBookings?: BookingUpdateManyWithoutSoldByNestedInput
    seatHolds?: SeatHoldUpdateManyWithoutUserNestedInput
    cinemaCredits?: CinemaCreditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSellingHoursReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
    patents?: PatentUncheckedUpdateManyWithoutUserNestedInput
    deletedPatent?: DeletedPatentsUncheckedUpdateManyWithoutUserNestedInput
    sellPoint?: SellPointUncheckedUpdateManyWithoutUserNestedInput
    parking?: ParkingUncheckedUpdateManyWithoutUserNestedInput
    userReports?: UserHoursReportsUncheckedUpdateManyWithoutUserNestedInput
    userParkingReports?: UserParkingReportsUncheckedUpdateManyWithoutUserNestedInput
    paidInfractions?: InfractionUncheckedUpdateManyWithoutPayedByUserNestedInput
    receivedHoursSales?: SellingHoursReportsUncheckedUpdateManyWithoutTargetUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutCustomerNestedInput
    soldBookings?: BookingUncheckedUpdateManyWithoutSoldByNestedInput
    seatHolds?: SeatHoldUncheckedUpdateManyWithoutUserNestedInput
    cinemaCredits?: CinemaCreditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutReceivedHoursSalesInput = {
    update: XOR<UserUpdateWithoutReceivedHoursSalesInput, UserUncheckedUpdateWithoutReceivedHoursSalesInput>
    create: XOR<UserCreateWithoutReceivedHoursSalesInput, UserUncheckedCreateWithoutReceivedHoursSalesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedHoursSalesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedHoursSalesInput, UserUncheckedUpdateWithoutReceivedHoursSalesInput>
  }

  export type UserUpdateWithoutReceivedHoursSalesInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
    patents?: PatentUpdateManyWithoutUserNestedInput
    deletedPatent?: DeletedPatentsUpdateManyWithoutUserNestedInput
    sellPoint?: SellPointUpdateManyWithoutUserNestedInput
    sellingHoursReports?: SellingHoursReportsUpdateManyWithoutUserNestedInput
    parking?: ParkingUpdateManyWithoutUserNestedInput
    userReports?: UserHoursReportsUpdateManyWithoutUserNestedInput
    userParkingReports?: UserParkingReportsUpdateManyWithoutUserNestedInput
    paidInfractions?: InfractionUpdateManyWithoutPayedByUserNestedInput
    bookings?: BookingUpdateManyWithoutCustomerNestedInput
    soldBookings?: BookingUpdateManyWithoutSoldByNestedInput
    seatHolds?: SeatHoldUpdateManyWithoutUserNestedInput
    cinemaCredits?: CinemaCreditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedHoursSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
    patents?: PatentUncheckedUpdateManyWithoutUserNestedInput
    deletedPatent?: DeletedPatentsUncheckedUpdateManyWithoutUserNestedInput
    sellPoint?: SellPointUncheckedUpdateManyWithoutUserNestedInput
    sellingHoursReports?: SellingHoursReportsUncheckedUpdateManyWithoutUserNestedInput
    parking?: ParkingUncheckedUpdateManyWithoutUserNestedInput
    userReports?: UserHoursReportsUncheckedUpdateManyWithoutUserNestedInput
    userParkingReports?: UserParkingReportsUncheckedUpdateManyWithoutUserNestedInput
    paidInfractions?: InfractionUncheckedUpdateManyWithoutPayedByUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutCustomerNestedInput
    soldBookings?: BookingUncheckedUpdateManyWithoutSoldByNestedInput
    seatHolds?: SeatHoldUncheckedUpdateManyWithoutUserNestedInput
    cinemaCredits?: CinemaCreditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUserReportsInput = {
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
    patents?: PatentCreateNestedManyWithoutUserInput
    deletedPatent?: DeletedPatentsCreateNestedManyWithoutUserInput
    sellPoint?: SellPointCreateNestedManyWithoutUserInput
    sellingHoursReports?: SellingHoursReportsCreateNestedManyWithoutUserInput
    parking?: ParkingCreateNestedManyWithoutUserInput
    userParkingReports?: UserParkingReportsCreateNestedManyWithoutUserInput
    paidInfractions?: InfractionCreateNestedManyWithoutPayedByUserInput
    receivedHoursSales?: SellingHoursReportsCreateNestedManyWithoutTargetUserInput
    bookings?: BookingCreateNestedManyWithoutCustomerInput
    soldBookings?: BookingCreateNestedManyWithoutSoldByInput
    seatHolds?: SeatHoldCreateNestedManyWithoutUserInput
    cinemaCredits?: CinemaCreditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserReportsInput = {
    id?: number
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
    patents?: PatentUncheckedCreateNestedManyWithoutUserInput
    deletedPatent?: DeletedPatentsUncheckedCreateNestedManyWithoutUserInput
    sellPoint?: SellPointUncheckedCreateNestedManyWithoutUserInput
    sellingHoursReports?: SellingHoursReportsUncheckedCreateNestedManyWithoutUserInput
    parking?: ParkingUncheckedCreateNestedManyWithoutUserInput
    userParkingReports?: UserParkingReportsUncheckedCreateNestedManyWithoutUserInput
    paidInfractions?: InfractionUncheckedCreateNestedManyWithoutPayedByUserInput
    receivedHoursSales?: SellingHoursReportsUncheckedCreateNestedManyWithoutTargetUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutCustomerInput
    soldBookings?: BookingUncheckedCreateNestedManyWithoutSoldByInput
    seatHolds?: SeatHoldUncheckedCreateNestedManyWithoutUserInput
    cinemaCredits?: CinemaCreditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserReportsInput, UserUncheckedCreateWithoutUserReportsInput>
  }

  export type UserUpsertWithoutUserReportsInput = {
    update: XOR<UserUpdateWithoutUserReportsInput, UserUncheckedUpdateWithoutUserReportsInput>
    create: XOR<UserCreateWithoutUserReportsInput, UserUncheckedCreateWithoutUserReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserReportsInput, UserUncheckedUpdateWithoutUserReportsInput>
  }

  export type UserUpdateWithoutUserReportsInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
    patents?: PatentUpdateManyWithoutUserNestedInput
    deletedPatent?: DeletedPatentsUpdateManyWithoutUserNestedInput
    sellPoint?: SellPointUpdateManyWithoutUserNestedInput
    sellingHoursReports?: SellingHoursReportsUpdateManyWithoutUserNestedInput
    parking?: ParkingUpdateManyWithoutUserNestedInput
    userParkingReports?: UserParkingReportsUpdateManyWithoutUserNestedInput
    paidInfractions?: InfractionUpdateManyWithoutPayedByUserNestedInput
    receivedHoursSales?: SellingHoursReportsUpdateManyWithoutTargetUserNestedInput
    bookings?: BookingUpdateManyWithoutCustomerNestedInput
    soldBookings?: BookingUpdateManyWithoutSoldByNestedInput
    seatHolds?: SeatHoldUpdateManyWithoutUserNestedInput
    cinemaCredits?: CinemaCreditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
    patents?: PatentUncheckedUpdateManyWithoutUserNestedInput
    deletedPatent?: DeletedPatentsUncheckedUpdateManyWithoutUserNestedInput
    sellPoint?: SellPointUncheckedUpdateManyWithoutUserNestedInput
    sellingHoursReports?: SellingHoursReportsUncheckedUpdateManyWithoutUserNestedInput
    parking?: ParkingUncheckedUpdateManyWithoutUserNestedInput
    userParkingReports?: UserParkingReportsUncheckedUpdateManyWithoutUserNestedInput
    paidInfractions?: InfractionUncheckedUpdateManyWithoutPayedByUserNestedInput
    receivedHoursSales?: SellingHoursReportsUncheckedUpdateManyWithoutTargetUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutCustomerNestedInput
    soldBookings?: BookingUncheckedUpdateManyWithoutSoldByNestedInput
    seatHolds?: SeatHoldUncheckedUpdateManyWithoutUserNestedInput
    cinemaCredits?: CinemaCreditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUserParkingReportsInput = {
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
    patents?: PatentCreateNestedManyWithoutUserInput
    deletedPatent?: DeletedPatentsCreateNestedManyWithoutUserInput
    sellPoint?: SellPointCreateNestedManyWithoutUserInput
    sellingHoursReports?: SellingHoursReportsCreateNestedManyWithoutUserInput
    parking?: ParkingCreateNestedManyWithoutUserInput
    userReports?: UserHoursReportsCreateNestedManyWithoutUserInput
    paidInfractions?: InfractionCreateNestedManyWithoutPayedByUserInput
    receivedHoursSales?: SellingHoursReportsCreateNestedManyWithoutTargetUserInput
    bookings?: BookingCreateNestedManyWithoutCustomerInput
    soldBookings?: BookingCreateNestedManyWithoutSoldByInput
    seatHolds?: SeatHoldCreateNestedManyWithoutUserInput
    cinemaCredits?: CinemaCreditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserParkingReportsInput = {
    id?: number
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
    patents?: PatentUncheckedCreateNestedManyWithoutUserInput
    deletedPatent?: DeletedPatentsUncheckedCreateNestedManyWithoutUserInput
    sellPoint?: SellPointUncheckedCreateNestedManyWithoutUserInput
    sellingHoursReports?: SellingHoursReportsUncheckedCreateNestedManyWithoutUserInput
    parking?: ParkingUncheckedCreateNestedManyWithoutUserInput
    userReports?: UserHoursReportsUncheckedCreateNestedManyWithoutUserInput
    paidInfractions?: InfractionUncheckedCreateNestedManyWithoutPayedByUserInput
    receivedHoursSales?: SellingHoursReportsUncheckedCreateNestedManyWithoutTargetUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutCustomerInput
    soldBookings?: BookingUncheckedCreateNestedManyWithoutSoldByInput
    seatHolds?: SeatHoldUncheckedCreateNestedManyWithoutUserInput
    cinemaCredits?: CinemaCreditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserParkingReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserParkingReportsInput, UserUncheckedCreateWithoutUserParkingReportsInput>
  }

  export type UserUpsertWithoutUserParkingReportsInput = {
    update: XOR<UserUpdateWithoutUserParkingReportsInput, UserUncheckedUpdateWithoutUserParkingReportsInput>
    create: XOR<UserCreateWithoutUserParkingReportsInput, UserUncheckedCreateWithoutUserParkingReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserParkingReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserParkingReportsInput, UserUncheckedUpdateWithoutUserParkingReportsInput>
  }

  export type UserUpdateWithoutUserParkingReportsInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
    patents?: PatentUpdateManyWithoutUserNestedInput
    deletedPatent?: DeletedPatentsUpdateManyWithoutUserNestedInput
    sellPoint?: SellPointUpdateManyWithoutUserNestedInput
    sellingHoursReports?: SellingHoursReportsUpdateManyWithoutUserNestedInput
    parking?: ParkingUpdateManyWithoutUserNestedInput
    userReports?: UserHoursReportsUpdateManyWithoutUserNestedInput
    paidInfractions?: InfractionUpdateManyWithoutPayedByUserNestedInput
    receivedHoursSales?: SellingHoursReportsUpdateManyWithoutTargetUserNestedInput
    bookings?: BookingUpdateManyWithoutCustomerNestedInput
    soldBookings?: BookingUpdateManyWithoutSoldByNestedInput
    seatHolds?: SeatHoldUpdateManyWithoutUserNestedInput
    cinemaCredits?: CinemaCreditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserParkingReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
    patents?: PatentUncheckedUpdateManyWithoutUserNestedInput
    deletedPatent?: DeletedPatentsUncheckedUpdateManyWithoutUserNestedInput
    sellPoint?: SellPointUncheckedUpdateManyWithoutUserNestedInput
    sellingHoursReports?: SellingHoursReportsUncheckedUpdateManyWithoutUserNestedInput
    parking?: ParkingUncheckedUpdateManyWithoutUserNestedInput
    userReports?: UserHoursReportsUncheckedUpdateManyWithoutUserNestedInput
    paidInfractions?: InfractionUncheckedUpdateManyWithoutPayedByUserNestedInput
    receivedHoursSales?: SellingHoursReportsUncheckedUpdateManyWithoutTargetUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutCustomerNestedInput
    soldBookings?: BookingUncheckedUpdateManyWithoutSoldByNestedInput
    seatHolds?: SeatHoldUncheckedUpdateManyWithoutUserNestedInput
    cinemaCredits?: CinemaCreditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutParkingInput = {
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
    patents?: PatentCreateNestedManyWithoutUserInput
    deletedPatent?: DeletedPatentsCreateNestedManyWithoutUserInput
    sellPoint?: SellPointCreateNestedManyWithoutUserInput
    sellingHoursReports?: SellingHoursReportsCreateNestedManyWithoutUserInput
    userReports?: UserHoursReportsCreateNestedManyWithoutUserInput
    userParkingReports?: UserParkingReportsCreateNestedManyWithoutUserInput
    paidInfractions?: InfractionCreateNestedManyWithoutPayedByUserInput
    receivedHoursSales?: SellingHoursReportsCreateNestedManyWithoutTargetUserInput
    bookings?: BookingCreateNestedManyWithoutCustomerInput
    soldBookings?: BookingCreateNestedManyWithoutSoldByInput
    seatHolds?: SeatHoldCreateNestedManyWithoutUserInput
    cinemaCredits?: CinemaCreditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutParkingInput = {
    id?: number
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
    patents?: PatentUncheckedCreateNestedManyWithoutUserInput
    deletedPatent?: DeletedPatentsUncheckedCreateNestedManyWithoutUserInput
    sellPoint?: SellPointUncheckedCreateNestedManyWithoutUserInput
    sellingHoursReports?: SellingHoursReportsUncheckedCreateNestedManyWithoutUserInput
    userReports?: UserHoursReportsUncheckedCreateNestedManyWithoutUserInput
    userParkingReports?: UserParkingReportsUncheckedCreateNestedManyWithoutUserInput
    paidInfractions?: InfractionUncheckedCreateNestedManyWithoutPayedByUserInput
    receivedHoursSales?: SellingHoursReportsUncheckedCreateNestedManyWithoutTargetUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutCustomerInput
    soldBookings?: BookingUncheckedCreateNestedManyWithoutSoldByInput
    seatHolds?: SeatHoldUncheckedCreateNestedManyWithoutUserInput
    cinemaCredits?: CinemaCreditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutParkingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutParkingInput, UserUncheckedCreateWithoutParkingInput>
  }

  export type UserUpsertWithoutParkingInput = {
    update: XOR<UserUpdateWithoutParkingInput, UserUncheckedUpdateWithoutParkingInput>
    create: XOR<UserCreateWithoutParkingInput, UserUncheckedCreateWithoutParkingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutParkingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutParkingInput, UserUncheckedUpdateWithoutParkingInput>
  }

  export type UserUpdateWithoutParkingInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
    patents?: PatentUpdateManyWithoutUserNestedInput
    deletedPatent?: DeletedPatentsUpdateManyWithoutUserNestedInput
    sellPoint?: SellPointUpdateManyWithoutUserNestedInput
    sellingHoursReports?: SellingHoursReportsUpdateManyWithoutUserNestedInput
    userReports?: UserHoursReportsUpdateManyWithoutUserNestedInput
    userParkingReports?: UserParkingReportsUpdateManyWithoutUserNestedInput
    paidInfractions?: InfractionUpdateManyWithoutPayedByUserNestedInput
    receivedHoursSales?: SellingHoursReportsUpdateManyWithoutTargetUserNestedInput
    bookings?: BookingUpdateManyWithoutCustomerNestedInput
    soldBookings?: BookingUpdateManyWithoutSoldByNestedInput
    seatHolds?: SeatHoldUpdateManyWithoutUserNestedInput
    cinemaCredits?: CinemaCreditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutParkingInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
    patents?: PatentUncheckedUpdateManyWithoutUserNestedInput
    deletedPatent?: DeletedPatentsUncheckedUpdateManyWithoutUserNestedInput
    sellPoint?: SellPointUncheckedUpdateManyWithoutUserNestedInput
    sellingHoursReports?: SellingHoursReportsUncheckedUpdateManyWithoutUserNestedInput
    userReports?: UserHoursReportsUncheckedUpdateManyWithoutUserNestedInput
    userParkingReports?: UserParkingReportsUncheckedUpdateManyWithoutUserNestedInput
    paidInfractions?: InfractionUncheckedUpdateManyWithoutPayedByUserNestedInput
    receivedHoursSales?: SellingHoursReportsUncheckedUpdateManyWithoutTargetUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutCustomerNestedInput
    soldBookings?: BookingUncheckedUpdateManyWithoutSoldByNestedInput
    seatHolds?: SeatHoldUncheckedUpdateManyWithoutUserNestedInput
    cinemaCredits?: CinemaCreditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InfractionImageCreateWithoutInfractionInput = {
    id?: string
    url: string
    createdAt?: Date | string
  }

  export type InfractionImageUncheckedCreateWithoutInfractionInput = {
    id?: string
    url: string
    createdAt?: Date | string
  }

  export type InfractionImageCreateOrConnectWithoutInfractionInput = {
    where: InfractionImageWhereUniqueInput
    create: XOR<InfractionImageCreateWithoutInfractionInput, InfractionImageUncheckedCreateWithoutInfractionInput>
  }

  export type InfractionImageCreateManyInfractionInputEnvelope = {
    data: InfractionImageCreateManyInfractionInput | InfractionImageCreateManyInfractionInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutPaidInfractionsInput = {
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
    patents?: PatentCreateNestedManyWithoutUserInput
    deletedPatent?: DeletedPatentsCreateNestedManyWithoutUserInput
    sellPoint?: SellPointCreateNestedManyWithoutUserInput
    sellingHoursReports?: SellingHoursReportsCreateNestedManyWithoutUserInput
    parking?: ParkingCreateNestedManyWithoutUserInput
    userReports?: UserHoursReportsCreateNestedManyWithoutUserInput
    userParkingReports?: UserParkingReportsCreateNestedManyWithoutUserInput
    receivedHoursSales?: SellingHoursReportsCreateNestedManyWithoutTargetUserInput
    bookings?: BookingCreateNestedManyWithoutCustomerInput
    soldBookings?: BookingCreateNestedManyWithoutSoldByInput
    seatHolds?: SeatHoldCreateNestedManyWithoutUserInput
    cinemaCredits?: CinemaCreditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaidInfractionsInput = {
    id?: number
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
    patents?: PatentUncheckedCreateNestedManyWithoutUserInput
    deletedPatent?: DeletedPatentsUncheckedCreateNestedManyWithoutUserInput
    sellPoint?: SellPointUncheckedCreateNestedManyWithoutUserInput
    sellingHoursReports?: SellingHoursReportsUncheckedCreateNestedManyWithoutUserInput
    parking?: ParkingUncheckedCreateNestedManyWithoutUserInput
    userReports?: UserHoursReportsUncheckedCreateNestedManyWithoutUserInput
    userParkingReports?: UserParkingReportsUncheckedCreateNestedManyWithoutUserInput
    receivedHoursSales?: SellingHoursReportsUncheckedCreateNestedManyWithoutTargetUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutCustomerInput
    soldBookings?: BookingUncheckedCreateNestedManyWithoutSoldByInput
    seatHolds?: SeatHoldUncheckedCreateNestedManyWithoutUserInput
    cinemaCredits?: CinemaCreditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaidInfractionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaidInfractionsInput, UserUncheckedCreateWithoutPaidInfractionsInput>
  }

  export type InfractionImageUpsertWithWhereUniqueWithoutInfractionInput = {
    where: InfractionImageWhereUniqueInput
    update: XOR<InfractionImageUpdateWithoutInfractionInput, InfractionImageUncheckedUpdateWithoutInfractionInput>
    create: XOR<InfractionImageCreateWithoutInfractionInput, InfractionImageUncheckedCreateWithoutInfractionInput>
  }

  export type InfractionImageUpdateWithWhereUniqueWithoutInfractionInput = {
    where: InfractionImageWhereUniqueInput
    data: XOR<InfractionImageUpdateWithoutInfractionInput, InfractionImageUncheckedUpdateWithoutInfractionInput>
  }

  export type InfractionImageUpdateManyWithWhereWithoutInfractionInput = {
    where: InfractionImageScalarWhereInput
    data: XOR<InfractionImageUpdateManyMutationInput, InfractionImageUncheckedUpdateManyWithoutInfractionInput>
  }

  export type InfractionImageScalarWhereInput = {
    AND?: InfractionImageScalarWhereInput | InfractionImageScalarWhereInput[]
    OR?: InfractionImageScalarWhereInput[]
    NOT?: InfractionImageScalarWhereInput | InfractionImageScalarWhereInput[]
    id?: StringFilter<"InfractionImage"> | string
    url?: StringFilter<"InfractionImage"> | string
    infractionId?: StringFilter<"InfractionImage"> | string
    createdAt?: DateTimeFilter<"InfractionImage"> | Date | string
  }

  export type UserUpsertWithoutPaidInfractionsInput = {
    update: XOR<UserUpdateWithoutPaidInfractionsInput, UserUncheckedUpdateWithoutPaidInfractionsInput>
    create: XOR<UserCreateWithoutPaidInfractionsInput, UserUncheckedCreateWithoutPaidInfractionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaidInfractionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaidInfractionsInput, UserUncheckedUpdateWithoutPaidInfractionsInput>
  }

  export type UserUpdateWithoutPaidInfractionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
    patents?: PatentUpdateManyWithoutUserNestedInput
    deletedPatent?: DeletedPatentsUpdateManyWithoutUserNestedInput
    sellPoint?: SellPointUpdateManyWithoutUserNestedInput
    sellingHoursReports?: SellingHoursReportsUpdateManyWithoutUserNestedInput
    parking?: ParkingUpdateManyWithoutUserNestedInput
    userReports?: UserHoursReportsUpdateManyWithoutUserNestedInput
    userParkingReports?: UserParkingReportsUpdateManyWithoutUserNestedInput
    receivedHoursSales?: SellingHoursReportsUpdateManyWithoutTargetUserNestedInput
    bookings?: BookingUpdateManyWithoutCustomerNestedInput
    soldBookings?: BookingUpdateManyWithoutSoldByNestedInput
    seatHolds?: SeatHoldUpdateManyWithoutUserNestedInput
    cinemaCredits?: CinemaCreditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaidInfractionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
    patents?: PatentUncheckedUpdateManyWithoutUserNestedInput
    deletedPatent?: DeletedPatentsUncheckedUpdateManyWithoutUserNestedInput
    sellPoint?: SellPointUncheckedUpdateManyWithoutUserNestedInput
    sellingHoursReports?: SellingHoursReportsUncheckedUpdateManyWithoutUserNestedInput
    parking?: ParkingUncheckedUpdateManyWithoutUserNestedInput
    userReports?: UserHoursReportsUncheckedUpdateManyWithoutUserNestedInput
    userParkingReports?: UserParkingReportsUncheckedUpdateManyWithoutUserNestedInput
    receivedHoursSales?: SellingHoursReportsUncheckedUpdateManyWithoutTargetUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutCustomerNestedInput
    soldBookings?: BookingUncheckedUpdateManyWithoutSoldByNestedInput
    seatHolds?: SeatHoldUncheckedUpdateManyWithoutUserNestedInput
    cinemaCredits?: CinemaCreditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InfractionCreateWithoutImagesInput = {
    id?: string
    numberId?: number
    createdAt: Date | string
    cancelled?: boolean
    cancelledAt?: Date | string | null
    cancelledReason?: string | null
    patentId: string
    street?: string | null
    payed: boolean
    payedAt?: Date | string | null
    isEnableToPay?: boolean | null
    paymentMethod?: string | null
    payedByUser?: UserCreateNestedOneWithoutPaidInfractionsInput
  }

  export type InfractionUncheckedCreateWithoutImagesInput = {
    id?: string
    numberId?: number
    createdAt: Date | string
    cancelled?: boolean
    cancelledAt?: Date | string | null
    cancelledReason?: string | null
    patentId: string
    street?: string | null
    payed: boolean
    payedAt?: Date | string | null
    isEnableToPay?: boolean | null
    paymentMethod?: string | null
    payedByUserId?: number | null
  }

  export type InfractionCreateOrConnectWithoutImagesInput = {
    where: InfractionWhereUniqueInput
    create: XOR<InfractionCreateWithoutImagesInput, InfractionUncheckedCreateWithoutImagesInput>
  }

  export type InfractionUpsertWithoutImagesInput = {
    update: XOR<InfractionUpdateWithoutImagesInput, InfractionUncheckedUpdateWithoutImagesInput>
    create: XOR<InfractionCreateWithoutImagesInput, InfractionUncheckedCreateWithoutImagesInput>
    where?: InfractionWhereInput
  }

  export type InfractionUpdateToOneWithWhereWithoutImagesInput = {
    where?: InfractionWhereInput
    data: XOR<InfractionUpdateWithoutImagesInput, InfractionUncheckedUpdateWithoutImagesInput>
  }

  export type InfractionUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledReason?: NullableStringFieldUpdateOperationsInput | string | null
    patentId?: StringFieldUpdateOperationsInput | string
    street?: NullableStringFieldUpdateOperationsInput | string | null
    payed?: BoolFieldUpdateOperationsInput | boolean
    payedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEnableToPay?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    payedByUser?: UserUpdateOneWithoutPaidInfractionsNestedInput
  }

  export type InfractionUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    numberId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledReason?: NullableStringFieldUpdateOperationsInput | string | null
    patentId?: StringFieldUpdateOperationsInput | string
    street?: NullableStringFieldUpdateOperationsInput | string | null
    payed?: BoolFieldUpdateOperationsInput | boolean
    payedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEnableToPay?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    payedByUserId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ShowingCreateWithoutMovieInput = {
    id?: string
    startTime: Date | string
    priceCents: number
    rows: number
    seatsPerRow: number
    totalSeats: number
    status?: $Enums.ShowingStatus
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    seats?: SeatCreateNestedManyWithoutShowingInput
    seatHolds?: SeatHoldCreateNestedManyWithoutShowingInput
    credits?: CinemaCreditCreateNestedManyWithoutShowingInput
  }

  export type ShowingUncheckedCreateWithoutMovieInput = {
    id?: string
    startTime: Date | string
    priceCents: number
    rows: number
    seatsPerRow: number
    totalSeats: number
    status?: $Enums.ShowingStatus
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    seats?: SeatUncheckedCreateNestedManyWithoutShowingInput
    seatHolds?: SeatHoldUncheckedCreateNestedManyWithoutShowingInput
    credits?: CinemaCreditUncheckedCreateNestedManyWithoutShowingInput
  }

  export type ShowingCreateOrConnectWithoutMovieInput = {
    where: ShowingWhereUniqueInput
    create: XOR<ShowingCreateWithoutMovieInput, ShowingUncheckedCreateWithoutMovieInput>
  }

  export type ShowingCreateManyMovieInputEnvelope = {
    data: ShowingCreateManyMovieInput | ShowingCreateManyMovieInput[]
    skipDuplicates?: boolean
  }

  export type ShowingUpsertWithWhereUniqueWithoutMovieInput = {
    where: ShowingWhereUniqueInput
    update: XOR<ShowingUpdateWithoutMovieInput, ShowingUncheckedUpdateWithoutMovieInput>
    create: XOR<ShowingCreateWithoutMovieInput, ShowingUncheckedCreateWithoutMovieInput>
  }

  export type ShowingUpdateWithWhereUniqueWithoutMovieInput = {
    where: ShowingWhereUniqueInput
    data: XOR<ShowingUpdateWithoutMovieInput, ShowingUncheckedUpdateWithoutMovieInput>
  }

  export type ShowingUpdateManyWithWhereWithoutMovieInput = {
    where: ShowingScalarWhereInput
    data: XOR<ShowingUpdateManyMutationInput, ShowingUncheckedUpdateManyWithoutMovieInput>
  }

  export type ShowingScalarWhereInput = {
    AND?: ShowingScalarWhereInput | ShowingScalarWhereInput[]
    OR?: ShowingScalarWhereInput[]
    NOT?: ShowingScalarWhereInput | ShowingScalarWhereInput[]
    id?: StringFilter<"Showing"> | string
    movieId?: StringFilter<"Showing"> | string
    startTime?: DateTimeFilter<"Showing"> | Date | string
    priceCents?: IntFilter<"Showing"> | number
    rows?: IntFilter<"Showing"> | number
    seatsPerRow?: IntFilter<"Showing"> | number
    totalSeats?: IntFilter<"Showing"> | number
    status?: EnumShowingStatusFilter<"Showing"> | $Enums.ShowingStatus
    cancelledAt?: DateTimeNullableFilter<"Showing"> | Date | string | null
    createdAt?: DateTimeFilter<"Showing"> | Date | string
  }

  export type MovieCreateWithoutShowingsInput = {
    id?: string
    title: string
    description: string
    durationMinutes: number
    language: string
    format: $Enums.Format
    posterUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MovieUncheckedCreateWithoutShowingsInput = {
    id?: string
    title: string
    description: string
    durationMinutes: number
    language: string
    format: $Enums.Format
    posterUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MovieCreateOrConnectWithoutShowingsInput = {
    where: MovieWhereUniqueInput
    create: XOR<MovieCreateWithoutShowingsInput, MovieUncheckedCreateWithoutShowingsInput>
  }

  export type SeatCreateWithoutShowingInput = {
    id?: string
    rowLabel: string
    number: number
    status?: $Enums.SeatStatus
    createdAt?: Date | string
    tickets?: TicketCreateNestedManyWithoutSeatInput
    hold?: SeatHoldCreateNestedOneWithoutSeatInput
  }

  export type SeatUncheckedCreateWithoutShowingInput = {
    id?: string
    rowLabel: string
    number: number
    status?: $Enums.SeatStatus
    createdAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutSeatInput
    hold?: SeatHoldUncheckedCreateNestedOneWithoutSeatInput
  }

  export type SeatCreateOrConnectWithoutShowingInput = {
    where: SeatWhereUniqueInput
    create: XOR<SeatCreateWithoutShowingInput, SeatUncheckedCreateWithoutShowingInput>
  }

  export type SeatCreateManyShowingInputEnvelope = {
    data: SeatCreateManyShowingInput | SeatCreateManyShowingInput[]
    skipDuplicates?: boolean
  }

  export type SeatHoldCreateWithoutShowingInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    seat: SeatCreateNestedOneWithoutHoldInput
    user: UserCreateNestedOneWithoutSeatHoldsInput
  }

  export type SeatHoldUncheckedCreateWithoutShowingInput = {
    id?: string
    seatId: string
    userId: number
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type SeatHoldCreateOrConnectWithoutShowingInput = {
    where: SeatHoldWhereUniqueInput
    create: XOR<SeatHoldCreateWithoutShowingInput, SeatHoldUncheckedCreateWithoutShowingInput>
  }

  export type SeatHoldCreateManyShowingInputEnvelope = {
    data: SeatHoldCreateManyShowingInput | SeatHoldCreateManyShowingInput[]
    skipDuplicates?: boolean
  }

  export type CinemaCreditCreateWithoutShowingInput = {
    id?: string
    amountCents: number
    remainingCents: number
    reason: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutCinemaCreditsInput
    booking?: BookingCreateNestedOneWithoutCreditsInput
  }

  export type CinemaCreditUncheckedCreateWithoutShowingInput = {
    id?: string
    userId: number
    bookingId?: string | null
    amountCents: number
    remainingCents: number
    reason: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type CinemaCreditCreateOrConnectWithoutShowingInput = {
    where: CinemaCreditWhereUniqueInput
    create: XOR<CinemaCreditCreateWithoutShowingInput, CinemaCreditUncheckedCreateWithoutShowingInput>
  }

  export type CinemaCreditCreateManyShowingInputEnvelope = {
    data: CinemaCreditCreateManyShowingInput | CinemaCreditCreateManyShowingInput[]
    skipDuplicates?: boolean
  }

  export type MovieUpsertWithoutShowingsInput = {
    update: XOR<MovieUpdateWithoutShowingsInput, MovieUncheckedUpdateWithoutShowingsInput>
    create: XOR<MovieCreateWithoutShowingsInput, MovieUncheckedCreateWithoutShowingsInput>
    where?: MovieWhereInput
  }

  export type MovieUpdateToOneWithWhereWithoutShowingsInput = {
    where?: MovieWhereInput
    data: XOR<MovieUpdateWithoutShowingsInput, MovieUncheckedUpdateWithoutShowingsInput>
  }

  export type MovieUpdateWithoutShowingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    format?: EnumFormatFieldUpdateOperationsInput | $Enums.Format
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieUncheckedUpdateWithoutShowingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    format?: EnumFormatFieldUpdateOperationsInput | $Enums.Format
    posterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatUpsertWithWhereUniqueWithoutShowingInput = {
    where: SeatWhereUniqueInput
    update: XOR<SeatUpdateWithoutShowingInput, SeatUncheckedUpdateWithoutShowingInput>
    create: XOR<SeatCreateWithoutShowingInput, SeatUncheckedCreateWithoutShowingInput>
  }

  export type SeatUpdateWithWhereUniqueWithoutShowingInput = {
    where: SeatWhereUniqueInput
    data: XOR<SeatUpdateWithoutShowingInput, SeatUncheckedUpdateWithoutShowingInput>
  }

  export type SeatUpdateManyWithWhereWithoutShowingInput = {
    where: SeatScalarWhereInput
    data: XOR<SeatUpdateManyMutationInput, SeatUncheckedUpdateManyWithoutShowingInput>
  }

  export type SeatScalarWhereInput = {
    AND?: SeatScalarWhereInput | SeatScalarWhereInput[]
    OR?: SeatScalarWhereInput[]
    NOT?: SeatScalarWhereInput | SeatScalarWhereInput[]
    id?: StringFilter<"Seat"> | string
    showingId?: StringFilter<"Seat"> | string
    rowLabel?: StringFilter<"Seat"> | string
    number?: IntFilter<"Seat"> | number
    status?: EnumSeatStatusFilter<"Seat"> | $Enums.SeatStatus
    createdAt?: DateTimeFilter<"Seat"> | Date | string
  }

  export type SeatHoldUpsertWithWhereUniqueWithoutShowingInput = {
    where: SeatHoldWhereUniqueInput
    update: XOR<SeatHoldUpdateWithoutShowingInput, SeatHoldUncheckedUpdateWithoutShowingInput>
    create: XOR<SeatHoldCreateWithoutShowingInput, SeatHoldUncheckedCreateWithoutShowingInput>
  }

  export type SeatHoldUpdateWithWhereUniqueWithoutShowingInput = {
    where: SeatHoldWhereUniqueInput
    data: XOR<SeatHoldUpdateWithoutShowingInput, SeatHoldUncheckedUpdateWithoutShowingInput>
  }

  export type SeatHoldUpdateManyWithWhereWithoutShowingInput = {
    where: SeatHoldScalarWhereInput
    data: XOR<SeatHoldUpdateManyMutationInput, SeatHoldUncheckedUpdateManyWithoutShowingInput>
  }

  export type CinemaCreditUpsertWithWhereUniqueWithoutShowingInput = {
    where: CinemaCreditWhereUniqueInput
    update: XOR<CinemaCreditUpdateWithoutShowingInput, CinemaCreditUncheckedUpdateWithoutShowingInput>
    create: XOR<CinemaCreditCreateWithoutShowingInput, CinemaCreditUncheckedCreateWithoutShowingInput>
  }

  export type CinemaCreditUpdateWithWhereUniqueWithoutShowingInput = {
    where: CinemaCreditWhereUniqueInput
    data: XOR<CinemaCreditUpdateWithoutShowingInput, CinemaCreditUncheckedUpdateWithoutShowingInput>
  }

  export type CinemaCreditUpdateManyWithWhereWithoutShowingInput = {
    where: CinemaCreditScalarWhereInput
    data: XOR<CinemaCreditUpdateManyMutationInput, CinemaCreditUncheckedUpdateManyWithoutShowingInput>
  }

  export type ShowingCreateWithoutSeatsInput = {
    id?: string
    startTime: Date | string
    priceCents: number
    rows: number
    seatsPerRow: number
    totalSeats: number
    status?: $Enums.ShowingStatus
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    movie: MovieCreateNestedOneWithoutShowingsInput
    seatHolds?: SeatHoldCreateNestedManyWithoutShowingInput
    credits?: CinemaCreditCreateNestedManyWithoutShowingInput
  }

  export type ShowingUncheckedCreateWithoutSeatsInput = {
    id?: string
    movieId: string
    startTime: Date | string
    priceCents: number
    rows: number
    seatsPerRow: number
    totalSeats: number
    status?: $Enums.ShowingStatus
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    seatHolds?: SeatHoldUncheckedCreateNestedManyWithoutShowingInput
    credits?: CinemaCreditUncheckedCreateNestedManyWithoutShowingInput
  }

  export type ShowingCreateOrConnectWithoutSeatsInput = {
    where: ShowingWhereUniqueInput
    create: XOR<ShowingCreateWithoutSeatsInput, ShowingUncheckedCreateWithoutSeatsInput>
  }

  export type TicketCreateWithoutSeatInput = {
    id?: string
    qrToken: string
    checkedInAt?: Date | string | null
    createdAt?: Date | string
    booking: BookingCreateNestedOneWithoutTicketsInput
  }

  export type TicketUncheckedCreateWithoutSeatInput = {
    id?: string
    bookingId: string
    qrToken: string
    checkedInAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TicketCreateOrConnectWithoutSeatInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutSeatInput, TicketUncheckedCreateWithoutSeatInput>
  }

  export type TicketCreateManySeatInputEnvelope = {
    data: TicketCreateManySeatInput | TicketCreateManySeatInput[]
    skipDuplicates?: boolean
  }

  export type SeatHoldCreateWithoutSeatInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    showing: ShowingCreateNestedOneWithoutSeatHoldsInput
    user: UserCreateNestedOneWithoutSeatHoldsInput
  }

  export type SeatHoldUncheckedCreateWithoutSeatInput = {
    id?: string
    showingId: string
    userId: number
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type SeatHoldCreateOrConnectWithoutSeatInput = {
    where: SeatHoldWhereUniqueInput
    create: XOR<SeatHoldCreateWithoutSeatInput, SeatHoldUncheckedCreateWithoutSeatInput>
  }

  export type ShowingUpsertWithoutSeatsInput = {
    update: XOR<ShowingUpdateWithoutSeatsInput, ShowingUncheckedUpdateWithoutSeatsInput>
    create: XOR<ShowingCreateWithoutSeatsInput, ShowingUncheckedCreateWithoutSeatsInput>
    where?: ShowingWhereInput
  }

  export type ShowingUpdateToOneWithWhereWithoutSeatsInput = {
    where?: ShowingWhereInput
    data: XOR<ShowingUpdateWithoutSeatsInput, ShowingUncheckedUpdateWithoutSeatsInput>
  }

  export type ShowingUpdateWithoutSeatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    priceCents?: IntFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    seatsPerRow?: IntFieldUpdateOperationsInput | number
    totalSeats?: IntFieldUpdateOperationsInput | number
    status?: EnumShowingStatusFieldUpdateOperationsInput | $Enums.ShowingStatus
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movie?: MovieUpdateOneRequiredWithoutShowingsNestedInput
    seatHolds?: SeatHoldUpdateManyWithoutShowingNestedInput
    credits?: CinemaCreditUpdateManyWithoutShowingNestedInput
  }

  export type ShowingUncheckedUpdateWithoutSeatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    priceCents?: IntFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    seatsPerRow?: IntFieldUpdateOperationsInput | number
    totalSeats?: IntFieldUpdateOperationsInput | number
    status?: EnumShowingStatusFieldUpdateOperationsInput | $Enums.ShowingStatus
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seatHolds?: SeatHoldUncheckedUpdateManyWithoutShowingNestedInput
    credits?: CinemaCreditUncheckedUpdateManyWithoutShowingNestedInput
  }

  export type TicketUpsertWithWhereUniqueWithoutSeatInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutSeatInput, TicketUncheckedUpdateWithoutSeatInput>
    create: XOR<TicketCreateWithoutSeatInput, TicketUncheckedCreateWithoutSeatInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutSeatInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutSeatInput, TicketUncheckedUpdateWithoutSeatInput>
  }

  export type TicketUpdateManyWithWhereWithoutSeatInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutSeatInput>
  }

  export type TicketScalarWhereInput = {
    AND?: TicketScalarWhereInput | TicketScalarWhereInput[]
    OR?: TicketScalarWhereInput[]
    NOT?: TicketScalarWhereInput | TicketScalarWhereInput[]
    id?: StringFilter<"Ticket"> | string
    bookingId?: StringFilter<"Ticket"> | string
    seatId?: StringFilter<"Ticket"> | string
    qrToken?: StringFilter<"Ticket"> | string
    checkedInAt?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
  }

  export type SeatHoldUpsertWithoutSeatInput = {
    update: XOR<SeatHoldUpdateWithoutSeatInput, SeatHoldUncheckedUpdateWithoutSeatInput>
    create: XOR<SeatHoldCreateWithoutSeatInput, SeatHoldUncheckedCreateWithoutSeatInput>
    where?: SeatHoldWhereInput
  }

  export type SeatHoldUpdateToOneWithWhereWithoutSeatInput = {
    where?: SeatHoldWhereInput
    data: XOR<SeatHoldUpdateWithoutSeatInput, SeatHoldUncheckedUpdateWithoutSeatInput>
  }

  export type SeatHoldUpdateWithoutSeatInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    showing?: ShowingUpdateOneRequiredWithoutSeatHoldsNestedInput
    user?: UserUpdateOneRequiredWithoutSeatHoldsNestedInput
  }

  export type SeatHoldUncheckedUpdateWithoutSeatInput = {
    id?: StringFieldUpdateOperationsInput | string
    showingId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatCreateWithoutHoldInput = {
    id?: string
    rowLabel: string
    number: number
    status?: $Enums.SeatStatus
    createdAt?: Date | string
    showing: ShowingCreateNestedOneWithoutSeatsInput
    tickets?: TicketCreateNestedManyWithoutSeatInput
  }

  export type SeatUncheckedCreateWithoutHoldInput = {
    id?: string
    showingId: string
    rowLabel: string
    number: number
    status?: $Enums.SeatStatus
    createdAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutSeatInput
  }

  export type SeatCreateOrConnectWithoutHoldInput = {
    where: SeatWhereUniqueInput
    create: XOR<SeatCreateWithoutHoldInput, SeatUncheckedCreateWithoutHoldInput>
  }

  export type ShowingCreateWithoutSeatHoldsInput = {
    id?: string
    startTime: Date | string
    priceCents: number
    rows: number
    seatsPerRow: number
    totalSeats: number
    status?: $Enums.ShowingStatus
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    movie: MovieCreateNestedOneWithoutShowingsInput
    seats?: SeatCreateNestedManyWithoutShowingInput
    credits?: CinemaCreditCreateNestedManyWithoutShowingInput
  }

  export type ShowingUncheckedCreateWithoutSeatHoldsInput = {
    id?: string
    movieId: string
    startTime: Date | string
    priceCents: number
    rows: number
    seatsPerRow: number
    totalSeats: number
    status?: $Enums.ShowingStatus
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    seats?: SeatUncheckedCreateNestedManyWithoutShowingInput
    credits?: CinemaCreditUncheckedCreateNestedManyWithoutShowingInput
  }

  export type ShowingCreateOrConnectWithoutSeatHoldsInput = {
    where: ShowingWhereUniqueInput
    create: XOR<ShowingCreateWithoutSeatHoldsInput, ShowingUncheckedCreateWithoutSeatHoldsInput>
  }

  export type UserCreateWithoutSeatHoldsInput = {
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
    patents?: PatentCreateNestedManyWithoutUserInput
    deletedPatent?: DeletedPatentsCreateNestedManyWithoutUserInput
    sellPoint?: SellPointCreateNestedManyWithoutUserInput
    sellingHoursReports?: SellingHoursReportsCreateNestedManyWithoutUserInput
    parking?: ParkingCreateNestedManyWithoutUserInput
    userReports?: UserHoursReportsCreateNestedManyWithoutUserInput
    userParkingReports?: UserParkingReportsCreateNestedManyWithoutUserInput
    paidInfractions?: InfractionCreateNestedManyWithoutPayedByUserInput
    receivedHoursSales?: SellingHoursReportsCreateNestedManyWithoutTargetUserInput
    bookings?: BookingCreateNestedManyWithoutCustomerInput
    soldBookings?: BookingCreateNestedManyWithoutSoldByInput
    cinemaCredits?: CinemaCreditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSeatHoldsInput = {
    id?: number
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
    patents?: PatentUncheckedCreateNestedManyWithoutUserInput
    deletedPatent?: DeletedPatentsUncheckedCreateNestedManyWithoutUserInput
    sellPoint?: SellPointUncheckedCreateNestedManyWithoutUserInput
    sellingHoursReports?: SellingHoursReportsUncheckedCreateNestedManyWithoutUserInput
    parking?: ParkingUncheckedCreateNestedManyWithoutUserInput
    userReports?: UserHoursReportsUncheckedCreateNestedManyWithoutUserInput
    userParkingReports?: UserParkingReportsUncheckedCreateNestedManyWithoutUserInput
    paidInfractions?: InfractionUncheckedCreateNestedManyWithoutPayedByUserInput
    receivedHoursSales?: SellingHoursReportsUncheckedCreateNestedManyWithoutTargetUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutCustomerInput
    soldBookings?: BookingUncheckedCreateNestedManyWithoutSoldByInput
    cinemaCredits?: CinemaCreditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSeatHoldsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSeatHoldsInput, UserUncheckedCreateWithoutSeatHoldsInput>
  }

  export type SeatUpsertWithoutHoldInput = {
    update: XOR<SeatUpdateWithoutHoldInput, SeatUncheckedUpdateWithoutHoldInput>
    create: XOR<SeatCreateWithoutHoldInput, SeatUncheckedCreateWithoutHoldInput>
    where?: SeatWhereInput
  }

  export type SeatUpdateToOneWithWhereWithoutHoldInput = {
    where?: SeatWhereInput
    data: XOR<SeatUpdateWithoutHoldInput, SeatUncheckedUpdateWithoutHoldInput>
  }

  export type SeatUpdateWithoutHoldInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowLabel?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    showing?: ShowingUpdateOneRequiredWithoutSeatsNestedInput
    tickets?: TicketUpdateManyWithoutSeatNestedInput
  }

  export type SeatUncheckedUpdateWithoutHoldInput = {
    id?: StringFieldUpdateOperationsInput | string
    showingId?: StringFieldUpdateOperationsInput | string
    rowLabel?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutSeatNestedInput
  }

  export type ShowingUpsertWithoutSeatHoldsInput = {
    update: XOR<ShowingUpdateWithoutSeatHoldsInput, ShowingUncheckedUpdateWithoutSeatHoldsInput>
    create: XOR<ShowingCreateWithoutSeatHoldsInput, ShowingUncheckedCreateWithoutSeatHoldsInput>
    where?: ShowingWhereInput
  }

  export type ShowingUpdateToOneWithWhereWithoutSeatHoldsInput = {
    where?: ShowingWhereInput
    data: XOR<ShowingUpdateWithoutSeatHoldsInput, ShowingUncheckedUpdateWithoutSeatHoldsInput>
  }

  export type ShowingUpdateWithoutSeatHoldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    priceCents?: IntFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    seatsPerRow?: IntFieldUpdateOperationsInput | number
    totalSeats?: IntFieldUpdateOperationsInput | number
    status?: EnumShowingStatusFieldUpdateOperationsInput | $Enums.ShowingStatus
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movie?: MovieUpdateOneRequiredWithoutShowingsNestedInput
    seats?: SeatUpdateManyWithoutShowingNestedInput
    credits?: CinemaCreditUpdateManyWithoutShowingNestedInput
  }

  export type ShowingUncheckedUpdateWithoutSeatHoldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    priceCents?: IntFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    seatsPerRow?: IntFieldUpdateOperationsInput | number
    totalSeats?: IntFieldUpdateOperationsInput | number
    status?: EnumShowingStatusFieldUpdateOperationsInput | $Enums.ShowingStatus
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seats?: SeatUncheckedUpdateManyWithoutShowingNestedInput
    credits?: CinemaCreditUncheckedUpdateManyWithoutShowingNestedInput
  }

  export type UserUpsertWithoutSeatHoldsInput = {
    update: XOR<UserUpdateWithoutSeatHoldsInput, UserUncheckedUpdateWithoutSeatHoldsInput>
    create: XOR<UserCreateWithoutSeatHoldsInput, UserUncheckedCreateWithoutSeatHoldsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSeatHoldsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSeatHoldsInput, UserUncheckedUpdateWithoutSeatHoldsInput>
  }

  export type UserUpdateWithoutSeatHoldsInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
    patents?: PatentUpdateManyWithoutUserNestedInput
    deletedPatent?: DeletedPatentsUpdateManyWithoutUserNestedInput
    sellPoint?: SellPointUpdateManyWithoutUserNestedInput
    sellingHoursReports?: SellingHoursReportsUpdateManyWithoutUserNestedInput
    parking?: ParkingUpdateManyWithoutUserNestedInput
    userReports?: UserHoursReportsUpdateManyWithoutUserNestedInput
    userParkingReports?: UserParkingReportsUpdateManyWithoutUserNestedInput
    paidInfractions?: InfractionUpdateManyWithoutPayedByUserNestedInput
    receivedHoursSales?: SellingHoursReportsUpdateManyWithoutTargetUserNestedInput
    bookings?: BookingUpdateManyWithoutCustomerNestedInput
    soldBookings?: BookingUpdateManyWithoutSoldByNestedInput
    cinemaCredits?: CinemaCreditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSeatHoldsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
    patents?: PatentUncheckedUpdateManyWithoutUserNestedInput
    deletedPatent?: DeletedPatentsUncheckedUpdateManyWithoutUserNestedInput
    sellPoint?: SellPointUncheckedUpdateManyWithoutUserNestedInput
    sellingHoursReports?: SellingHoursReportsUncheckedUpdateManyWithoutUserNestedInput
    parking?: ParkingUncheckedUpdateManyWithoutUserNestedInput
    userReports?: UserHoursReportsUncheckedUpdateManyWithoutUserNestedInput
    userParkingReports?: UserParkingReportsUncheckedUpdateManyWithoutUserNestedInput
    paidInfractions?: InfractionUncheckedUpdateManyWithoutPayedByUserNestedInput
    receivedHoursSales?: SellingHoursReportsUncheckedUpdateManyWithoutTargetUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutCustomerNestedInput
    soldBookings?: BookingUncheckedUpdateManyWithoutSoldByNestedInput
    cinemaCredits?: CinemaCreditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutBookingsInput = {
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
    patents?: PatentCreateNestedManyWithoutUserInput
    deletedPatent?: DeletedPatentsCreateNestedManyWithoutUserInput
    sellPoint?: SellPointCreateNestedManyWithoutUserInput
    sellingHoursReports?: SellingHoursReportsCreateNestedManyWithoutUserInput
    parking?: ParkingCreateNestedManyWithoutUserInput
    userReports?: UserHoursReportsCreateNestedManyWithoutUserInput
    userParkingReports?: UserParkingReportsCreateNestedManyWithoutUserInput
    paidInfractions?: InfractionCreateNestedManyWithoutPayedByUserInput
    receivedHoursSales?: SellingHoursReportsCreateNestedManyWithoutTargetUserInput
    soldBookings?: BookingCreateNestedManyWithoutSoldByInput
    seatHolds?: SeatHoldCreateNestedManyWithoutUserInput
    cinemaCredits?: CinemaCreditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBookingsInput = {
    id?: number
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
    patents?: PatentUncheckedCreateNestedManyWithoutUserInput
    deletedPatent?: DeletedPatentsUncheckedCreateNestedManyWithoutUserInput
    sellPoint?: SellPointUncheckedCreateNestedManyWithoutUserInput
    sellingHoursReports?: SellingHoursReportsUncheckedCreateNestedManyWithoutUserInput
    parking?: ParkingUncheckedCreateNestedManyWithoutUserInput
    userReports?: UserHoursReportsUncheckedCreateNestedManyWithoutUserInput
    userParkingReports?: UserParkingReportsUncheckedCreateNestedManyWithoutUserInput
    paidInfractions?: InfractionUncheckedCreateNestedManyWithoutPayedByUserInput
    receivedHoursSales?: SellingHoursReportsUncheckedCreateNestedManyWithoutTargetUserInput
    soldBookings?: BookingUncheckedCreateNestedManyWithoutSoldByInput
    seatHolds?: SeatHoldUncheckedCreateNestedManyWithoutUserInput
    cinemaCredits?: CinemaCreditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
  }

  export type UserCreateWithoutSoldBookingsInput = {
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
    patents?: PatentCreateNestedManyWithoutUserInput
    deletedPatent?: DeletedPatentsCreateNestedManyWithoutUserInput
    sellPoint?: SellPointCreateNestedManyWithoutUserInput
    sellingHoursReports?: SellingHoursReportsCreateNestedManyWithoutUserInput
    parking?: ParkingCreateNestedManyWithoutUserInput
    userReports?: UserHoursReportsCreateNestedManyWithoutUserInput
    userParkingReports?: UserParkingReportsCreateNestedManyWithoutUserInput
    paidInfractions?: InfractionCreateNestedManyWithoutPayedByUserInput
    receivedHoursSales?: SellingHoursReportsCreateNestedManyWithoutTargetUserInput
    bookings?: BookingCreateNestedManyWithoutCustomerInput
    seatHolds?: SeatHoldCreateNestedManyWithoutUserInput
    cinemaCredits?: CinemaCreditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSoldBookingsInput = {
    id?: number
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
    patents?: PatentUncheckedCreateNestedManyWithoutUserInput
    deletedPatent?: DeletedPatentsUncheckedCreateNestedManyWithoutUserInput
    sellPoint?: SellPointUncheckedCreateNestedManyWithoutUserInput
    sellingHoursReports?: SellingHoursReportsUncheckedCreateNestedManyWithoutUserInput
    parking?: ParkingUncheckedCreateNestedManyWithoutUserInput
    userReports?: UserHoursReportsUncheckedCreateNestedManyWithoutUserInput
    userParkingReports?: UserParkingReportsUncheckedCreateNestedManyWithoutUserInput
    paidInfractions?: InfractionUncheckedCreateNestedManyWithoutPayedByUserInput
    receivedHoursSales?: SellingHoursReportsUncheckedCreateNestedManyWithoutTargetUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutCustomerInput
    seatHolds?: SeatHoldUncheckedCreateNestedManyWithoutUserInput
    cinemaCredits?: CinemaCreditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSoldBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSoldBookingsInput, UserUncheckedCreateWithoutSoldBookingsInput>
  }

  export type TicketCreateWithoutBookingInput = {
    id?: string
    qrToken: string
    checkedInAt?: Date | string | null
    createdAt?: Date | string
    seat: SeatCreateNestedOneWithoutTicketsInput
  }

  export type TicketUncheckedCreateWithoutBookingInput = {
    id?: string
    seatId: string
    qrToken: string
    checkedInAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TicketCreateOrConnectWithoutBookingInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutBookingInput, TicketUncheckedCreateWithoutBookingInput>
  }

  export type TicketCreateManyBookingInputEnvelope = {
    data: TicketCreateManyBookingInput | TicketCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type CinemaCreditCreateWithoutBookingInput = {
    id?: string
    amountCents: number
    remainingCents: number
    reason: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutCinemaCreditsInput
    showing?: ShowingCreateNestedOneWithoutCreditsInput
  }

  export type CinemaCreditUncheckedCreateWithoutBookingInput = {
    id?: string
    userId: number
    showingId?: string | null
    amountCents: number
    remainingCents: number
    reason: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type CinemaCreditCreateOrConnectWithoutBookingInput = {
    where: CinemaCreditWhereUniqueInput
    create: XOR<CinemaCreditCreateWithoutBookingInput, CinemaCreditUncheckedCreateWithoutBookingInput>
  }

  export type CinemaCreditCreateManyBookingInputEnvelope = {
    data: CinemaCreditCreateManyBookingInput | CinemaCreditCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBookingsInput = {
    update: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateWithoutBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
    patents?: PatentUpdateManyWithoutUserNestedInput
    deletedPatent?: DeletedPatentsUpdateManyWithoutUserNestedInput
    sellPoint?: SellPointUpdateManyWithoutUserNestedInput
    sellingHoursReports?: SellingHoursReportsUpdateManyWithoutUserNestedInput
    parking?: ParkingUpdateManyWithoutUserNestedInput
    userReports?: UserHoursReportsUpdateManyWithoutUserNestedInput
    userParkingReports?: UserParkingReportsUpdateManyWithoutUserNestedInput
    paidInfractions?: InfractionUpdateManyWithoutPayedByUserNestedInput
    receivedHoursSales?: SellingHoursReportsUpdateManyWithoutTargetUserNestedInput
    soldBookings?: BookingUpdateManyWithoutSoldByNestedInput
    seatHolds?: SeatHoldUpdateManyWithoutUserNestedInput
    cinemaCredits?: CinemaCreditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
    patents?: PatentUncheckedUpdateManyWithoutUserNestedInput
    deletedPatent?: DeletedPatentsUncheckedUpdateManyWithoutUserNestedInput
    sellPoint?: SellPointUncheckedUpdateManyWithoutUserNestedInput
    sellingHoursReports?: SellingHoursReportsUncheckedUpdateManyWithoutUserNestedInput
    parking?: ParkingUncheckedUpdateManyWithoutUserNestedInput
    userReports?: UserHoursReportsUncheckedUpdateManyWithoutUserNestedInput
    userParkingReports?: UserParkingReportsUncheckedUpdateManyWithoutUserNestedInput
    paidInfractions?: InfractionUncheckedUpdateManyWithoutPayedByUserNestedInput
    receivedHoursSales?: SellingHoursReportsUncheckedUpdateManyWithoutTargetUserNestedInput
    soldBookings?: BookingUncheckedUpdateManyWithoutSoldByNestedInput
    seatHolds?: SeatHoldUncheckedUpdateManyWithoutUserNestedInput
    cinemaCredits?: CinemaCreditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutSoldBookingsInput = {
    update: XOR<UserUpdateWithoutSoldBookingsInput, UserUncheckedUpdateWithoutSoldBookingsInput>
    create: XOR<UserCreateWithoutSoldBookingsInput, UserUncheckedCreateWithoutSoldBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSoldBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSoldBookingsInput, UserUncheckedUpdateWithoutSoldBookingsInput>
  }

  export type UserUpdateWithoutSoldBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
    patents?: PatentUpdateManyWithoutUserNestedInput
    deletedPatent?: DeletedPatentsUpdateManyWithoutUserNestedInput
    sellPoint?: SellPointUpdateManyWithoutUserNestedInput
    sellingHoursReports?: SellingHoursReportsUpdateManyWithoutUserNestedInput
    parking?: ParkingUpdateManyWithoutUserNestedInput
    userReports?: UserHoursReportsUpdateManyWithoutUserNestedInput
    userParkingReports?: UserParkingReportsUpdateManyWithoutUserNestedInput
    paidInfractions?: InfractionUpdateManyWithoutPayedByUserNestedInput
    receivedHoursSales?: SellingHoursReportsUpdateManyWithoutTargetUserNestedInput
    bookings?: BookingUpdateManyWithoutCustomerNestedInput
    seatHolds?: SeatHoldUpdateManyWithoutUserNestedInput
    cinemaCredits?: CinemaCreditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSoldBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
    patents?: PatentUncheckedUpdateManyWithoutUserNestedInput
    deletedPatent?: DeletedPatentsUncheckedUpdateManyWithoutUserNestedInput
    sellPoint?: SellPointUncheckedUpdateManyWithoutUserNestedInput
    sellingHoursReports?: SellingHoursReportsUncheckedUpdateManyWithoutUserNestedInput
    parking?: ParkingUncheckedUpdateManyWithoutUserNestedInput
    userReports?: UserHoursReportsUncheckedUpdateManyWithoutUserNestedInput
    userParkingReports?: UserParkingReportsUncheckedUpdateManyWithoutUserNestedInput
    paidInfractions?: InfractionUncheckedUpdateManyWithoutPayedByUserNestedInput
    receivedHoursSales?: SellingHoursReportsUncheckedUpdateManyWithoutTargetUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutCustomerNestedInput
    seatHolds?: SeatHoldUncheckedUpdateManyWithoutUserNestedInput
    cinemaCredits?: CinemaCreditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TicketUpsertWithWhereUniqueWithoutBookingInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutBookingInput, TicketUncheckedUpdateWithoutBookingInput>
    create: XOR<TicketCreateWithoutBookingInput, TicketUncheckedCreateWithoutBookingInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutBookingInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutBookingInput, TicketUncheckedUpdateWithoutBookingInput>
  }

  export type TicketUpdateManyWithWhereWithoutBookingInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutBookingInput>
  }

  export type CinemaCreditUpsertWithWhereUniqueWithoutBookingInput = {
    where: CinemaCreditWhereUniqueInput
    update: XOR<CinemaCreditUpdateWithoutBookingInput, CinemaCreditUncheckedUpdateWithoutBookingInput>
    create: XOR<CinemaCreditCreateWithoutBookingInput, CinemaCreditUncheckedCreateWithoutBookingInput>
  }

  export type CinemaCreditUpdateWithWhereUniqueWithoutBookingInput = {
    where: CinemaCreditWhereUniqueInput
    data: XOR<CinemaCreditUpdateWithoutBookingInput, CinemaCreditUncheckedUpdateWithoutBookingInput>
  }

  export type CinemaCreditUpdateManyWithWhereWithoutBookingInput = {
    where: CinemaCreditScalarWhereInput
    data: XOR<CinemaCreditUpdateManyMutationInput, CinemaCreditUncheckedUpdateManyWithoutBookingInput>
  }

  export type BookingCreateWithoutTicketsInput = {
    id?: string
    createdAt?: Date | string
    status: $Enums.BookingStatus
    channel: $Enums.PurchaseChannel
    totalPriceCents: number
    customerEmail?: string | null
    customer?: UserCreateNestedOneWithoutBookingsInput
    soldBy?: UserCreateNestedOneWithoutSoldBookingsInput
    credits?: CinemaCreditCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutTicketsInput = {
    id?: string
    createdAt?: Date | string
    status: $Enums.BookingStatus
    channel: $Enums.PurchaseChannel
    totalPriceCents: number
    customerId?: number | null
    soldById?: number | null
    customerEmail?: string | null
    credits?: CinemaCreditUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutTicketsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutTicketsInput, BookingUncheckedCreateWithoutTicketsInput>
  }

  export type SeatCreateWithoutTicketsInput = {
    id?: string
    rowLabel: string
    number: number
    status?: $Enums.SeatStatus
    createdAt?: Date | string
    showing: ShowingCreateNestedOneWithoutSeatsInput
    hold?: SeatHoldCreateNestedOneWithoutSeatInput
  }

  export type SeatUncheckedCreateWithoutTicketsInput = {
    id?: string
    showingId: string
    rowLabel: string
    number: number
    status?: $Enums.SeatStatus
    createdAt?: Date | string
    hold?: SeatHoldUncheckedCreateNestedOneWithoutSeatInput
  }

  export type SeatCreateOrConnectWithoutTicketsInput = {
    where: SeatWhereUniqueInput
    create: XOR<SeatCreateWithoutTicketsInput, SeatUncheckedCreateWithoutTicketsInput>
  }

  export type BookingUpsertWithoutTicketsInput = {
    update: XOR<BookingUpdateWithoutTicketsInput, BookingUncheckedUpdateWithoutTicketsInput>
    create: XOR<BookingCreateWithoutTicketsInput, BookingUncheckedCreateWithoutTicketsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutTicketsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutTicketsInput, BookingUncheckedUpdateWithoutTicketsInput>
  }

  export type BookingUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    channel?: EnumPurchaseChannelFieldUpdateOperationsInput | $Enums.PurchaseChannel
    totalPriceCents?: IntFieldUpdateOperationsInput | number
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: UserUpdateOneWithoutBookingsNestedInput
    soldBy?: UserUpdateOneWithoutSoldBookingsNestedInput
    credits?: CinemaCreditUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    channel?: EnumPurchaseChannelFieldUpdateOperationsInput | $Enums.PurchaseChannel
    totalPriceCents?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    soldById?: NullableIntFieldUpdateOperationsInput | number | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: CinemaCreditUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type SeatUpsertWithoutTicketsInput = {
    update: XOR<SeatUpdateWithoutTicketsInput, SeatUncheckedUpdateWithoutTicketsInput>
    create: XOR<SeatCreateWithoutTicketsInput, SeatUncheckedCreateWithoutTicketsInput>
    where?: SeatWhereInput
  }

  export type SeatUpdateToOneWithWhereWithoutTicketsInput = {
    where?: SeatWhereInput
    data: XOR<SeatUpdateWithoutTicketsInput, SeatUncheckedUpdateWithoutTicketsInput>
  }

  export type SeatUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowLabel?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    showing?: ShowingUpdateOneRequiredWithoutSeatsNestedInput
    hold?: SeatHoldUpdateOneWithoutSeatNestedInput
  }

  export type SeatUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    showingId?: StringFieldUpdateOperationsInput | string
    rowLabel?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hold?: SeatHoldUncheckedUpdateOneWithoutSeatNestedInput
  }

  export type UserCreateWithoutCinemaCreditsInput = {
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
    patents?: PatentCreateNestedManyWithoutUserInput
    deletedPatent?: DeletedPatentsCreateNestedManyWithoutUserInput
    sellPoint?: SellPointCreateNestedManyWithoutUserInput
    sellingHoursReports?: SellingHoursReportsCreateNestedManyWithoutUserInput
    parking?: ParkingCreateNestedManyWithoutUserInput
    userReports?: UserHoursReportsCreateNestedManyWithoutUserInput
    userParkingReports?: UserParkingReportsCreateNestedManyWithoutUserInput
    paidInfractions?: InfractionCreateNestedManyWithoutPayedByUserInput
    receivedHoursSales?: SellingHoursReportsCreateNestedManyWithoutTargetUserInput
    bookings?: BookingCreateNestedManyWithoutCustomerInput
    soldBookings?: BookingCreateNestedManyWithoutSoldByInput
    seatHolds?: SeatHoldCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCinemaCreditsInput = {
    id?: number
    name: string
    lastName: string
    email: string
    password: string
    type: number
    dni: number
    role?: $Enums.Role
    availableHours?: number | null
    availableMinutes?: number | null
    usedHours?: number | null
    recoveryCode?: number | null
    patents?: PatentUncheckedCreateNestedManyWithoutUserInput
    deletedPatent?: DeletedPatentsUncheckedCreateNestedManyWithoutUserInput
    sellPoint?: SellPointUncheckedCreateNestedManyWithoutUserInput
    sellingHoursReports?: SellingHoursReportsUncheckedCreateNestedManyWithoutUserInput
    parking?: ParkingUncheckedCreateNestedManyWithoutUserInput
    userReports?: UserHoursReportsUncheckedCreateNestedManyWithoutUserInput
    userParkingReports?: UserParkingReportsUncheckedCreateNestedManyWithoutUserInput
    paidInfractions?: InfractionUncheckedCreateNestedManyWithoutPayedByUserInput
    receivedHoursSales?: SellingHoursReportsUncheckedCreateNestedManyWithoutTargetUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutCustomerInput
    soldBookings?: BookingUncheckedCreateNestedManyWithoutSoldByInput
    seatHolds?: SeatHoldUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCinemaCreditsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCinemaCreditsInput, UserUncheckedCreateWithoutCinemaCreditsInput>
  }

  export type BookingCreateWithoutCreditsInput = {
    id?: string
    createdAt?: Date | string
    status: $Enums.BookingStatus
    channel: $Enums.PurchaseChannel
    totalPriceCents: number
    customerEmail?: string | null
    customer?: UserCreateNestedOneWithoutBookingsInput
    soldBy?: UserCreateNestedOneWithoutSoldBookingsInput
    tickets?: TicketCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutCreditsInput = {
    id?: string
    createdAt?: Date | string
    status: $Enums.BookingStatus
    channel: $Enums.PurchaseChannel
    totalPriceCents: number
    customerId?: number | null
    soldById?: number | null
    customerEmail?: string | null
    tickets?: TicketUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutCreditsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutCreditsInput, BookingUncheckedCreateWithoutCreditsInput>
  }

  export type ShowingCreateWithoutCreditsInput = {
    id?: string
    startTime: Date | string
    priceCents: number
    rows: number
    seatsPerRow: number
    totalSeats: number
    status?: $Enums.ShowingStatus
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    movie: MovieCreateNestedOneWithoutShowingsInput
    seats?: SeatCreateNestedManyWithoutShowingInput
    seatHolds?: SeatHoldCreateNestedManyWithoutShowingInput
  }

  export type ShowingUncheckedCreateWithoutCreditsInput = {
    id?: string
    movieId: string
    startTime: Date | string
    priceCents: number
    rows: number
    seatsPerRow: number
    totalSeats: number
    status?: $Enums.ShowingStatus
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    seats?: SeatUncheckedCreateNestedManyWithoutShowingInput
    seatHolds?: SeatHoldUncheckedCreateNestedManyWithoutShowingInput
  }

  export type ShowingCreateOrConnectWithoutCreditsInput = {
    where: ShowingWhereUniqueInput
    create: XOR<ShowingCreateWithoutCreditsInput, ShowingUncheckedCreateWithoutCreditsInput>
  }

  export type UserUpsertWithoutCinemaCreditsInput = {
    update: XOR<UserUpdateWithoutCinemaCreditsInput, UserUncheckedUpdateWithoutCinemaCreditsInput>
    create: XOR<UserCreateWithoutCinemaCreditsInput, UserUncheckedCreateWithoutCinemaCreditsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCinemaCreditsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCinemaCreditsInput, UserUncheckedUpdateWithoutCinemaCreditsInput>
  }

  export type UserUpdateWithoutCinemaCreditsInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
    patents?: PatentUpdateManyWithoutUserNestedInput
    deletedPatent?: DeletedPatentsUpdateManyWithoutUserNestedInput
    sellPoint?: SellPointUpdateManyWithoutUserNestedInput
    sellingHoursReports?: SellingHoursReportsUpdateManyWithoutUserNestedInput
    parking?: ParkingUpdateManyWithoutUserNestedInput
    userReports?: UserHoursReportsUpdateManyWithoutUserNestedInput
    userParkingReports?: UserParkingReportsUpdateManyWithoutUserNestedInput
    paidInfractions?: InfractionUpdateManyWithoutPayedByUserNestedInput
    receivedHoursSales?: SellingHoursReportsUpdateManyWithoutTargetUserNestedInput
    bookings?: BookingUpdateManyWithoutCustomerNestedInput
    soldBookings?: BookingUpdateManyWithoutSoldByNestedInput
    seatHolds?: SeatHoldUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCinemaCreditsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    dni?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    availableHours?: NullableIntFieldUpdateOperationsInput | number | null
    availableMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    usedHours?: NullableIntFieldUpdateOperationsInput | number | null
    recoveryCode?: NullableIntFieldUpdateOperationsInput | number | null
    patents?: PatentUncheckedUpdateManyWithoutUserNestedInput
    deletedPatent?: DeletedPatentsUncheckedUpdateManyWithoutUserNestedInput
    sellPoint?: SellPointUncheckedUpdateManyWithoutUserNestedInput
    sellingHoursReports?: SellingHoursReportsUncheckedUpdateManyWithoutUserNestedInput
    parking?: ParkingUncheckedUpdateManyWithoutUserNestedInput
    userReports?: UserHoursReportsUncheckedUpdateManyWithoutUserNestedInput
    userParkingReports?: UserParkingReportsUncheckedUpdateManyWithoutUserNestedInput
    paidInfractions?: InfractionUncheckedUpdateManyWithoutPayedByUserNestedInput
    receivedHoursSales?: SellingHoursReportsUncheckedUpdateManyWithoutTargetUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutCustomerNestedInput
    soldBookings?: BookingUncheckedUpdateManyWithoutSoldByNestedInput
    seatHolds?: SeatHoldUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BookingUpsertWithoutCreditsInput = {
    update: XOR<BookingUpdateWithoutCreditsInput, BookingUncheckedUpdateWithoutCreditsInput>
    create: XOR<BookingCreateWithoutCreditsInput, BookingUncheckedCreateWithoutCreditsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutCreditsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutCreditsInput, BookingUncheckedUpdateWithoutCreditsInput>
  }

  export type BookingUpdateWithoutCreditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    channel?: EnumPurchaseChannelFieldUpdateOperationsInput | $Enums.PurchaseChannel
    totalPriceCents?: IntFieldUpdateOperationsInput | number
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: UserUpdateOneWithoutBookingsNestedInput
    soldBy?: UserUpdateOneWithoutSoldBookingsNestedInput
    tickets?: TicketUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutCreditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    channel?: EnumPurchaseChannelFieldUpdateOperationsInput | $Enums.PurchaseChannel
    totalPriceCents?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    soldById?: NullableIntFieldUpdateOperationsInput | number | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tickets?: TicketUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type ShowingUpsertWithoutCreditsInput = {
    update: XOR<ShowingUpdateWithoutCreditsInput, ShowingUncheckedUpdateWithoutCreditsInput>
    create: XOR<ShowingCreateWithoutCreditsInput, ShowingUncheckedCreateWithoutCreditsInput>
    where?: ShowingWhereInput
  }

  export type ShowingUpdateToOneWithWhereWithoutCreditsInput = {
    where?: ShowingWhereInput
    data: XOR<ShowingUpdateWithoutCreditsInput, ShowingUncheckedUpdateWithoutCreditsInput>
  }

  export type ShowingUpdateWithoutCreditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    priceCents?: IntFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    seatsPerRow?: IntFieldUpdateOperationsInput | number
    totalSeats?: IntFieldUpdateOperationsInput | number
    status?: EnumShowingStatusFieldUpdateOperationsInput | $Enums.ShowingStatus
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movie?: MovieUpdateOneRequiredWithoutShowingsNestedInput
    seats?: SeatUpdateManyWithoutShowingNestedInput
    seatHolds?: SeatHoldUpdateManyWithoutShowingNestedInput
  }

  export type ShowingUncheckedUpdateWithoutCreditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    priceCents?: IntFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    seatsPerRow?: IntFieldUpdateOperationsInput | number
    totalSeats?: IntFieldUpdateOperationsInput | number
    status?: EnumShowingStatusFieldUpdateOperationsInput | $Enums.ShowingStatus
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seats?: SeatUncheckedUpdateManyWithoutShowingNestedInput
    seatHolds?: SeatHoldUncheckedUpdateManyWithoutShowingNestedInput
  }

  export type PatentCreateManyUserInput = {
    id?: number
    patentId: string
    createdAt?: Date | string
    hasSingleHours?: boolean
    singleHours?: number
    dni?: number | null
    isAllowed?: boolean
    canShow?: boolean
    isAllowedIn?: string | null
    houseType?: string | null
  }

  export type DeletedPatentsCreateManyUserInput = {
    id?: number
    patentId: string
    deletedAt?: Date | string | null
  }

  export type SellPointCreateManyUserInput = {
    id?: number
    address: string
    street?: string | null
    streetNumber?: number | null
    availableHours?: number
    usedHours?: number
    pointName: string
    dni?: number | null
    profitPercentage: number
  }

  export type SellingHoursReportsCreateManyUserInput = {
    id?: string
    hoursAdded: number
    addedAt: Date | string
    hourPrice: number
    soldBy?: number | null
    targetUserId?: number | null
  }

  export type ParkingCreateManyUserInput = {
    id?: string
    hours: number
    startedAt?: Date | string
    finishedAt?: Date | string | null
    patentId: string
    isMonthly?: boolean
  }

  export type UserHoursReportsCreateManyUserInput = {
    id?: string
    hoursBought: number
    boughtAt: Date | string
    hourPrice: number
    soldBy: number
  }

  export type UserParkingReportsCreateManyUserInput = {
    id?: string
    startedAt: Date | string
    finishedAt: Date | string
    patentId: string
    totalHours: number
    hourPrice: number
  }

  export type InfractionCreateManyPayedByUserInput = {
    id?: string
    numberId?: number
    createdAt: Date | string
    cancelled?: boolean
    cancelledAt?: Date | string | null
    cancelledReason?: string | null
    patentId: string
    street?: string | null
    payed: boolean
    payedAt?: Date | string | null
    isEnableToPay?: boolean | null
    paymentMethod?: string | null
  }

  export type SellingHoursReportsCreateManyTargetUserInput = {
    id?: string
    hoursAdded: number
    addedAt: Date | string
    userId: number
    hourPrice: number
    soldBy?: number | null
  }

  export type BookingCreateManyCustomerInput = {
    id?: string
    createdAt?: Date | string
    status: $Enums.BookingStatus
    channel: $Enums.PurchaseChannel
    totalPriceCents: number
    soldById?: number | null
    customerEmail?: string | null
  }

  export type BookingCreateManySoldByInput = {
    id?: string
    createdAt?: Date | string
    status: $Enums.BookingStatus
    channel: $Enums.PurchaseChannel
    totalPriceCents: number
    customerId?: number | null
    customerEmail?: string | null
  }

  export type SeatHoldCreateManyUserInput = {
    id?: string
    seatId: string
    showingId: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type CinemaCreditCreateManyUserInput = {
    id?: string
    bookingId?: string | null
    showingId?: string | null
    amountCents: number
    remainingCents: number
    reason: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type PatentUpdateWithoutUserInput = {
    patentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasSingleHours?: BoolFieldUpdateOperationsInput | boolean
    singleHours?: IntFieldUpdateOperationsInput | number
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowed?: BoolFieldUpdateOperationsInput | boolean
    canShow?: BoolFieldUpdateOperationsInput | boolean
    isAllowedIn?: NullableStringFieldUpdateOperationsInput | string | null
    houseType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    patentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasSingleHours?: BoolFieldUpdateOperationsInput | boolean
    singleHours?: IntFieldUpdateOperationsInput | number
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowed?: BoolFieldUpdateOperationsInput | boolean
    canShow?: BoolFieldUpdateOperationsInput | boolean
    isAllowedIn?: NullableStringFieldUpdateOperationsInput | string | null
    houseType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    patentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasSingleHours?: BoolFieldUpdateOperationsInput | boolean
    singleHours?: IntFieldUpdateOperationsInput | number
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowed?: BoolFieldUpdateOperationsInput | boolean
    canShow?: BoolFieldUpdateOperationsInput | boolean
    isAllowedIn?: NullableStringFieldUpdateOperationsInput | string | null
    houseType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeletedPatentsUpdateWithoutUserInput = {
    patentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeletedPatentsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    patentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeletedPatentsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    patentId?: StringFieldUpdateOperationsInput | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SellPointUpdateWithoutUserInput = {
    address?: StringFieldUpdateOperationsInput | string
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableIntFieldUpdateOperationsInput | number | null
    availableHours?: IntFieldUpdateOperationsInput | number
    usedHours?: IntFieldUpdateOperationsInput | number
    pointName?: StringFieldUpdateOperationsInput | string
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    profitPercentage?: IntFieldUpdateOperationsInput | number
    reports?: AssignHoursReportsUpdateManyWithoutSellPointNestedInput
    patentReports?: AssignPatentHoursReportsUpdateManyWithoutSellPointNestedInput
  }

  export type SellPointUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableIntFieldUpdateOperationsInput | number | null
    availableHours?: IntFieldUpdateOperationsInput | number
    usedHours?: IntFieldUpdateOperationsInput | number
    pointName?: StringFieldUpdateOperationsInput | string
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    profitPercentage?: IntFieldUpdateOperationsInput | number
    reports?: AssignHoursReportsUncheckedUpdateManyWithoutSellPointNestedInput
    patentReports?: AssignPatentHoursReportsUncheckedUpdateManyWithoutSellPointNestedInput
  }

  export type SellPointUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    street?: NullableStringFieldUpdateOperationsInput | string | null
    streetNumber?: NullableIntFieldUpdateOperationsInput | number | null
    availableHours?: IntFieldUpdateOperationsInput | number
    usedHours?: IntFieldUpdateOperationsInput | number
    pointName?: StringFieldUpdateOperationsInput | string
    dni?: NullableIntFieldUpdateOperationsInput | number | null
    profitPercentage?: IntFieldUpdateOperationsInput | number
  }

  export type SellingHoursReportsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursAdded?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hourPrice?: FloatFieldUpdateOperationsInput | number
    soldBy?: NullableIntFieldUpdateOperationsInput | number | null
    targetUser?: UserUpdateOneWithoutReceivedHoursSalesNestedInput
  }

  export type SellingHoursReportsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursAdded?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hourPrice?: FloatFieldUpdateOperationsInput | number
    soldBy?: NullableIntFieldUpdateOperationsInput | number | null
    targetUserId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SellingHoursReportsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursAdded?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hourPrice?: FloatFieldUpdateOperationsInput | number
    soldBy?: NullableIntFieldUpdateOperationsInput | number | null
    targetUserId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ParkingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    hours?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patentId?: StringFieldUpdateOperationsInput | string
    isMonthly?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ParkingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    hours?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patentId?: StringFieldUpdateOperationsInput | string
    isMonthly?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ParkingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    hours?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patentId?: StringFieldUpdateOperationsInput | string
    isMonthly?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserHoursReportsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursBought?: IntFieldUpdateOperationsInput | number
    boughtAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hourPrice?: FloatFieldUpdateOperationsInput | number
    soldBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserHoursReportsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursBought?: IntFieldUpdateOperationsInput | number
    boughtAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hourPrice?: FloatFieldUpdateOperationsInput | number
    soldBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserHoursReportsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursBought?: IntFieldUpdateOperationsInput | number
    boughtAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hourPrice?: FloatFieldUpdateOperationsInput | number
    soldBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserParkingReportsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patentId?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    hourPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type UserParkingReportsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patentId?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    hourPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type UserParkingReportsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patentId?: StringFieldUpdateOperationsInput | string
    totalHours?: IntFieldUpdateOperationsInput | number
    hourPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type InfractionUpdateWithoutPayedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledReason?: NullableStringFieldUpdateOperationsInput | string | null
    patentId?: StringFieldUpdateOperationsInput | string
    street?: NullableStringFieldUpdateOperationsInput | string | null
    payed?: BoolFieldUpdateOperationsInput | boolean
    payedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEnableToPay?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    images?: InfractionImageUpdateManyWithoutInfractionNestedInput
  }

  export type InfractionUncheckedUpdateWithoutPayedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    numberId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledReason?: NullableStringFieldUpdateOperationsInput | string | null
    patentId?: StringFieldUpdateOperationsInput | string
    street?: NullableStringFieldUpdateOperationsInput | string | null
    payed?: BoolFieldUpdateOperationsInput | boolean
    payedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEnableToPay?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    images?: InfractionImageUncheckedUpdateManyWithoutInfractionNestedInput
  }

  export type InfractionUncheckedUpdateManyWithoutPayedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    numberId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelled?: BoolFieldUpdateOperationsInput | boolean
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledReason?: NullableStringFieldUpdateOperationsInput | string | null
    patentId?: StringFieldUpdateOperationsInput | string
    street?: NullableStringFieldUpdateOperationsInput | string | null
    payed?: BoolFieldUpdateOperationsInput | boolean
    payedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEnableToPay?: NullableBoolFieldUpdateOperationsInput | boolean | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SellingHoursReportsUpdateWithoutTargetUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursAdded?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hourPrice?: FloatFieldUpdateOperationsInput | number
    soldBy?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutSellingHoursReportsNestedInput
  }

  export type SellingHoursReportsUncheckedUpdateWithoutTargetUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursAdded?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    hourPrice?: FloatFieldUpdateOperationsInput | number
    soldBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SellingHoursReportsUncheckedUpdateManyWithoutTargetUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursAdded?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    hourPrice?: FloatFieldUpdateOperationsInput | number
    soldBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BookingUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    channel?: EnumPurchaseChannelFieldUpdateOperationsInput | $Enums.PurchaseChannel
    totalPriceCents?: IntFieldUpdateOperationsInput | number
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    soldBy?: UserUpdateOneWithoutSoldBookingsNestedInput
    tickets?: TicketUpdateManyWithoutBookingNestedInput
    credits?: CinemaCreditUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    channel?: EnumPurchaseChannelFieldUpdateOperationsInput | $Enums.PurchaseChannel
    totalPriceCents?: IntFieldUpdateOperationsInput | number
    soldById?: NullableIntFieldUpdateOperationsInput | number | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tickets?: TicketUncheckedUpdateManyWithoutBookingNestedInput
    credits?: CinemaCreditUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    channel?: EnumPurchaseChannelFieldUpdateOperationsInput | $Enums.PurchaseChannel
    totalPriceCents?: IntFieldUpdateOperationsInput | number
    soldById?: NullableIntFieldUpdateOperationsInput | number | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingUpdateWithoutSoldByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    channel?: EnumPurchaseChannelFieldUpdateOperationsInput | $Enums.PurchaseChannel
    totalPriceCents?: IntFieldUpdateOperationsInput | number
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: UserUpdateOneWithoutBookingsNestedInput
    tickets?: TicketUpdateManyWithoutBookingNestedInput
    credits?: CinemaCreditUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutSoldByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    channel?: EnumPurchaseChannelFieldUpdateOperationsInput | $Enums.PurchaseChannel
    totalPriceCents?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tickets?: TicketUncheckedUpdateManyWithoutBookingNestedInput
    credits?: CinemaCreditUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutSoldByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    channel?: EnumPurchaseChannelFieldUpdateOperationsInput | $Enums.PurchaseChannel
    totalPriceCents?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SeatHoldUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seat?: SeatUpdateOneRequiredWithoutHoldNestedInput
    showing?: ShowingUpdateOneRequiredWithoutSeatHoldsNestedInput
  }

  export type SeatHoldUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatId?: StringFieldUpdateOperationsInput | string
    showingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatHoldUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatId?: StringFieldUpdateOperationsInput | string
    showingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CinemaCreditUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    remainingCents?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    booking?: BookingUpdateOneWithoutCreditsNestedInput
    showing?: ShowingUpdateOneWithoutCreditsNestedInput
  }

  export type CinemaCreditUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    showingId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    remainingCents?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CinemaCreditUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    showingId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    remainingCents?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssignHoursReportsCreateManySellPointInput = {
    id?: string
    hoursAdded: number
    addedAt: Date | string
    hourPrice: number
    soldBy?: number | null
  }

  export type AssignPatentHoursReportsCreateManySellPointInput = {
    id?: string
    hoursAdded: number
    addedAt: Date | string
    hourPrice: number
    patentId: string
    dni: number
    soldBy?: number | null
  }

  export type AssignHoursReportsUpdateWithoutSellPointInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursAdded?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hourPrice?: FloatFieldUpdateOperationsInput | number
    soldBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AssignHoursReportsUncheckedUpdateWithoutSellPointInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursAdded?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hourPrice?: FloatFieldUpdateOperationsInput | number
    soldBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AssignHoursReportsUncheckedUpdateManyWithoutSellPointInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursAdded?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hourPrice?: FloatFieldUpdateOperationsInput | number
    soldBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AssignPatentHoursReportsUpdateWithoutSellPointInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursAdded?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hourPrice?: FloatFieldUpdateOperationsInput | number
    patentId?: StringFieldUpdateOperationsInput | string
    dni?: IntFieldUpdateOperationsInput | number
    soldBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AssignPatentHoursReportsUncheckedUpdateWithoutSellPointInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursAdded?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hourPrice?: FloatFieldUpdateOperationsInput | number
    patentId?: StringFieldUpdateOperationsInput | string
    dni?: IntFieldUpdateOperationsInput | number
    soldBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AssignPatentHoursReportsUncheckedUpdateManyWithoutSellPointInput = {
    id?: StringFieldUpdateOperationsInput | string
    hoursAdded?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hourPrice?: FloatFieldUpdateOperationsInput | number
    patentId?: StringFieldUpdateOperationsInput | string
    dni?: IntFieldUpdateOperationsInput | number
    soldBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InfractionImageCreateManyInfractionInput = {
    id?: string
    url: string
    createdAt?: Date | string
  }

  export type InfractionImageUpdateWithoutInfractionInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfractionImageUncheckedUpdateWithoutInfractionInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfractionImageUncheckedUpdateManyWithoutInfractionInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShowingCreateManyMovieInput = {
    id?: string
    startTime: Date | string
    priceCents: number
    rows: number
    seatsPerRow: number
    totalSeats: number
    status?: $Enums.ShowingStatus
    cancelledAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ShowingUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    priceCents?: IntFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    seatsPerRow?: IntFieldUpdateOperationsInput | number
    totalSeats?: IntFieldUpdateOperationsInput | number
    status?: EnumShowingStatusFieldUpdateOperationsInput | $Enums.ShowingStatus
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seats?: SeatUpdateManyWithoutShowingNestedInput
    seatHolds?: SeatHoldUpdateManyWithoutShowingNestedInput
    credits?: CinemaCreditUpdateManyWithoutShowingNestedInput
  }

  export type ShowingUncheckedUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    priceCents?: IntFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    seatsPerRow?: IntFieldUpdateOperationsInput | number
    totalSeats?: IntFieldUpdateOperationsInput | number
    status?: EnumShowingStatusFieldUpdateOperationsInput | $Enums.ShowingStatus
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seats?: SeatUncheckedUpdateManyWithoutShowingNestedInput
    seatHolds?: SeatHoldUncheckedUpdateManyWithoutShowingNestedInput
    credits?: CinemaCreditUncheckedUpdateManyWithoutShowingNestedInput
  }

  export type ShowingUncheckedUpdateManyWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    priceCents?: IntFieldUpdateOperationsInput | number
    rows?: IntFieldUpdateOperationsInput | number
    seatsPerRow?: IntFieldUpdateOperationsInput | number
    totalSeats?: IntFieldUpdateOperationsInput | number
    status?: EnumShowingStatusFieldUpdateOperationsInput | $Enums.ShowingStatus
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatCreateManyShowingInput = {
    id?: string
    rowLabel: string
    number: number
    status?: $Enums.SeatStatus
    createdAt?: Date | string
  }

  export type SeatHoldCreateManyShowingInput = {
    id?: string
    seatId: string
    userId: number
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type CinemaCreditCreateManyShowingInput = {
    id?: string
    userId: number
    bookingId?: string | null
    amountCents: number
    remainingCents: number
    reason: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type SeatUpdateWithoutShowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowLabel?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutSeatNestedInput
    hold?: SeatHoldUpdateOneWithoutSeatNestedInput
  }

  export type SeatUncheckedUpdateWithoutShowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowLabel?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutSeatNestedInput
    hold?: SeatHoldUncheckedUpdateOneWithoutSeatNestedInput
  }

  export type SeatUncheckedUpdateManyWithoutShowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowLabel?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    status?: EnumSeatStatusFieldUpdateOperationsInput | $Enums.SeatStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatHoldUpdateWithoutShowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seat?: SeatUpdateOneRequiredWithoutHoldNestedInput
    user?: UserUpdateOneRequiredWithoutSeatHoldsNestedInput
  }

  export type SeatHoldUncheckedUpdateWithoutShowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeatHoldUncheckedUpdateManyWithoutShowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatId?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CinemaCreditUpdateWithoutShowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    remainingCents?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCinemaCreditsNestedInput
    booking?: BookingUpdateOneWithoutCreditsNestedInput
  }

  export type CinemaCreditUncheckedUpdateWithoutShowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    remainingCents?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CinemaCreditUncheckedUpdateManyWithoutShowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    remainingCents?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TicketCreateManySeatInput = {
    id?: string
    bookingId: string
    qrToken: string
    checkedInAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TicketUpdateWithoutSeatInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrToken?: StringFieldUpdateOperationsInput | string
    checkedInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateWithoutSeatInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    qrToken?: StringFieldUpdateOperationsInput | string
    checkedInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUncheckedUpdateManyWithoutSeatInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    qrToken?: StringFieldUpdateOperationsInput | string
    checkedInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCreateManyBookingInput = {
    id?: string
    seatId: string
    qrToken: string
    checkedInAt?: Date | string | null
    createdAt?: Date | string
  }

  export type CinemaCreditCreateManyBookingInput = {
    id?: string
    userId: number
    showingId?: string | null
    amountCents: number
    remainingCents: number
    reason: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type TicketUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrToken?: StringFieldUpdateOperationsInput | string
    checkedInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seat?: SeatUpdateOneRequiredWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatId?: StringFieldUpdateOperationsInput | string
    qrToken?: StringFieldUpdateOperationsInput | string
    checkedInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatId?: StringFieldUpdateOperationsInput | string
    qrToken?: StringFieldUpdateOperationsInput | string
    checkedInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CinemaCreditUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountCents?: IntFieldUpdateOperationsInput | number
    remainingCents?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCinemaCreditsNestedInput
    showing?: ShowingUpdateOneWithoutCreditsNestedInput
  }

  export type CinemaCreditUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    showingId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    remainingCents?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CinemaCreditUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    showingId?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    remainingCents?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SellPointCountOutputTypeDefaultArgs instead
     */
    export type SellPointCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SellPointCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InfractionCountOutputTypeDefaultArgs instead
     */
    export type InfractionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InfractionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MovieCountOutputTypeDefaultArgs instead
     */
    export type MovieCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MovieCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShowingCountOutputTypeDefaultArgs instead
     */
    export type ShowingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShowingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SeatCountOutputTypeDefaultArgs instead
     */
    export type SeatCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SeatCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingCountOutputTypeDefaultArgs instead
     */
    export type BookingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SellPointDefaultArgs instead
     */
    export type SellPointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SellPointDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatentDefaultArgs instead
     */
    export type PatentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatentValidationDefaultArgs instead
     */
    export type PatentValidationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatentValidationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeletedPatentsDefaultArgs instead
     */
    export type DeletedPatentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeletedPatentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssignHoursReportsDefaultArgs instead
     */
    export type AssignHoursReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssignHoursReportsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssignPatentHoursReportsDefaultArgs instead
     */
    export type AssignPatentHoursReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssignPatentHoursReportsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SellingHoursReportsDefaultArgs instead
     */
    export type SellingHoursReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SellingHoursReportsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserHoursReportsDefaultArgs instead
     */
    export type UserHoursReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserHoursReportsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserParkingReportsDefaultArgs instead
     */
    export type UserParkingReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserParkingReportsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HoursPricesDefaultArgs instead
     */
    export type HoursPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HoursPricesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParkingDefaultArgs instead
     */
    export type ParkingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParkingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InfractionDefaultArgs instead
     */
    export type InfractionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InfractionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InfractionImageDefaultArgs instead
     */
    export type InfractionImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InfractionImageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SingleParkingComprobantDefaultArgs instead
     */
    export type SingleParkingComprobantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SingleParkingComprobantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SellingHoursComprobantDefaultArgs instead
     */
    export type SellingHoursComprobantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SellingHoursComprobantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HolidayDefaultArgs instead
     */
    export type HolidayArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HolidayDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SellingPointHoursComprobantDefaultArgs instead
     */
    export type SellingPointHoursComprobantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SellingPointHoursComprobantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SellingMonthlyComprobantDefaultArgs instead
     */
    export type SellingMonthlyComprobantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SellingMonthlyComprobantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MovieDefaultArgs instead
     */
    export type MovieArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MovieDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShowingDefaultArgs instead
     */
    export type ShowingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShowingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SeatDefaultArgs instead
     */
    export type SeatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SeatDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SeatHoldDefaultArgs instead
     */
    export type SeatHoldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SeatHoldDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingDefaultArgs instead
     */
    export type BookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketDefaultArgs instead
     */
    export type TicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CinemaCreditDefaultArgs instead
     */
    export type CinemaCreditArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CinemaCreditDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}